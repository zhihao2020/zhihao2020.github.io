{"categories":[{"title":"Python","uri":"https://zhihao2020.github.io/categories/python/"},{"title":"学习能力","uri":"https://zhihao2020.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B/"},{"title":"建筑方面","uri":"https://zhihao2020.github.io/categories/%E5%BB%BA%E7%AD%91%E6%96%B9%E9%9D%A2/"},{"title":"效率工具","uri":"https://zhihao2020.github.io/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"},{"title":"数据分析","uri":"https://zhihao2020.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"title":"杂七杂八","uri":"https://zhihao2020.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"title":"生活","uri":"https://zhihao2020.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"posts":[{"content":"调用 关于 __call__ 方法，不得不先提到一个概念，就是可调用对象（callable），我们平时自定义的函数、内置函数和类都属于可调用对象，但凡是可以把一对括号()应用到某个对象身上都可称之为可调用对象，判断对象是否为可调用对象可以用函数 __call__有无。\n如果在类中实现了 __call__ 方法，那么实例化对象也将成为一个可调用对象，\n __call__(self, [args\u0026hellip;])\n __call __ 在那些类的实例经常改变状态的时候会非常有效。调用这个实例是一种改变这个对象状态的直接和优雅的做法。用一个实例来表达最好不过了:\nclass Entity:\r'''调用实体来改变实体的位置。'''\rdef __init__(self, size, x, y):\rself.x, self.y = x, y\rself.size = size\rdef __call__(self, x, y):\r'''改变实体的位置'''\rself.x, self.y = x, y\re = Entity(1, 2, 3) // 创建实例\re(4, 5) //实例可以象函数那样执行，并传入x y值，修改对象的x y\r __call__其他作用 实例对象也可以像函数一样作为可调用对象来用，那么，这个特点在什么场景用得上呢？\n这个要结合类的特性来说，类可以记录数据（属性），而函数不行（闭包某种意义上也可行），利用这种特性可以实现基于类的装饰器，在类里面记录状态，比如，下面这个例子用于记录函数被调用的次数：\nclass Counter:\rdef __init__(self, func):\rself.func = func\rself.count = 0\rdef __call__(self, *args, **kwargs):\rself.count += 1\rreturn self.func(*args, **kwargs)\r@Counter\rdef foo():\rpass\rfor i in range(10):\rfoo()\rprint(foo.count) # 10\r ","id":0,"section":"posts","summary":"调用 关于 __call__ 方法，不得不先提到一个概念，就是可调用对象（callable），我们平时自定义的函数、内置函数和类都属于可调用对象，但凡是可以把一","tags":["Python魔法方法"],"title":"Python中的__call__方法","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84__call__/","year":"2020"},{"content":" 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法\n __new__的作用 在Python中__new__方法与__init__方法类似，但是如果两个都存在那么__new__会先执行。\n在基础类object中，__new__被定义成了一个静态方法，并且需要传递一个参数cls。Cls表示需要实例化的类，此参数在实例化时由Python解析器自动提供。\nnew()是在新式类中新出现的方法，它作用在构造方法init()建造实例之前，可以这么理解，在Python 中存在于类里面的构造方法init()负责将类的实例化，而在init()调用之前，new()决定是否要使用该init()方法，因为new()可以调用其他类的构造方法或者直接返回别的对象来作为本类 的实例。\nnew()方法的特性 new()方法是在类准备将自身实例化时调用。\nnew()方法始终都是类的静态方法，即使没有被加上静态方法装饰器。\n实例 class Person(object):\rdef __new__(cls, name, age):\rif 0 \u0026lt; age \u0026lt; 150:\rreturn object.__new__(cls)\r# return super(Person, cls).__new__(cls)\relse:\rreturn None\rdef __init__(self, name, age):\rself.name = name\rself.age = age\rdef __str__(self):\rreturn '{0}({1})'.format(self.__class__.__name__, self.__dict__)\rprint(Person('Tom', 10))\rprint(Person('Mike', 200))\r 输出：\nPerson({'age': 10, 'name': 'Tom'})\rNone\r ","id":1,"section":"posts","summary":"在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 __new__的作用 在Python中__new_","tags":["Python魔法方法"],"title":"Python中的__new__方法","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84__new__/","year":"2020"},{"content":" 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法\n class Cat:\rdef __init__(self, new_name, new_age):\r\u0026quot;\u0026quot;\u0026quot;在创建完对象之后 会自动调用, 它完成对象的初始化的功能\u0026quot;\u0026quot;\u0026quot;\rself.name = new_name\rself.age = new_age def __str__(self):\r\u0026quot;\u0026quot;\u0026quot;返回一个对象的描述信息\u0026quot;\u0026quot;\u0026quot;\rreturn \u0026quot;名字是:%s , 年龄是:%d\u0026quot; % (self.name, self.age)\rdef eat(self):\rprint(\u0026quot;%s在吃鱼....\u0026quot; % self.name)\rdef drink(self):\rprint(\u0026quot;%s在喝可乐...\u0026quot; % self.name)\r# 创建了一个对象\rtom = Cat(\u0026quot;汤姆\u0026quot;, 30)\rprint(tom)\rprint(tom.eat())\rprint(tom.drink())\r 输出\n名字是:汤姆 , 年龄是:30\r汤姆在吃鱼....\rNone\r汤姆在喝可乐...\rNone\r ","id":2,"section":"posts","summary":"在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 class Cat: def __init__(self, new_name, new_age): \u0026quot;\u0026quot;\u0026quot;","tags":["Python魔法方法"],"title":"Python中的__str__方法","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84__str__/","year":"2020"},{"content":"@classmethod 返回函数的类方法\nclassmethod修饰符对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的cls参数，可以调用类的属性，类的方法，实例化对象等。\n实例 class test(object):\rbar = 1\rdef func1(self): print ('AAA') @classmethod\rdef func2(cls):\rprint ('func2')\rprint (cls.bar)\rcls().func1() test.func2() # 不需要实例化\r 输出：\nfunc2\r1\rAAA\r @staticmethod 返回函数的静态方法\nclass test(object):\r@staticmethod\rdef fun():\rprint('hello');\rtest.fun() # 静态方法无需实例化\robj = test()\robj.fun() # 也可以实例化后调用\r 输出：\nhello\rhello\r ","id":3,"section":"posts","summary":"@classmethod 返回函数的类方法 classmethod修饰符对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的cls参数，可以调用","tags":["Python内建函数"],"title":"Python中的staticmethod和classmethod","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84staticmethod%E5%92%8Cclassmethod/","year":"2020"},{"content":"介绍 **super()**函数是用于条用父类（超类)的一个方法。\nsuper 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用等种种问题。\nspuer()的使用案例 class Parent(object):\rdef __init__(self):\rself.parent = 'I\\'m the parent.'\rprint('Parent')\rdef bar(self, message):\rprint(\u0026quot;%s from Parent\u0026quot; % message)\rclass Child(Parent):#单继承\rdef __init__(self):\r# super(Child,self) 首先找到 Child 的父类（就是类 Parent），然后把Parent中的东西继承过来了。\rsuper(Child, self).__init__()\rprint('Child')\rdef bar(self, message):\rself.bar(message)\rprint('Child bar fuction')\rprint(self.parent)\rif __name__ == '__main__':\rfooChild = Child()\rfooChild.bar('HelloWorld')\r Parent\rChild\rHelloWorld from Parent\rChild bar fuction\rI'm the parent.\r ","id":4,"section":"posts","summary":"介绍 **super()**函数是用于条用父类（超类)的一个方法。 super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，","tags":["Python内建函数"],"title":"Python中的super()函数","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84super%E5%87%BD%E6%95%B0/","year":"2020"},{"content":"配置文件： [numbers]\rpi: 3.1415926\r[messages]\rgreeting: welcome to the area calculation program!\rquestion: Please emter the radius\rresult_message: The area is\r 使用示例 from ConfigParser import ConfigParser\rCONFIGFILE = ‘XXX.txt'\rconfig = ConfigParser()\r#读取配置文件\rconfig.read(CONFIGFILE)\r#打印初始问候语\r#要查看的区段是’messages‘\rprint(config.get('messages','greeting'))\r#使用配置文件的一个问题读取半径：\rradius = input(config.get('messages','question')+' ')\r#打印配置文件中的结果信息\r#以逗号结束，以在同一行显示\rprint(config.get('messages','result_message'))\r#getfloat()将config值转换为float类型\rprint(config.getfloat('numbers','pi') * radius **2)\r 方法 写入:\nimport configparser\rconfig = configparser.ConfigParser()\rconfig['DEFAULT'] = {'ServerAliveInterval': '45',\r'Compression': 'yes',\r'CompressionLevel': '9'}\rconfig['bitbucket.org'] = {}\rconfig['bitbucket.org']['User'] = 'hg'\rconfig['topsecret.server.com'] = {}\rtopsecret = config['topsecret.server.com']\rtopsecret['Port'] = '50022' # mutates the parser\rtopsecret['ForwardX11'] = 'no' # same here\rconfig['DEFAULT']['ForwardX11'] = 'yes'\rwith open('example.ini', 'w') as configfile:\rconfig.write(configfile)\r 注意： 它不去猜测配置文件中值得数据类型，而是始终将他们内部存储为字符串。\n于是提供了getint()、getfloat和getboolean()方法。\n例如，gwtboolean()用于处理布尔值，此方法不区分大小写，并从并从'yes'/ 'no'，'on'/ 'off'， 'true'/ 'false'和'1'/ '0' 识别布尔值。\n","id":5,"section":"posts","summary":"配置文件： [numbers] pi: 3.1415926 [messages] greeting: welcome to the area calculation program! question: Please emter the radius result_message: The area is 使用示例 from ConfigParser import ConfigParser CONFIGFILE = ‘XXX.txt' config = ConfigParser() #读取配置文件 config.read(CONFIGFILE) #打印初始问候语 #要查看的区段","tags":["Python标准库"],"title":"Python的一种简单配置文件的方法","uri":"https://zhihao2020.github.io/2020/04/python%E7%9A%84%E4%B8%80%E7%A7%8D%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/","year":"2020"},{"content":"函数也是对象 首先要明确一个概念，函数也是对象。\n于是，函数本身其实可以与其他的数据类型一样，作为其他函数的参数或者返回值。\ndef decorator(func):\rdef wrapper():\rprint(\u0026quot;we can do sth.Befor the func() is called...\u0026quot;)\rfunc()\rprint(\u0026quot;... and we can do sth. After it is called.. \u0026quot;)\rreturn wrapper()\rdef func()\rprint(\u0026quot;Hi, I'm func!\u0026quot;)\rfunc()\rdecorator(func)\r 输出如下：\nHi, I'm a_func!\rWe can do sth. before a func is called...\rHi, I'm a_func!\r... and we can do sth. after it is called...\r 但是，如果这样，那就不同了：\ndef decorator(func):\rdef wrapper():\rprint('We can do sth. before a func is called...')\rfunc()\rprint('... and we can do sth. after it is called...')\rreturn wrapper def func():\rprint(\u0026quot;Hi, I'm a_func!\u0026quot;)\rfunc()\rdecorator(func)\r Hi, I'm a_func!\r\u0026lt;function __main__.a_decorator.\u0026lt;locals\u0026gt;.wrapper()\u0026gt;\r 其实，这里 wrapper 是返回这个函数本身，而wrapper()则是返回这个函数的返回值。\n装饰器操作符 Python提供了一个针对函数的操作符@。\ndef decorator(func):\rdef wrapper():\rprint('We can do sth. before calling a_func...')\rfunc()\rprint('... and we can do sth. after it was called...')\rreturn wrapper\r@decorator\rdef func():\rprint(\u0026quot;Hi, I'm func!\u0026quot;)\rfunc()\r We can do sth. before calling a_func...\rHi, I'm a_func!\r... and we can do sth. after it was called...\r  注意：以上的代码中，decorator(func) 返回的是 wrapper 这个函数本身。而不是wrapper的返回值。\n 其中， 被 @ 调用的函数，叫做 “装饰器”（Decorator），比如，以上代码中的 decorator(func)。\n现在可以很简单直接地说清楚装饰器的作用了：\n@decorator\rdef func():\r...\r 等价于\ndef func():\r...\rfunc = decorator(func)\r 就是用 decorator 的调用结果替换掉原来的函数。decorator 返回值是什么，以后调用 func 时就是在调用这个返回值，而 decorator 本身此时已经执行完毕了。\n装饰器的用途 Decorator 最常用的场景是什么呢？最常用的场景就是用来改变其它函数的行为。\ndef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r The quick brown fox jumps over the lazy dog.\r def uppercase(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = original_result.upper()\rreturn modified_restult\rreturn wrapper\r@uppercase\rdef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\r 你还可以给一个函数加上一个以上的装饰器：\ndef uppercase(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = original_result.upper()\rreturn modified_restult\rreturn wrapper\rdef strong(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = '\u0026lt;strong\u0026gt;'+original_result+'\u0026lt;/strong\u0026gt;'\rreturn modified_restult\rreturn wrapper\r@uppercase\r@strong\rdef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r \u0026lt;STRONG\u0026gt;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\u0026lt;/STRONG\u0026gt;\r 你把两个装饰器的顺序调换一下写成下面这样试试：\n@uppercase\r@strong\rdef an_output():\r...\r 装饰器的执行顺序是 “自下而上” —— 其实是 “由里到外” 更为准确。体会一下。\n装饰带有参数的函数 到现在我们见到的使用装饰器的函数都是没有参数的：an_output 以及之前的 func。\n如果被装饰的函数有参数怎么办？装饰器自身内部又应该怎么写？\n这时候，Python 的 *args and **kwargs 的威力就显现出来了。\n装饰器函数本身这么写：\ndef decorator(func):\rdef wrapper(*args, **kwargs):\rreturn original_result\r# ... return wrapper\r 在这里，(*args, **kwargs) 非常强大，它可以匹配所有函数传进来的所有参数…… 准确地讲，*args 接收并处理所有传递进来的位置参数，**kwargs 接收并处理所有传递进来的关键字参数。\n假设我们有这么个函数：\ndef say_hi(greeting, name=None):\rreturn greeting + '! ' + name + '.'\rprint(say_hi('Hello', 'Jack'))\r Hello! Jack.\r 如果我们想在装饰器里对函数名、参数，都做些事情 —— 比如，我们写个 @trace 用来告诉用户调用一个函数的时候都发生了什么……\ndef trace(func):\rdef wrapper(*args, **kwargs):\rprint(f\u0026quot;Trace: You've called a function: {func.__name__}(),\u0026quot;,\rf\u0026quot;with args: {args}; kwargs: {kwargs}\u0026quot;)\roriginal_result = func(*args, **kwargs)\rprint(f\u0026quot;Trace: {func.__name__}{args} returned: {original_result}\u0026quot;)\rreturn original_result\rreturn wrapper\r@trace\rdef say_hi(greeting, name=None):\rreturn greeting + '! ' + name + '.'\rprint(say_hi('Hello', name = 'Jack'))\r Trace: You've called a function: say_hi(), with args: ('Hello',); kwargs: {'name': 'Jack'}\rTrace: say_hi('Hello',) returned: Hello! Jack.\rHello! Jack.\r ","id":6,"section":"posts","summary":"函数也是对象 首先要明确一个概念，函数也是对象。 于是，函数本身其实可以与其他的数据类型一样，作为其他函数的参数或者返回值。 def decorator(func): def wrapper(): print(\u0026quot;we can do sth.Befor the func()","tags":null,"title":"Python的函数工具(1)","uri":"https://zhihao2020.github.io/2020/04/python%E7%9A%84%E5%87%BD%E6%95%B0%E5%B7%A5%E5%85%B71/","year":"2020"},{"content":"面向对象的三大基本特性，五大基本原则 透切理解面向对象三大基本特性是理解面向对象五大基本原则的基础.\n三大特性是：封装,继承,多态 封装 封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n继承 面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”。 被继承的类称为“基类”、“父类”或“超类”。 继承的过程，就是从一般到特殊的过程。 要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。 在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。\n继承概念的实现方式有三类：实现继承、接口继承和可视继承。\n  实现继承是指使用基类的属性和方法而无需额外编码的能力.\n  接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；\n  可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力\n  多态 一种事物的多种体现形式，函数的重写其实就是多态的一种体现\n在Python中，多态指的是父类的引用指向子类的对象\n那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。\n五大基本原则 单一职责原则SRP(Single Responsibility Principle) 是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。\n开放封闭原则OCP(Open－Close Principle) 一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能， 那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。\n替换原则(the Liskov Substitution Principle LSP) 子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工， 也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。\n依赖原则(the Dependency Inversion Principle DIP) 具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能， 这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到 了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。\n接口分离原则(the Interface Segregation Principle ISP) 模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来\n","id":7,"section":"posts","summary":"面向对象的三大基本特性，五大基本原则 透切理解面向对象三大基本特性是理解面向对象五大基本原则的基础. 三大特性是：封装,继承,多态 封装 封装最好理","tags":null,"title":"面向对象的三大特性和五大原则","uri":"https://zhihao2020.github.io/2020/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%92%8C%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99/","year":"2020"},{"content":"JupyterLab 有两种键盘输入模式，分别为编辑模式和命令模式。\n一、命令行模式 (按键 Esc 开启) 命令行模式：键盘输入运行程序命令；这时的单元框线是灰色。\n   快捷键 实现的功能 快捷键 实现的功能     Enter 转入编辑模式 V 粘贴到下方单元   Shift + Enter 运行本单元，选中下个单元 Z 恢复删除的最后一个单元   Ctrl + Enter 运行本单元 连按两下D 删除选中的单元   Alt + Enter 运行本单元，在其下插入新单元 Shift + M 合并选中的单元   Y 单元转入代码状态 Ctrl + S 文件存盘   M 单元转入markdown状态 S 文件存盘   R 单元转入raw状态 L 转换行号   1 设定 1 级标题 O 转换输出   2 设定 2 级标题 Shift + O 转换输出滚动   3 设定 3 级标题 Esc 关闭页面   4 设定 4 级标题 Q 关闭页面   5 设定 5 级标题 H 显示快捷键帮助   6 设定 6 级标题 I,I 中断Notebook内核   Up 选中上方单元 连按两下数字0 重启Notebook内核   Down 选中下方单元 Shift 忽略   K 选中上方单元 Shift + Space 向上滚动   J 选中下方单元 Space 向下滚动   Shift + K 扩大选中上方单元 Shift + J 扩大选中下方单元   A 在上方插入新单元 B 在下方插入新单元   X 剪切选中的单元 C 复制选中的单元   Shift + V 粘贴到上方单元      二、编辑模式 ( Enter 键启动) 编辑模式：允许你往单元中键入代码或文本；这时的单元框线是绿色的。\n   快捷键 实现的功能 快捷键 实现的功能     Tab 代码补全或缩进 Shift + Tab 提示   Ctrl + ] 缩进 Ctrl + [ 解除缩进   Ctrl + A 全选 Ctrl + Z 复原   Ctrl + Shift + Z 再做 Ctrl + Y 再做   Ctrl + Home 跳到单元开头 Ctrl + End 跳到单元末尾   Ctrl + Up 跳到单元开头 Ctrl + Down 跳到单元末尾   Ctrl + Left 跳到左边一个字首 Ctrl + Right 跳到右边一个字首   Ctrl + Backspace 删除前面一个字 Esc 进入命令模式   Ctrl + Delete 删除后面一个字 Shift + Enter 运行本单元，选中下一单元   Ctrl + M 进入命令模式 Ctrl + Enter 运行本单元   Alt + Enter 运行本单元，在下面插入一单元 Ctrl + Shift + + 分割单元   Ctrl + S 文件存盘 Ctrl + Shift + Subtract 分割单元   Up 光标上移或转入上一单元 Down 光标下移或转入下一单元   Shift 忽略      ","id":8,"section":"posts","summary":"JupyterLab 有两种键盘输入模式，分别为编辑模式和命令模式。 一、命令行模式 (按键 Esc 开启) 命令行模式：键盘输入运行程序命令；这时的单元框线是灰色。 快捷键 实","tags":["JupyterLab"],"title":"JupyterLab快捷键","uri":"https://zhihao2020.github.io/2020/04/jupyterlab%E5%BF%AB%E6%8D%B7%E9%94%AE/","year":"2020"},{"content":"测试驱动是先写测试代码，然后写功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码\nunittest最早由JUnit启发而来。它支持自动化测试，分享结构，关闭测试代码，将测试聚合到集合中，并使测试独立于报告框架。\n为了实现这些功能，unittest以面向对象的方式提供了一些重要的概念：\n test fixture(测试固件)  测试装置表示执行一个或多个测试所需的准备工作，以及任何相关的清理操作。例如，这可能涉及创建临时或代理数据库、目录或启动服务器进程。\n test case（测试案例）  测试用例是测试的单个单元。它检查对特定输入集的特定响应。unittest提供了一个基类TestCase，它可以用来创建新的测试用例。\n test suite（测试套件）  测试套件是测试用例、测试套件或两者的集合。它用于聚合(aggregate)应该一起执行的测试。\n test runner（测试运行器）  测试运行器是一个组件，它编排测试的执行并向用户提供结果。运行程序可以使用图形界面、文本界面或返回一个特殊值来指示执行测试的结果。\n基本实例 unittest模块提供了构造和运行测试丰富组件。\nimport unittest\rclass TestStringMethods(unittest.TestCase):\rdef test_upper(self):\rself.assertEqual('foo'.upper(), 'FOO')\rdef test_isupper(self):\rself.assertTrue('FOO'.isupper())\rself.assertFalse('Foo'.isupper())\rdef test_split(self):\rs = 'hello world'\rself.assertEqual(s.split(), ['hello', 'world'])\r# check that s.split fails when the separator is not a string\rwith self.assertRaises(TypeError):\rs.split(2)\rif __name__ == '__main__':\runittest.main()\r testcase是通过子类化unittest.TestCase来创建的。这三个单独的测试是用名称以字母test开头的方法定义的。这个命名约定通知测试运行程序哪些方法表示测试。\n每个测试的关键是调用assertEqual()来检查期望的结果；assertTrue()或assertFalse()来验证条件；或assertRaises来验证是否引发了特定的异常。这些方法替代了assert语句，因此这些测试接货可以最终生成报告。\nsetUp()和tearDown()方法允许你定义能在测试方法之前和之后执行的指令。\n最后的代码是运行这个测试的简单方法。unittest.main()t提供了测试脚本的命令行接口。当从命令行运行时，上面的脚本生成如下的输出：\n...\r------------------------------------------------------------\rRan 3 tests in 0.000s\rOK\r 将-v传输到你的测试代码将使unittest.main()开始更高级的说明。比如像下面：\ntest_isupper (__main__.TestStringMethods) ... ok\rtest_split (__main__.TestStringMethods) ... ok\rtest_upper (__main__.TestStringMethods) ... ok\r----------------------------------------------------------------------\rRan 3 tests in 0.001s\rOK\r 上面的例子展示了最常用的unittest特性，这些特性足以满足许多日常的测试需求。文档的其余部分将探索来自first principles的完整特性集。\n命令行界面 可以从命令行使用unittest模块\n比如\npython -m unittest test_module1 test_module2\rpython -m unittest test_module.TestClass\rpython -m unittest test_module.TestClass.test_method\r 测试模块也可以通过文件路径指定：\npython -m unittest tests/test_something.py\r 这使您可以使用Shell文件名补全来指定测试模块。指定的文件必须仍然可以作为模块导入。通过删除“ .py”并将路径分隔符转换为“。”，可将该路径转换为模块名称。如果要执行不可作为模块导入的测试文件，则应直接执行该文件。\n您可以通过传递-v标志来更详细（更详细）地运行测试：\npython -m unittest -v test_module\r 在不带参数的情况下执行时，将启动“ 测试发现”：\npython -m unittest\r 有关所有命令行选项的列表：\npython -m unittest -h\r 组织测试代码 单元测试的基本构建模块是测试用例 —必须设置单个场景并检查其正确性。在中unittest，测试用例由unittest.TestCase实例表示。要制作自己的测试用例，必须编写TestCase或的子类 FunctionTestCase。\nTestCase实例的测试代码应完全独立，以使它可以隔离运行，也可以与任意数量的其他测试用例任意组合运行。\n最简单的TestCase子类将简单地实现一个测试方法（即名称以开头的方法test），以执行特定的测试代码：\nimport unittest\rclass DefaultWidgetSizeTestCase(unittest.TestCase):\rdef test_default_widget_size(self):\rwidget = Widget('The widget')\rself.assertEqual(widget.size(), (50, 50))\r 请注意，为了测试某些内容，我们使用assert*() ,他TestCase基类提供的方法之一。如果测试失败，则会引发异常，并带有一条解释性消息，并将unittest 测试用例标识为失败。其他任何异常都将被视为错误。\n测试可能很多，并且它们的设置可能是重复的。幸运的是，我们可以通过实现称为的方法来分解设置代码，setUp()测试框架将针对我们运行的每个测试自动调用该方法 ：\nimport unittest\rclass WidgetTestCase(unittest.TestCase):\rdef setUp(self):\rself.widget = Widget('The widget')\rdef test_default_widget_size(self):\rself.assertEqual(self.widget.size(), (50,50),\r'incorrect default size')\rdef test_widget_resize(self):\rself.widget.resize(100,150)\rself.assertEqual(self.widget.size(), (100,150),\r'wrong size after resize')\r 注意:通过根据字符串的内置顺序对测试方法名称进行排序，可以确定各种测试的运行顺序。\n如果在setUp()测试运行时该方法引发异常，则框架将认为该测试已发生错误，并且该测试方法将不会执行。\n同样，我们可以提供一种tearDown()在测试方法运行后进行整理的方法：\nimport unittest\rclass WidgetTestCase(unittest.TestCase):\rdef setUp(self):\rself.widget = Widget('The widget')\rdef tearDown(self):\rself.widget.dispose()\r 如果setUp()成功，tearDown()将运行测试方法是否成功。\n这种用于测试代码的工作环境称为 测试夹具。创建一个新的TestCase实例作为用于执行每种单独的测试方法的唯一测试夹具。因此 setUp()，tearDown()和__init__() 将在每个测试中被调用一次。\n建议使用TestCase实现将测试根据其测试的功能分组在一起。 unittest为此提供了一种机制：test suite（测试套件)，由unittest的 TestSuite类表示。在大多数情况下，调用unittest.main()将做正确的事情，并为您收集所有模块的测试用例并执行它们。\n但是，如果您想自定义测试套件的构建，则可以自己进行：\ndef suite():\rsuite = unittest.TestSuite()\rsuite.addTest(WidgetTestCase('test_default_widget_size'))\rsuite.addTest(WidgetTestCase('test_widget_resize'))\rreturn suite\rif __name__ == '__main__':\rrunner = unittest.TextTestRunner()\rrunner.run(suite())\r 您可以将测试用例和测试套件的定义与它们要测试的代码放在相同的模块中（例如widget.py），但是将测试代码放在单独的模块中有许多优点，例如 test_widget.py：\n 可以从命令行独立运行测试模块。 测试代码可以更容易地与出厂代码分开。 在没有充分理由的情况下，很少有更改测试代码以使其适合测试代码的诱惑。 测试代码的修改频率应低于其测试的代码。 经过测试的代码可以更容易地重构。 如果测试策略发生变化，则无需更改源代码。  ","id":9,"section":"posts","summary":"测试驱动是先写测试代码，然后写功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码 unittest最早由JUnit启发","tags":["Python标准库"],"title":"Python的Unittest模块","uri":"https://zhihao2020.github.io/2020/04/python%E7%9A%84unittest%E6%A8%A1%E5%9D%97/","year":"2020"},{"content":"argparse可以让人编写对用户友好的命令行接口。程序定义好它需要的参数，然后argparse将从sys.argv解析出那些参数。\nargparse还会自动生成帮助和使用手册，并在用户给程序传入无效参数时报出错误信息。\n概念 创建一个解析器 parser = argparse.ArgumentParser(description='Process some integers.')\r 添加参数 添加参数是通过调用add_argument()方法完成的\npaser.add_argument('integers', metavar='N', type=int, nargs='+',help='an integer for the accumulator')\rparser.add_argument('--sum',dest='accumulate',action='store_const',const=sum,default=max,help='max,help='sum the integers (default: find the max)')\r 稍后，调用 parse_args() 将返回一个具有 integers 和 accumulate 两个属性的对象。integers 属性将是一个包含一个或多个整数的列表，而 accumulate 属性当命令行中指定了 --sum 参数时将是 sum() 函数，否则则是 max() 函数。\n解析参数 ArgumentParser 通过 parse_args() 方法解析参数。它将检查命令行，把每个参数转换为适当的类型然后调用相应的操作。在大多数情况下，这意味着一个简单的 Namespace 对象将从命令行参数中解析出的属性构建：\nparser.parse_args(['--sum', '7', '-1', '42'])\r 在脚本中，通常parse_args()会不带参数调用，而ArgumentParser将自动从sysy.argv中确定命令行参数。\n基本方法 基础 import argparse\rparser = argparse.AgumentParser()\rparser.parse_args()\r 位置参数 位置参数之所以这样命名，是因为程序应该如何处理该参数，完全取决于1它在命令行中的参数。\nimport argparse\rparser = argprase.ArgumentParser()\rparser.add_argument(\u0026quot;square\u0026quot;,help=\u0026quot;display a square of a given number\u0026quot;,type=int)\rargs = parser.parser_args()\rprint(args.square**2)\r  首先我们引入parser对象 我们增加了add_argument()方法，该方法用于指定程序能够接受哪些命令行选项。 The parse_args() method actually returns some data from the options specified, in this case, square.  注意，这里有type=int，这个是告诉argparse来吧输入当做整数，不然他就会把它当做字符串。\n可选参数 import argparse\rparser = argparse.ArgumentParser()\rparser.add_argument(\u0026quot;--verbose\u0026quot;, help=\u0026quot;increase output verbosity\u0026quot;,\raction=\u0026quot;store_true\u0026quot;)\rargs = parser.parse_args()\rif args.verbose:\rprint(\u0026quot;verbosity turned on\u0026quot;)\r 这里action赋值为\u0026quot;store_true\u0026quot;。这意味着，当一个选项存在时，为args.verbose赋值为True。没有指定时，啧隐含地赋值为False。\n短选项 parser.add_argument(\u0026quot;-v\u0026quot;, \u0026quot;--verbose\u0026quot;, help=\u0026quot;increase output verbosity\u0026quot;,\raction=\u0026quot;store_true\u0026quot;)\r ","id":10,"section":"posts","summary":"argparse可以让人编写对用户友好的命令行接口。程序定义好它需要的参数，然后argparse将从sys.argv解析出那些参数。 argp","tags":["Python标准库"],"title":"Python 参数解析 Parser 的使用方法","uri":"https://zhihao2020.github.io/2020/04/python-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90-parser-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","year":"2020"},{"content":"sys.argv 传递给Python脚本的命令行参数列表。\n例如\nimport sys\rprint(sys.argv[0])\rprint(sys.argv[1])\r 运行它：\npython temp.py argv1\rsys.py\rargv1\r sys.exit([arg]) 功能：执行到主程序末尾，解释器自动退出，但是如果需要中途退出程序，可以调用sys.exit函数，带有一个可选的整数参数返回给调用它的程序，表示你可以在主程序中捕获对sys.exit的调用。（0是正常退出，其他为异常）\nsys.getdefaultencoding() 获取系统当前编码，一般默认为ascii。\nsys.path 功能：获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。\n当然你可以通过这样修改\nsys.path.append(\u0026quot;自定义模块路径\u0026quot;)\r sys.platform 获取当前系统平台。\nsys.stdin,sys.stdout,sys.stderr 功能：stdin , stdout , 以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们\n——未完之后，会不断补充——\n","id":11,"section":"posts","summary":"sys.argv 传递给Python脚本的命令行参数列表。 例如 import sys print(sys.argv[0]) print(sys.argv[1]) 运行它： python temp.py argv1 sys.py argv1 sys.exit([arg]) 功能：执行到主程序末尾，解释器自动退出，但是如果需要中途退出程序，","tags":["Python标准库"],"title":"Python中的sys","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84sys/","year":"2020"},{"content":"这个项目会创建一个N×N的细胞网格，随时间推移，模拟Conway生命游戏。\n在这个游戏中，细胞处于ON或OFF状态。游戏从一个初始状态开始，每个细胞分配一个状态，刷滕州而决定如何随时间而改变。\n这个游戏规则很简单，但是它表明，复杂的结构可以根据简单的规则演进，不必遵循任何一个预设的模式。\n工作原理 Conway生命游戏有4个规则：\n 1、如果一个细胞为ON，邻居中少于两个为ON，他变为OFF。 2、如果一个细胞为ON，邻居中有两个或3个为ON，他保持为ON。 3、如果一个细胞为ON，邻居超过三个为ON，他变为OFF。 4、如果一个细胞为OFF，邻居中恰好有三个为ON，他变为ON.  对于边界采用环形边界条件\n表示网格 表示网格上的细胞死活，采用255和0作为ON和OFF的数值。我们将采用matplotlib的imshow()方法，来显示网格当前的状态，将一个数字矩阵表示为一张图像。\n例如：\nx = np.array([[0,0,255],[255,255,0],[0,255,0]])\rplt.imshow(x,interpolation='nearest')\rplt.show\r 初始条件 开始模拟，先为二维网格的每个细胞初始状态。可以使用随机分布，或者特定的图案。\n这里我使用了随机分布。\n例如：\nnp.random.choice([0,255],4*4,p=[0.1,0.9]).reshape(4,4)\r 下面为输出：\narray([[255, 255, 255, 255],\r[255, 255, 0, 255],\r[0, 255, 255, 255],\r[255, 255, 255, 0]])\r 边界条件 这里除了边缘其他位置都好处理，因为边缘采用了环形边界。\n这里我使用了取模。\nright = gird[i][(j+1)%N]\rleft = grid[i][(j-1)%N]\rtop = grid[(i-1)%N][j]\rdown = grid[(i+1)%N][j]\r 实现规则 生命游戏的规则基于相邻细胞的ON或OFF数目。为了简化这些规则的应用，可以计算出处于ON状态的相邻细胞总数。因为ON状态的值为255，所以可以对所有相邻细胞的值求和，再除以255，来获得ON细胞的数量。下面是相关的代码：\nif grid[i,j] == ON:\rif (total \u0026lt; 2) or (total \u0026gt;3 ):\rnewGrid[i,j] = OFF\relse:\rif total == 3:\rnewGrid[i,j] = ON\r 初始化模拟 # set grid size\rN = 100\rif args.N and int(args.N) \u0026gt; 8:\rN = int(args.N)\r# set animation update interval\rupdateInterval = 50\rif args.interval:\rupdateInterval = int(args.interval)\r# populate grid with random on/off - more off than on\rgrid = randomGrid(N)\r 设置动画，\nfig,ax = plt.subplots()\rimg = ax.imshow(grid,interpolation = 'nearest')\rani = animation.FuncAnimation(fig,update,fargs=\t(img.grid,N,),frames=10,interval=updateInterval,save_count=50)\rif args.movfile:\rani.save(args.movfile, fps=30, extra_args=['-vcodec', 'libx264'])\rplt.show()\r 最后的结果：\n完整代码：\nimport sys, argparse\rimport numpy as np\rimport matplotlib.pyplot as plt\rimport matplotlib.animation as animation\rON = 255\rOFF = 0\rvals = [ON, OFF]\rdef randomGrid(N):\r\u0026quot;\u0026quot;\u0026quot;returns a grid of NxN random values\u0026quot;\u0026quot;\u0026quot;\rreturn np.random.choice(vals, N * N, p=[0.2, 0.8]).reshape(N, N)\rdef update(frameNum, img, grid, N):\r# copy grid since we require 8 neighbors for calculation\r# and we go line by line\rnewGrid = grid.copy()\rfor i in range(N):\rfor j in range(N):\r# compute 8-neghbor sum\r# using toroidal boundary conditions - x and y wrap around\r# so that the simulaton takes place on a toroidal surface.\rtotal = int((grid[i, (j - 1) % N] + grid[i, (j + 1) % N] +\rgrid[(i - 1) % N, j] + grid[(i + 1) % N, j] +\rgrid[(i - 1) % N, (j - 1) % N] + grid[(i - 1) % N, (j + 1) % N] +\rgrid[(i + 1) % N, (j - 1) % N] + grid[(i + 1) % N, (j + 1) % N]) / 255)\r# apply Conway's rules\rif grid[i, j] == ON:\rif (total \u0026lt; 2) or (total \u0026gt; 3):\rnewGrid[i, j] = OFF\relse:\rif total == 3:\rnewGrid[i, j] = ON\r# update data\rimg.set_data(newGrid)\rgrid[:] = newGrid[:]\rreturn img,\r# main() function\rdef main():\r# Command line args are in sys.argv[1], sys.argv[2] ..\r# sys.argv[0] is the script name itself and can be ignored\r# parse arguments\rparser = argparse.ArgumentParser(description=\u0026quot;Runs Conway's Game of Life simulation.\u0026quot;)\r# add arguments\rparser.add_argument('--grid-size', dest='N', required=False)\rparser.add_argument('--mov-file', dest='movfile', required=False)\rparser.add_argument('--interval', dest='interval', required=False)\rargs = parser.parse_args()\r# set grid size\rN = 100\rif args.N and int(args.N) \u0026gt; 8:\rN = int(args.N)\r# set animation update interval\rupdateInterval = 50\rif args.interval:\rupdateInterval = int(args.interval)\r# declare grid\rgrid = np.array([])\r# populate grid with random on/off - more off than on\rgrid = randomGrid(N)\r# set up animation\rfig, ax = plt.subplots()\rimg = ax.imshow(grid, interpolation='nearest')\rani = animation.FuncAnimation(fig, update, fargs=(img, grid, N,),\rframes=10,\rinterval=updateInterval,\rsave_count=50)\rif args.movfile:\rani.save(args.movfile, fps=30, extra_args=['-vcodec', 'libx264'])\rplt.show()\r# call main\rif __name__ == '__main__':\rmain()\r ","id":12,"section":"posts","summary":"这个项目会创建一个N×N的细胞网格，随时间推移，模拟Conway生命游戏。 在这个游戏中，细胞处于ON或OFF状态。游戏从一个初始状态开始，每","tags":null,"title":"用Python模拟生命","uri":"https://zhihao2020.github.io/2020/04/python%E6%A8%A1%E6%8B%9F%E7%94%9F%E5%91%BD/","year":"2020"},{"content":"#!/usr/bin/env python3\r\u0026quot;\u0026quot;\u0026quot;\rA Python version of the classic \u0026quot;bottles of beer on the wall\u0026quot; programming\rexample.\rBy Guido van Rossum, demystified after a version by Fredrik Lundh.\r\u0026quot;\u0026quot;\u0026quot;\rimport sys\rn = 100\rif sys.argv[1:]:\rn = int(sys.argv[1])\rdef bottle(n):\rif n == 0: return \u0026quot;no more bottles of beer\u0026quot;\rif n == 1: return \u0026quot;one bottle of beer\u0026quot;\rreturn str(n) + \u0026quot; bottles of beer\u0026quot;\rfor i in range(n, 0, -1):\rprint(bottle(i), \u0026quot;on the wall,\u0026quot;)\rprint(bottle(i) + \u0026quot;.\u0026quot;)\rprint(\u0026quot;Take one down, pass it around,\u0026quot;)\rprint(bottle(i-1), \u0026quot;on the wall.\u0026quot;)\r 这里值得学习：\nn = 100\rif sys.argv[1:]:\rn = int(sys.argv[1])\r 这样保证了n有默认值，用户也可以自己修改。\n今天这个真水，就算一个平缓的起步吧~\n","id":13,"section":"posts","summary":"#!/usr/bin/env python3 \u0026quot;\u0026quot;\u0026quot; A Python version of the classic \u0026quot;bottles of beer on the wall\u0026quot; programming example. By Guido van Rossum, demystified after a version by Fredrik Lundh. \u0026quot;\u0026quot;\u0026quot; import sys n = 100 if sys.argv[1:]: n = int(sys.argv[1]) def bottle(n): if n == 0: return \u0026quot;no more bottles of beer\u0026quot; if n == 1: return \u0026quot;one bottle of beer\u0026quot; return str(n) + \u0026quot; bottles of beer\u0026quot; for i in","tags":["Python代码学习"],"title":"精读代码(1)","uri":"https://zhihao2020.github.io/2020/04/%E7%B2%BE%E8%AF%BB%E4%BB%A3%E7%A0%811/","year":"2020"},{"content":"配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit）更改。配置Git来忽略制定文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。\n获取Git仓库 有两种获取Git项目仓库的方式。第一种是将已有项目或目录导入为Git仓库；第二种是从其他服务器克隆一个已存在的Git仓库。\n在已存在目录中初始化仓库 如果你打算使用Git来对已有项目进行跟踪，你需要进入项目目录并输入：\ngit init\r 该命令将创建一个名为**.git**的子目录，这个子目录含有你初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。\n如果在一个已存在的文件夹（而非空文件夹）中进行版本控制。你应该开始追踪这些文件并进行初始提交。可以通过git add 命令来指定所需的文件来进行追踪，然后执行git commit：\ngit add .\rgit add LICENSE\rgit commit -m 'initial project version'\r 现在你已经得到了一个存在于被追踪文件与初始提交的Git仓库。\n克隆现有的仓库 如果你想获得一份已经存在了的Git仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这是就要用到git clone命令。Git克隆的是该Git仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。\n当你执行git clone命令时，默认的配置下远程Git胀库的每一个文件的没一个版本都将被拉下来。\ngit clone [url]\r 这会在当前目录下创建一个XX的目录，并在这个目录下初始化一个**.git**文件，从远程仓库拉取下所有数据放入**.git**文件夹，然后从中读取最新版本文件的拷贝。如果你想在克隆远程仓库的时候，自定义本地仓的名字 你可以用这个命令：\ngit clone [url] myStore\r Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用SSH 传输协议，比如 user@server:path/to/repo.git 。\n记录每次更新到仓库 现在我们手上有了一个真实的Git仓库，并从这个仓库中取出所有文件的拷贝。接下来，对这些文件做些修改，在完成一个阶段的目标之后，提交本次更新到仓库。\n记住：你工作目录下的每一个文件都不外乎两种状态：已跟踪或未跟踪。\n已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在国祚一定时间后，它们的状态可能是未修改，已修改或已放入暂存区。\n工作目录中除已跟踪文件以外的所有其他文件都属于未跟踪文件，它们即不存在于上次快照的记录中，也没有被放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。\n检查当前文件状态 可以用git status命令查看哪些文件处于什么状态。如果在克隆仓库后立即使用此命令，会看到类似这样输出：\ngit status\rOn branch master\rnothing to commit,working dirdctory clean\r 这说明你现在的工作目录相当干净，换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有任何处于未跟踪状态的新文件，否则Git会在这里列出来。最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。现在，分支名是“master”，这是默认的分支名。\nGit不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件“。这样的处理让你不必担心将生成的二进制文件或其他不想被跟踪的文件夹包含进来。\n跟踪新文件 使用git add开始跟踪一个文件。所以，比如跟踪README文件，运行：\ngit add README\r 此时再运行git status命令，会看到README文件已被跟踪，并处于暂存状态：\n$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\r 只要在Changes to be committed 这行下面，就说明已暂存状态。如果此时提交，那么该文件在你运行git add时的版本将留在历史记录中。你可能会想起之前我们使用git init后运行了**git add(files)**命令，开始跟踪当前目录下的文件。git add 命令使用文件或牡蛎的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。\n暂存已修改文件 现在我们来修改一个已被跟踪的文件。如果你修改了一个名为CONTRIBUTING。md的已被跟踪的文件，然后运行git status命令，会看到下面内容\n$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 文件CONTRIBURING。md出现在Changes not staged for commit这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行git add命令。\ngit add这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。\n将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行git add 将\u0026quot;CONTRIBUTING.md\u0026quot;放到暂存区，然后再看看 git status 的输出：\n$ git add CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\rmodified: CONTRIBUTING.md\r 现在两个文件都已暂存，下次提交就会一并记录到仓库。假设此时，你想要的在CONTRIBUTING.md里再加条注释。重新编辑存盘后，准备好提交。不过且慢，再运行git status看看：\n$ vim CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\rmodified: CONTRIBUTING.md\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 怎么回事？现在CONTRIBUTING.md文件同时出现在暂存区和非暂存区。实际上，Git只不过暂存了你运行git add命令时的版本。如果你现在提交，CONTRIBUTING.md版本是你最后一次运行git add命令时的那个版本，而不是你运行git commit是，在工作目录中的当前版本。所以，运行了git add之后又做了修订的文件，需要重新运行git add把最新版本重新暂存起来：\n$ git add CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\rmodified: CONTRIBUTING.md\r 状态简览 git status命令输出十分详细，但其用语有些繁琐。Git有一个选项可以帮助你缩短状态命令的输出，这样可以以简洁的方式查看更改。如果你使用git status -s命令或git status —short命令，你将得到一种格式更为紧凑的输出。\n$ git status -s\rM README\rMM Rakefile\rA lib/git.rb\rM lib/simplegit.rb\r?? LICENSE.txt\r 新添加的未跟踪文件前面有**？？**标记，\n新添加都暂存区中的文件前面有A标记，\n修改过的文件前面有M标记。\n注意：M有两个可以出现的位置，出现在右边的M表示该文件被修改了但是还没被放入暂存区。出现在靠左边的M表示该文件被修改了并被放入了暂存区。\n 例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,lib/simplegit.rb 文件被修改了并已将修改后的文件放入了暂存区。 而 Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。\r 忽略文件 一般我们总会有些文件无需纳入Git的管理，也不希望它们总出现在未被跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件。在这种情况下，我们可以创建一个名为**.gitignore**的文件，列出要忽略的文件模式。来看一个实际的**.gitignore**例子\n$ cat .gitignore\r*.[oa]\r*~\r 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。\n第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。\n此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好**.gitignore** 文件的习惯，以免将来误提交这类无用的文件。\n文件.gitignore的格式规范如下：\n 所有空行或者以#开头的行都会被Git忽略。 可以使用标准的glob模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（！）取反。  所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z , a/b/z 或 a/b/c/z 等。 我们再看一个 .gitignore 文件的例子：\n# no .a files\r*.a\r# but do track lib.a, even though you're ignoring .a files above\r!lib.a\r# only ignore the TODO file in the current directory, not subdir/TODO\r/TODO\r# ignore all files in the build/ directory\rbuild/\r# ignore doc/notes.txt, but not doc/server/arch.txt\rdoc/*.txt\r# ignore all .pdf files in the doc/ directory\rdoc/**/*.pdf\r GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在https://github.com/github/gitignore 找到它。\n查看已暂存和未暂存的修改 如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。稍后我们会详细介绍 git diff，你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？ 有哪些更新已经暂存起来准备好下次提交？ 虽然 git status 已经通过在相应栏下列出文件名的方式回答了这个问 题，但 git diff 将通过文件补丁的格式更加具体地显示哪些行发生了改变。 假如再次修改 README 文件后暂存，然后编辑 CONTRIBUTING.md 文件后先不暂存， 运行 status 命令将会看到：\n$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rmodified: README\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 要看尚未暂存的文件更新了哪些部分，不加参数直接输入git diff：\n$ git diff\rdiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\rindex 8ebb991..643e24f 100644\r--- a/CONTRIBUTING.md\r+++ b/CONTRIBUTING.md\r@@ -65,7 +65,8 @@ branch directly, things can get messy.\rPlease include a nice description of your changes when you submit your\rPR;\rif we have to read the whole diff to figure out why you're contributing\rin the first place, you're less likely to get feedback and have your\rchange\r-merged in.\r+merged in. Also, split your changes into comprehensive chunks if your\rpatch is\r+longer than a dozen lines.\rIf you are starting to work on a particular area, feel free to submit a\rPR\rthat highlights your work in progress (and note in the PR title that it's\r 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。 若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff \u0026ndash;staged 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异:\n$ git diff --staged\rdiff --git a/README b/README\rnew file mode 100644\rindex 0000000..03902a1\r--- /dev/null\r+++ b/README\r@@ -0,0 +1 @@\r+My Project\r 请注意，git diff本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。 像之前说的，暂存 CONTRIBUTING.md 后再编辑，可以使用 git status 查看已被暂存的修改或未被暂存的修改。 如果我们的环境（终端输出）看起来如下：\n$ git add CONTRIBUTING.md\r$ echo '# test line' \u0026gt;\u0026gt; CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rmodified: CONTRIBUTING.md\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 现在运行git diff看暂存前后变化：\n$ git diff\rdiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\rindex 643e24f..87f08c8 100644\r--- a/CONTRIBUTING.md\r+++ b/CONTRIBUTING.md\r@@ -119,3 +119,4 @@ at the\r## Starter Projects\rSee our [projects\rlist](\u0026lt;https://github.com/libgit2/libgit2/blob/development/PROJECTS.md\u0026gt;).\r+# test line\r 然后用git diff —cached查看已经暂存起来的变化：（\u0026ndash;staged 和 \u0026ndash;cached 是同义词）\n提交更新 现在暂存区域已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有git add 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过但没有暂存的文件只保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 git commit：\ngit commit\r 这种方式会启动文本编辑器以便输入本次提交的说明。 （默认会启用 shell 的环境变量 $EDITOR 所指定的软件，一般都是 vim 或 emacs。当然也可以按照 起步 介绍的方式，使用 git config \u0026ndash;globalcore.editor 命令设定你喜欢的编辑软件。） 编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：\n# Please enter the commit message for your changes. Lines starting\r# with '#' will be ignored, and an empty message aborts the commit.\r# On branch master\r# Changes to be committed:\r# new file: README\r# modified: CONTRIBUTING.md\r#\r~\r~\r~\r\u0026quot;.git/COMMIT_EDITMSG\u0026quot; 9L, 283C\r 可以看到，默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。 （如果想要更详细的对修改了哪些内容的提示，可以用 -v 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。） 退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。 另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示：\n$ git commit -m \u0026quot;Story 182: Fix benchmarks for speed\u0026quot;\r[master 463dc4f] Story 182: Fix benchmarks for speed\r2 files changed, 2 insertions(+)\rcreate mode 100644 README\r 好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本 次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改 过。 请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。\n跳过使用暂存区 尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存 起来一并提交，从而跳过 git add 步骤：\n$ git status\rOn branch master\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\rno changes added to commit (use \u0026quot;git add\u0026quot; and/or \u0026quot;git commit -a\u0026quot;)\r$ git commit -a -m 'added new benchmarks'\r[master 83e38c7] added new benchmarks\r1 file changed, 5 insertions(+), 0 deletions(-)\r 看到了吗？提交之前不再需要 git add 文件“CONTRIBUTING.md”了。 这是因为 -a 选项使本次提交包含了所有修改过的文件。 这很方便，但是要小心；有时这个选项会将不需要的文件添加到提交中。\n移除文件 **要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。**可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。\n如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到：\n$ rm PROJECTS.md\r$ git status\rOn branch master\rYour branch is up-to-date with 'origin/master'.\rChanges not staged for commit:\r(use \u0026quot;git add/rm \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rdeleted: PROJECTS.md\rno changes added to commit (use \u0026quot;git add\u0026quot; and/or \u0026quot;git commit -a\u0026quot;)\r 然后再运行git rm 记录此次移除文件的操作：\n$ git rm PROJECTS.md\rrm 'PROJECTS.md'\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rdeleted: PROJECTS.md\r 下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。\n另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 \u0026ndash;cached 选项：\ngit rm --cache README\r git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。 比方说：\ngit rm log/\\\\*.log\r 注意到星号 * 之前的反斜杠 \\， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。此命令删除 log/ 目录下扩展名为 .log 的所有文件。 类似的比如：\ngit rm \\\\*~\r 该命令为删除以 ~ 结尾的所有文件。\n移动文件 Git不会显式跟踪文件移动操作。\n要在Git中对文件改名：\ngit mv file_from file_to\r 实际上，运行git mv就相当于运行下面三条命令：\n$ mv README.md README\r$ git rm README.md\r$ git add README\r 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。\n查看提交历史 在提交了若干个更新，又或者克隆了某个项目之后，你想回顾一下提交历史。完成这个任务最简单而有效的工具是git log命令\n不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 git log 有许多选项可以帮助你搜寻你所要找的提交， 下面我们会介绍几个最常用的选项。 其中一个比较有用的选项是 -p，它会显示每次提交所引入的差异。 与此同时，你也可以使用 -2 选项来仅显示最近的两次提交：\n撤销操作 在任何一个阶段，你都有可能想要撤销某些操作。这里，我们将会学习几个撤销你所做修改的基本工具。注意，有些撤销操作是不可逆的。这是在使用Git的过程中，会因为操作失误而导致之前工作丢失的少有的几个地方之一。\n有时候，我们提交完发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有 —amend 选项的提交命令尝试重新提交。\ngit commit --amend\r 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。 例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\n$ git commit -m 'initial commit'\r$ git add forgotten_file\r$ git commit --amend\r 最终你只会有一个提交——第二次提交将代替第一次提交的结果。\n取消暂存的文件 接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。\n例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如何只取消暂存两个中的一个呢？ git status 命令提示了你：\n$ git add *\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rrenamed: README.md -\u0026gt; README\rmodified: CONTRIBUTING.md\r 在 “Changes to be committed” 文字正下方，提示使用 git reset HEAD \u0026hellip; 来取消暂存。 所以，我们可以这样来取消暂存 CONTRIBUTING.md 文件\n$ git reset HEAD CONTRIBUTING.md\rUnstaged changes after reset:\rM CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rrenamed: README.md -\u0026gt; README\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 这样CONTRIBUTING.md 文件已经是修改未暂存的状态了。\n虽然在调用时加上 \u0026ndash;hard 选项可以令 git reset 成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！），但本例中工作目录内的文件并不会被修改。 不加选项地调用git reset 并不危险 — 它只会修改暂存区域。\n撤销对文件的修改 如果你并不想保留对 CONTRIBUTING.md 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，git status 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样\nChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r$ git checkout -- CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rrenamed: README.md -\u0026gt; README\r 可以看到那些修改已经被撤销了。\n你需要知道 git checkout \u0026ndash; [file] 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失——你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。\n如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 Git 分支 介绍保存进度与分支；这些通常是更好的做法。 记住，在 Git 中任何 已提交的 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 \u0026ndash;amend 选项覆盖的提交也可以恢复（阅读 数据恢复 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。\n远程仓库的使用 为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 在本节中，我们将介绍一部分远程管理的技能。\n查看远程仓库 如果想查看你已经配置好的远程仓库服务器，可以运行git remote命令。他会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该看到origin——这是Git给你克隆的仓库服务意识的默认名字。\n$ git clone \u0026lt;https://github.com/schacon/ticgit\u0026gt;\rCloning into 'ticgit'...\rremote: Reusing existing pack: 1857, done.\rremote: Total 1857 (delta 0), reused 0 (delta 0)\rReceiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.\rResolving deltas: 100% (772/772), done.\rChecking connectivity... done.\r$ cd ticgit\r$ git remote\rorigin\r 你也可以指定选项**-v**，会显示读写远程仓库使用的Git保存的简写与其对应的URL。\n$ git remote -v\rorigin \u0026lt;https://github.com/schacon/ticgit\u0026gt; (fetch)\rorigin \u0026lt;https://github.com/schacon/ticgit\u0026gt; (push)\r 添加远程仓库 我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。 运行 **git remote add ** 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简 写：\n$ git remote\rorigin\r$ git remote add pb \u0026lt;https://github.com/paulboone/ticgit\u0026gt;\r$ git remote -v\rorigin \u0026lt;https://github.com/schacon/ticgit\u0026gt; (fetch)\rorigin \u0026lt;https://github.com/schacon/ticgit\u0026gt; (push)\rpb \u0026lt;https://github.com/paulboone/ticgit\u0026gt; (fetch)\rpb \u0026lt;https://github.com/paulboone/ticgit\u0026gt; (push)\r 现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch pb：\n$ git fetch pb\rremote: Counting objects: 43, done.\rremote: Compressing objects: 100% (36/36), done.\rremote: Total 43 (delta 10), reused 31 (delta 5)\rUnpacking objects: 100% (43/43), done.\rFrom \u0026lt;https://github.com/paulboone/ticgit\u0026gt;\r* [new branch] master -\u0026gt; pb/master\r* [new branch] ticgit -\u0026gt; pb/ticgit\r 现在 Paul 的 master 分支可以在本地通过 pb/master 访问到——你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 Git 分支 中详细介绍什么是分支以及如何使用分支。）\n从远程仓库中抓取与拉取 从远程仓库获得数据，可以执行：\ngit fetch [remote-name]\r 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工 作。 如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 Git 分支 了解更多信息），可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\n推送到远程仓库 当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：git push [remote-name] [branchname]。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：\ngit push origin master\r 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 阅读 Git 分支 了解如何推送到远程仓库服务器的详细信息。\n查看某个远程仓库 如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：\n$ git remote show origin\r* remote origin\rFetch URL: \u0026lt;https://github.com/schacon/ticgit\u0026gt;\rPush URL: \u0026lt;https://github.com/schacon/ticgit\u0026gt;\rHEAD branch: master\rRemote branches:\rmaster tracked\rdev-branch tracked\rLocal branch configured for 'git pull':\rmaster merges with remote master\rLocal ref configured for 'git push':\rmaster pushes to master (up to date)\r 它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。 这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 git remote show 看到更多的信息。\n$ git remote show origin\r* remote origin\rURL: \u0026lt;https://github.com/my-org/complex-project\u0026gt;\rFetch URL: \u0026lt;https://github.com/my-org/complex-project\u0026gt;\rPush URL: \u0026lt;https://github.com/my-org/complex-project\u0026gt;\rHEAD branch: master\rRemote branches:\rmaster tracked\rdev-branch tracked\rmarkdown-strip tracked\rissue-43 new (next fetch will store in\rremotes/origin)\rissue-45 new (next fetch will store in\rremotes/origin)\rrefs/remotes/origin/issue-11 stale (use 'git remote prune' to\rremove)\rLocal branches configured for 'git pull':\rdev-branch merges with remote dev-branch\rmaster merges with remote master\rLocal refs configured for 'git push':\rdev-branch pushes to dev-branch\r(up to date)\rmarkdown-strip pushes to markdown-strip\r(up to date)\rmaster pushes to master\r(up to date)\r 这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 git pull 时哪些分支会自动合并。\n远程仓库的移除与重命名 如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 例如，想要将 pb重命名为 paul，可以用 git remote rename 这样做：\n$ git remote rename pb paul\r$ git remote\rorigin\rpaul\r 值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 pb/master 的现在会引用 paul/master。\n如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用 git remote rm ：\n$ git remote rm paul\r$ git remote\rorigin\r ","id":14,"section":"posts","summary":"配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit）更改。配置Git来忽","tags":["Git"],"title":"Git基本操作(1)","uri":"https://zhihao2020.github.io/2020/04/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","year":"2020"},{"content":"行内与独行  行内公式：将公式插入到本行内，符号：$公式内容$，如：$xyz$ 独行公式：将公式插入到新的一行内，并且居中，符号：$$公式内容$$，如：$$xyz$$  上标、下标与组合  上标符号，符号：^，如：$x^4$ 下标符号，符号：_，如：$x_1$ 组合符号，符号：{}，如：${16}{8}O{2+}{2}$  汉字、字体与格式  汉字形式，符号：\\mbox{}，如：$V_{\\mbox{初始}}$ 字体控制，符号：\\displaystyle，如：$\\displaystyle \\frac{x+y}{y+z}$ 下划线符号，符号：\\underline，如：$\\underline{x+y}$ 标签，符号\\tag{数字}，如：$\\tag{11}$ 上大括号，符号：\\overbrace{算式}，如：$\\overbrace{a+b+c+d}^{2.0}$ 下大括号，符号：\\underbrace{算式}，如：$a+\\underbrace{b+c}_{1.0}+d$ 上位符号，符号：\\stacrel{上位符号}{基位符号}，如：$\\vec{x}\\stackrel{\\mathrm{def}}{=}{x_1,\\dots,x_n}$  占位符  两个quad空格，符号：\\qquad，如：$x \\qquad y$ quad空格，符号：\\quad，如：$x \\quad y$ 大空格，符号\\，如：$x \\ y$ 中空格，符号\\:，如：$x : y$ 小空格，符号\\,，如：$x , y$ 没有空格，符号``，如：$xy$ 紧贴，符号\\!，如：$x ! y$  定界符与组合  括号，符号：（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)，如：$（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)$ 中括号，符号：[]，如：$[x+y]$ 大括号，符号：\\{ \\}，如：${x+y}$ 自适应括号，符号：\\left \\right，如：$\\left(x\\right)$，$\\left(x{yz}\\right)$ 组合公式，符号：{上位公式 \\choose 下位公式}，如：${n+1 \\choose k}={n \\choose k}+{n \\choose k-1}$ 组合公式，符号：{上位公式 \\atop 下位公式}，如：$\\sum_{k_0,k_1,\\ldots\u0026gt;0 \\atop k_0+k_1+\\cdots=n}A_{k_0}A_{k_1}\\cdots$  四则运算  加法运算，符号：+，如：$x+y=z$ 减法运算，符号：-，如：$x-y=z$ 加减运算，符号：\\pm，如：$x \\pm y=z$ 减甲运算，符号：\\mp，如：$x \\mp y=z$ 乘法运算，符号：\\times，如：$x \\times y=z$ 点乘运算，符号：\\cdot，如：$x \\cdot y=z$ 星乘运算，符号：\\ast，如：$x \\ast y=z$ 除法运算，符号：\\div，如：$x \\div y=z$ 斜法运算，符号：/，如：$x/y=z$ 分式表示，符号：\\frac{分子}{分母}，如：$\\frac{x+y}{y+z}$ 分式表示，符号：{分子} \\voer {分母}，如：${x+y} \\over {y+z}$ 绝对值表示，符号：||，如：$|x+y|$  高级运算  平均数运算，符号：\\overline{算式}，如：$\\overline{xyz}$ 开二次方运算，符号：\\sqrt，如：$\\sqrt x$ 开方运算，符号：\\sqrt[开方数]{被开方数}，如：$\\sqrt[3]{x+y}$ 对数运算，符号：\\log，如：$\\log(x)$ 极限运算，符号：\\lim，如：$\\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 极限运算，符号：\\displaystyle \\lim，如：$\\displaystyle \\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 求和运算，符号：\\sum，如：$\\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 求和运算，符号：\\displaystyle \\sum，如：$\\displaystyle \\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 积分运算，符号：\\int，如：$\\int^{\\infty}_{0}{xdx}$ 积分运算，符号：\\displaystyle \\int，如：$\\displaystyle \\int^{\\infty}_{0}{xdx}$ 微分运算，符号：\\partial，如：$\\frac{\\partial x}{\\partial y}$ 矩阵表示，符号：\\begin{matrix} \\end{matrix}，如：$\\left[ \\begin{matrix} 1 \u0026amp;2 \u0026amp;\\cdots \u0026amp;4\\5 \u0026amp;6 \u0026amp;\\cdots \u0026amp;8\\vdots \u0026amp;\\vdots \u0026amp;\\ddots \u0026amp;\\vdots\\13 \u0026amp;14 \u0026amp;\\cdots \u0026amp;16\\end{matrix} \\right]$  逻辑运算  等于运算，符号：=，如：$x+y=z$ 大于运算，符号：\u0026gt;，如：$x+y\u0026gt;z$ 小于运算，符号：\u0026lt;，如：$x+y\u0026lt;z$ 大于等于运算，符号：\\geq，如：$x+y \\geq z$ 小于等于运算，符号：\\leq，如：$x+y \\leq z$ 不等于运算，符号：\\neq，如：$x+y \\neq z$ 不大于等于运算，符号：\\ngeq，如：$x+y \\ngeq z$ 不大于等于运算，符号：\\not\\geq，如：$x+y \\not\\geq z$ 不小于等于运算，符号：\\nleq，如：$x+y \\nleq z$ 不小于等于运算，符号：\\not\\leq，如：$x+y \\not\\leq z$ 约等于运算，符号：\\approx，如：$x+y \\approx z$ 恒定等于运算，符号：\\equiv，如：$x+y \\equiv z$  集合运算  属于运算，符号：\\in，如：$x \\in y$ 不属于运算，符号：\\notin，如：$x \\notin y$ 不属于运算，符号：\\not\\in，如：$x \\not\\in y$ 子集运算，符号：\\subset，如：$x \\subset y$ 子集运算，符号：\\supset，如：$x \\supset y$ 真子集运算，符号：\\subseteq，如：$x \\subseteq y$ 非真子集运算，符号：\\subsetneq，如：$x \\subsetneq y$ 真子集运算，符号：\\supseteq，如：$x \\supseteq y$ 非真子集运算，符号：\\supsetneq，如：$x \\supsetneq y$ 非子集运算，符号：\\not\\subset，如：$x \\not\\subset y$ 非子集运算，符号：\\not\\supset，如：$x \\not\\supset y$ 并集运算，符号：\\cup，如：$x \\cup y$ 交集运算，符号：\\cap，如：$x \\cap y$ 差集运算，符号：\\setminus，如：$x \\setminus y$ 同或运算，符号：\\bigodot，如：$x \\bigodot y$ 同与运算，符号：\\bigotimes，如：$x \\bigotimes y$ 实数集合，符号：\\mathbb{R}，如：\\mathbb{R} 自然数集合，符号：\\mathbb{Z}，如：\\mathbb{Z} 空集，符号：\\emptyset，如：$\\emptyset$  数学符号  无穷，符号：\\infty，如：$\\infty$ 虚数，符号：\\imath，如：$\\imath$ 虚数，符号：\\jmath，如：$\\jmath$ 数学符号，符号\\hat{a}，如：$\\hat{a}$ 数学符号，符号\\check{a}，如：$\\check{a}$ 数学符号，符号\\breve{a}，如：$\\breve{a}$ 数学符号，符号\\tilde{a}，如：$\\tilde{a}$ 数学符号，符号\\bar{a}，如：$\\bar{a}$ 矢量符号，符号\\vec{a}，如：$\\vec{a}$ 数学符号，符号\\acute{a}，如：$\\acute{a}$ 数学符号，符号\\grave{a}，如：$\\grave{a}$ 数学符号，符号\\mathring{a}，如：$\\mathring{a}$ 一阶导数符号，符号\\dot{a}，如：$\\dot{a}$ 二阶导数符号，符号\\ddot{a}，如：$\\ddot{a}$ 上箭头，符号：\\uparrow，如：$\\uparrow$ 上箭头，符号：\\Uparrow，如：$\\Uparrow$ 下箭头，符号：\\downarrow，如：$\\downarrow$ 下箭头，符号：\\Downarrow，如：$\\Downarrow$ 左箭头，符号：\\leftarrow，如：$\\leftarrow$ 左箭头，符号：\\Leftarrow，如：$\\Leftarrow$ 右箭头，符号：\\rightarrow，如：$\\rightarrow$ 右箭头，符号：\\Rightarrow，如：$\\Rightarrow$ 底端对齐的省略号，符号：\\ldots，如：$1,2,\\ldots,n$ 中线对齐的省略号，符号：\\cdots，如：$x_1^2 + x_2^2 + \\cdots + x_n^2$ 竖直对齐的省略号，符号：\\vdots，如：$\\vdots$ 斜对齐的省略号，符号：\\ddots，如：$\\ddots$  希腊字母    字母 实现 字母 实现     A A α \\alhpa   B B β \\beta   Γ \\Gamma γ \\gamma   Δ \\Delta δ \\delta   E E ϵ \\epsilon   Z Z ζ \\zeta   H H η \\eta   Θ \\Theta θ \\theta   I I ι \\iota   K K κ \\kappa   Λ \\Lambda λ \\lambda   M M μ \\mu   N N ν \\nu   Ξ \\Xi ξ \\xi   O O ο \\omicron   Π \\Pi π \\pi   P P ρ \\rho   Σ \\Sigma σ \\sigma   T T τ \\tau   Υ \\Upsilon υ \\upsilon   Φ \\Phi ϕ \\phi   X X χ \\chi   Ψ \\Psi ψ \\psi   Ω \\v ω \\omega    这篇文章是我转自别人的，放到我的库里面，方便以后即使查阅。\n作者：DanielGavin 来源：简书 链接：https://www.jianshu.com/p/e74eb43960a1\n","id":15,"section":"posts","summary":"行内与独行 行内公式：将公式插入到本行内，符号：$公式内容$，如：$xyz$ 独行公式：将公式插入到新的一行内，并且居中，符号：$$公式内容$$","tags":["Markown"],"title":"Mrakdown中插入数学公式","uri":"https://zhihao2020.github.io/2020/04/markdown%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","year":"2020"},{"content":"常量通常定义在代码前面，并且全都大写，分割的时候用_（下划线）分割。比如想，MAX_OVERFLOW和TOTAL这样。\n Constants are usually defined on a module level and written in all capital letters with underscores separating words. Examples include MAX_OVERFLOW and TOTAL.\n 始终决定是否一个类的方法和实例变量（通常也叫“属性”）应该是公开还是不公开。如果不确定的话，选择非公共，之后让他公开会 比 让公共的属性非公开，要简单。\n Always decide whether a class\u0026rsquo;s methods and instance variables (collectively: \u0026ldquo;attributes\u0026rdquo;) should be public or non-public. If in doubt, choose non-public; it\u0026rsquo;s easier to make it public later than to make a public attribute non-public.\n 公共属性是那些 与你认为与你使用的类不相关的客户端，并且你承诺避免向后不兼容的更改。不公共的属性 是那些打算被第三方使用的属性；你不保证非公共属性不能更改或者被移除。\n Public attributes are those that you expect unrelated clients of your class to use, with your commitment to avoid backwards incompatible changes. Non-public attributes are those that are not intended to be used by third parties; you make no guarantees that non-public attributes won\u0026rsquo;t change or even be removed.\n 我们在这里不使用“私密”这个术语。因为在Python中没有属性是真正的私密（通常没有必要的工作量）。\n We don\u0026rsquo;t use the term \u0026ldquo;private\u0026rdquo; here, since no attribute is really private in Python (without a generally unnecessary amount of work).\n 另一类属性的种类是“子类API”的一部分。（在其它的语言中，经常被叫做“被保护”）。一些类被设计为从类继承，以扩展或者修改类行为的某些方面。在设计这样一个类时，要注意明确地决定哪些属性是公共的，哪些属性是子类API的一部分，哪些属性实际上只由基类使用。\n Another category of attributes are those that are part of the \u0026ldquo;subclass API\u0026rdquo; (often called \u0026ldquo;protected\u0026rdquo; in other languages). Some classes are designed to be inherited from, either to extend or modify aspects of the class\u0026rsquo;s behavior. When designing such a class, take care to make explicit decisions about which attributes are public, which are part of the subclass API, and which are truly only to be used by your base class.\n 基于这样的考虑，这里有Pyhton的建议：\n With this in mind, here are the Pythonic guidelines:\n  公共属性，前面没有下划线。   Public attributes should have no leading underscores.\n   如果你的公共属性与保留关键字冲突，在你的属性名后面加上一个_(下划线).这比缩写或者拼写错误更好。（但是，尽管有这个规定，对于已知是类的任何变量或参数，特别是类方法的第一个参数，“cls”是首选拼写。）\nNote1：有关类方法，请参阅上面的参数名称建议。\n   If your public attribute name collides with a reserved keyword, append a single trailing underscore to your attribute name. This is preferable to an abbreviation or corrupted spelling. (However, notwithstanding this rule, \u0026lsquo;cls\u0026rsquo; is the preferred spelling for any variable or argument which is known to be a class, especially the first argument to a class method.)\nNote 1: See the argument name recommendation above for class methods.\n   对于简单的公共数据变量，最好公开属性名，不用复杂的accessor/mutator方法。请记住，Python提供了一个通往未来增强的简单路径，如果你发现了一个简单的数据属性需要增长功能行为。在这种情况下，使用属性将功能实现隐藏在简单的数据属性访问语法之后。\nNote1:特性(Properties)只工作在新式类中。\nNote2：尽量使函数行为无副作用，尽管像缓存这样的副作用通常是好的\nNote3：避免使用属性进行计算开销大的操作;属性表示法使调用者相信访问是(相对)便宜的。\n   For simple public data attributes, it is best to expose just the attribute name, without complicated accessor/mutator methods. Keep in mind that Python provides an easy path to future enhancement, should you find that a simple data attribute needs to grow functional behavior. In that case, use properties to hide functional implementation behind simple data attribute access syntax.\nNote 1: Properties only work on new-style classes.\nNote 2: Try to keep the functional behavior side-effect free, although side-effects such as caching are generally fine.\nNote 3: Avoid using properties for computationally expensive operations; the attribute notation makes the caller believe that access is (relatively) cheap.\n   如果你的类被打算子类化，并且如果您不希望使用子类的属性，可以考虑使用__(双前导下划线)和无后导下划线来命名它们。这将调用Python的名称转换算法，其中类的名称将转换为属性名。这有助于避免在子类无意中包含具有相同名称的属性时发生属性名称冲突。\nNote1：注意，在混乱的名称中只使用简单的类名，因此，如果子类同时选择相同的类名和属性名，仍然会发生名称冲突。\nNote2：名称篡改可以使某些用途变得不那么方便，比如调试和getattr()。但是，名称篡改(mangling)算法有很好的文档记录，并且很容易手工执行。\nNote3：不是每个人都喜欢乱改名字。尽量平衡避免意外名称冲突与高级调用者可能使用的名称冲突的需要。\n   If your class is intended to be subclassed, and you have attributes that you do not want subclasses to use, consider naming them with double leading underscores and no trailing underscores. This invokes Python\u0026rsquo;s name mangling algorithm, where the name of the class is mangled into the attribute name. This helps avoid attribute name collisions should subclasses inadvertently contain attributes with the same name.\nNote 1: Note that only the simple class name is used in the mangled name, so if a subclass chooses both the same class name and attribute name, you can still get name collisions.\nNote 2: Name mangling can make certain uses, such as debugging and getattr(), less convenient. However the name mangling algorithm is well documented and easy to perform manually.\nNote 3: Not everyone likes name mangling. Try to balance the need to avoid accidental name clashes with potential use by advanced callers.\n 任何向后兼容性保证都只适用于公共接口。因此，用户能够清楚地区分公共接口和内部接口是很重要的。\n Any backwards compatibility guarantees apply only to public interfaces. Accordingly, it is important that users be able to clearly distinguish between public and internal interfaces.\n 文档化的接口被认为是公共的，除非文档明确声明它们是临时的或内部接口，不受通常的向后兼容性保证的约束。所有未文档化的接口都应该被认为是内部的。\n Documented interfaces are considered public, unless the documentation explicitly declares them to be provisional or internal interfaces exempt from the usual backwards compatibility guarantees. All undocumented interfaces should be assumed to be internal.\n 为了更好地支持自省，模块应该使用all属性显式地在其公共API中声明名称。将all设置为空列表表示该模块没有公共API。\n To better support introspection, modules should explicitly declare the names in their public API using the all attribute. Setting all to an empty list indicates that the module has no public API.\n 即使all进行了适当的设置，内部接口(包、模块、类、函数、属性或其他名称)仍然应该以单个前导下划线作为前缀。\n Even with all set appropriately, internal interfaces (packages, modules, classes, functions, attributes or other names) should still be prefixed with a single leading underscore.\n 如果任何包含名称空间(包、模块或类)被认为是内部的，那么接口也被认为是内部的。\n An interface is also considered internal if any containing namespace (package, module or class) is considered internal.\n 导入的名称应该始终被视为实现细节。其他模块不能依赖于对这些导入名称的间接访问，除非它们是包含模块的API(如os)的显式文档部分。从子模块公开功能的路径或包的init模块。\n Imported names should always be considered an implementation detail. Other modules must not rely on indirect access to such imported names unless they are an explicitly documented part of the containing module\u0026rsquo;s API, such as os.path or a package\u0026rsquo;s init module that exposes functionality from submodules.\n   编写代码的方式不应该损害Python的其他实现(PyPy、Jython、IronPython、Cython、Psyco等)。\n例如，对于形式为a += b或a = a + b的语句，不要依赖于CPython的就地字符串连接的高效实现。这种优化是脆弱的甚至在CPython的(只适用于某些类型)和不存在在不使用refcounting实现。在库的性能敏感部分，应该使用“.join()”形式。这将确保在不同实现之间以线性时间进行连接。\n Code should be written in a way that does not disadvantage other implementations of Python (PyPy, Jython, IronPython, Cython, Psyco, and such).\nFor example, do not rely on CPython\u0026rsquo;s efficient implementation of in-place string concatenation for statements in the form a += b or a = a + b. This optimization is fragile even in CPython (it only works for some types) and isn\u0026rsquo;t present at all in implementations that don\u0026rsquo;t use refcounting. In performance sensitive parts of the library, the \u0026lsquo;'.join() form should be used instead. This will ensure that concatenation occurs in linear time across various implementations.\n   像None这样的比较应该始终使用is或is not，而不是相等运算符。\n另外，当你真正的意思是x不是None时，要注意不要写if x。例如，当测试一个默认为None的变量或参数是否被设置为其他值时。另一个值可能具有在布尔上下文中为false的类型(例如容器)!\n Comparisons to singletons like None should always be done with is or is not, never the equality operators.\nAlso, beware of writing if x when you really mean if x is not None \u0026ndash; e.g. when testing whether a variable or argument that defaults to None was set to some other value. The other value might have a type (such as a container) that could be false in a boolean context!\n   Use is not operator rather than not \u0026hellip; is. While both expressions are functionally identical, the former is more readable and preferred.\nYes:\n if foo is not None:\r No:\n if not foo is None:\r   When implementing ordering operations with rich comparisons, it is best to implement all six operations (eq, ne, lt, le, gt, ge) rather than relying on other code to only exercise a particular comparison.\nTo minimize the effort involved, the functools.total_ordering() decorator provides a tool to generate missing comparison methods.\nPEP 207 indicates that reflexivity rules are assumed by Python. Thus, the interpreter may swap y \u0026gt; x with x \u0026lt; y, y \u0026gt;= x with x \u0026lt;= y, and may swap the arguments of x == y and x != y. The sort() and min() operations are guaranteed to use the \u0026lt; operator and the max() function uses the \u0026gt; operator. However, it is best to implement all six operations so that confusion doesn\u0026rsquo;t arise in other contexts.\n  Always use a def statement instead of an assignment statement that binds a lambda expression directly to an identifier.\nYes:\n def f(x): return 2*x\r No:\n f = lambda x: 2*x\r The first form means that the name of the resulting function object is specifically \u0026lsquo;f\u0026rsquo; instead of the generic \u0026lsquo;\u0026rsquo;. This is more useful for tracebacks and string representations in general. The use of the assignment statement eliminates the sole benefit a lambda expression can offer over an explicit def statement (i.e. that it can be embedded inside a larger expression)\n  Derive exceptions from Exception rather than BaseException. Direct inheritance from BaseException is reserved for exceptions where catching them is almost always the wrong thing to do.\nDesign exception hierarchies based on the distinctions that code catching the exceptions is likely to need, rather than the locations where the exceptions are raised. Aim to answer the question \u0026ldquo;What went wrong?\u0026rdquo; programmatically, rather than only stating that \u0026ldquo;A problem occurred\u0026rdquo; (see PEP 3151 for an example of this lesson being learned for the builtin exception hierarchy)\nClass naming conventions apply here, although you should add the suffix \u0026ldquo;Error\u0026rdquo; to your exception classes if the exception is an error. Non-error exceptions that are used for non-local flow control or other forms of signaling need no special suffix.\n  Use exception chaining appropriately. In Python 3, \u0026ldquo;raise X from Y\u0026rdquo; should be used to indicate explicit replacement without losing the original traceback.\nWhen deliberately replacing an inner exception (using \u0026ldquo;raise X\u0026rdquo; in Python 2 or \u0026ldquo;raise X from None\u0026rdquo; in Python 3.3+), ensure that relevant details are transferred to the new exception (such as preserving the attribute name when converting KeyError to AttributeError, or embedding the text of the original exception in the new exception message).\n  When raising an exception in Python 2, use raise ValueError(\u0026lsquo;message\u0026rsquo;) instead of the older form raise ValueError, \u0026lsquo;message\u0026rsquo;.\nThe latter form is not legal Python 3 syntax.\nThe paren-using form also means that when the exception arguments are long or include string formatting, you don\u0026rsquo;t need to use line continuation characters thanks to the containing parentheses.\n  When catching exceptions, mention specific exceptions whenever possible instead of using a bare except: clause:\n try:\rimport platform_specific_module\rexcept ImportError:\rplatform_specific_module = None\r A bare except: clause will catch SystemExit and KeyboardInterrupt exceptions, making it harder to interrupt a program with Control-C, and can disguise other problems. If you want to catch all exceptions that signal program errors, use except Exception: (bare except is equivalent to except BaseException:).\nA good rule of thumb is to limit use of bare \u0026lsquo;except\u0026rsquo; clauses to two cases:\n If the exception handler will be printing out or logging the traceback; at least the user will be aware that an error has occurred. If the code needs to do some cleanup work, but then lets the exception propagate upwards with raise. try\u0026hellip;finally can be a better way to handle this case.    When binding caught exceptions to a name, prefer the explicit name binding syntax added in Python 2.6:\n try:\rprocess_data()\rexcept Exception as exc:\rraise DataProcessingFailedError(str(exc))\r This is the only syntax supported in Python 3, and avoids the ambiguity problems associated with the older comma-based syntax.\n  When catching operating system errors, prefer the explicit exception hierarchy introduced in Python 3.3 over introspection of errno values.\n  Additionally, for all try/except clauses, limit the try clause to the absolute minimum amount of code necessary. Again, this avoids masking bugs.\nYes:\n try:\rvalue = collection[key]\rexcept KeyError:\rreturn key_not_found(key)\relse:\rreturn handle_value(value)\r No:\n try:\r# Too broad!\rreturn handle_value(collection[key])\rexcept KeyError:\r# Will also catch KeyError raised by handle_value()\rreturn key_not_found(key)\r   When a resource is local to a particular section of code, use a with statement to ensure it is cleaned up promptly and reliably after use. A try/finally statement is also acceptable.\n  Context managers should be invoked through separate functions or methods whenever they do something other than acquire and release resources.\nYes:\nwith conn.begin_transaction():\rdo_stuff_in_transaction(conn)\r No:\nwith conn:\rdo_stuff_in_transaction(conn)\r The latter example doesn\u0026rsquo;t provide any information to indicate that the enter and exit methods are doing something other than closing the connection after a transaction. Being explicit is important in this case.\n  Be consistent in return statements. Either all return statements in a function should return an expression, or none of them should. If any return statement returns an expression, any return statements where no value is returned should explicitly state this as return None, and an explicit return statement should be present at the end of the function (if reachable).\nYes:\n def foo(x):\rif x \u0026gt;= 0:\rreturn math.sqrt(x)\relse:\rreturn None\rdef bar(x):\rif x \u0026lt; 0:\rreturn None\rreturn math.sqrt(x)\r No:\n def foo(x):\rif x \u0026gt;= 0:\rreturn math.sqrt(x)\rdef bar(x):\rif x \u0026lt; 0:\rreturn\rreturn math.sqrt(x)\r   Use string methods instead of the string module.\nString methods are always much faster and share the same API with unicode strings. Override this rule if backwards compatibility with Pythons older than 2.0 is required.\n  Use \u0026lsquo;'.startswith() and \u0026lsquo;'.endswith() instead of string slicing to check for prefixes or suffixes.\nstartswith() and endswith() are cleaner and less error prone:\n Yes: if foo.startswith('bar'):\rNo: if foo[:3] == 'bar':\r   Object type comparisons should always use isinstance() instead of comparing types directly.\n Yes: if isinstance(obj, int):\rNo: if type(obj) is type(1):\r When checking if an object is a string, keep in mind that it might be a unicode string too! In Python 2, str and unicode have a common base class, basestring, so you can do:\n if isinstance(obj, basestring):\r Note that in Python 3, unicode and basestring no longer exist (there is only str) and a bytes object is no longer a kind of string (it is a sequence of integers instead).\n  For sequences, (strings, lists, tuples), use the fact that empty sequences are false.\n Yes: if not seq:\rif seq:\rNo: if len(seq):\rif not len(seq):\r   Don\u0026rsquo;t write string literals that rely on significant trailing whitespace. Such trailing whitespace is visually indistinguishable and some editors (or more recently, reindent.py) will trim them.\n  Don\u0026rsquo;t compare boolean values to True or False using ==.\n Yes: if greeting:\rNo: if greeting == True:\rWorse: if greeting is True:\r   Use of the flow control statements return/break/continue within the finally suite of a try\u0026hellip;finally, where the flow control statement would jump outside the finally suite, is discouraged. This is because such statements will implicitly cancel any active exception that is propagating through the finally suite.\nNo:\n def foo():\rtry:\r1 / 0\rfinally:\rreturn 42\r   With the acceptance of PEP 484, the style rules for function annotations are changing.\n  In order to be forward compatible, function annotations in Python 3 code should preferably use PEP 484 syntax. (There are some formatting recommendations for annotations in the previous section.)\n  The experimentation with annotation styles that was recommended previously in this PEP is no longer encouraged.\n  However, outside the stdlib, experiments within the rules of PEP 484 are now encouraged. For example, marking up a large third party library or application with PEP 484 style type annotations, reviewing how easy it was to add those annotations, and observing whether their presence increases code understandability.\n  The Python standard library should be conservative in adopting such annotations, but their use is allowed for new code and for big refactorings.\n  For code that wants to make a different use of function annotations it is recommended to put a comment of the form:\nnear the top of the file; this tells type checker to ignore all annotations. (More fine-grained ways of disabling complaints from type checkers can be found in PEP 484.)\n  Like linters, type checkers are optional, separate tools. Python interpreters by default should not issue any messages due to type checking and should not alter their behavior based on annotations.\n  Users who don\u0026rsquo;t want to use type checkers are free to ignore them. However, it is expected that users of third party library packages may want to run type checkers over those packages. For this purpose PEP 484 recommends the use of stub files: .pyi files that are read by the type checker in preference of the corresponding .py files. Stub files can be distributed with a library, or separately (with the library author\u0026rsquo;s permission) through the typeshed repo [5].\n  For code that needs to be backwards compatible, type annotations can be added in the form of comments. See the relevant section of PEP 484 [6].\n  PEP 526 introduced variable annotations. The style recommendations for them are similar to those on function annotations described above:\n  Annotations for module level variables, class and instance variables, and local variables should have a single space after the colon.\n  There should be no space before the colon.\n  If an assignment has a right hand side, then the equality sign should have exactly one space on both sides.\n  Yes:\n code: int\rclass Point:\rcoords: Tuple[int, int]\rlabel: str = '\u0026lt;unknown\u0026gt;'\r   No:\ncode:int # No space after colon\rcode : int # Space before colon\rclass Test:\rresult: int=0 # No spaces around equality sign\r   Although the PEP 526 is accepted for Python 3.6, the variable annotation syntax is the preferred syntax for stub files on all versions of Python (see PEP 484 for details).\n  ","id":16,"section":"posts","summary":"常量通常定义在代码前面，并且全都大写，分割的时候用_（下划线）分割。比如想，MAX_OVERFLOW和TOTAL这样。 Constants are usually defined on a module level and written in","tags":["Python"],"title":"PEP-8——Python代码的风格指导","uri":"https://zhihao2020.github.io/2020/04/pep-8python%E4%BB%A3%E7%A0%81%E7%9A%84%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%AF%BC/","year":"2020"},{"content":"定额计价法　 定额计价法的概念 定额计价是根据招标文件，按照各国家建设行政主管部门发布的建设工程预算定额的“工程量计算规则”，同时参照省级建设主管部门发布的人工工日单价、机械台班单价、材料以及设备价格信息及同期市场价格，直接计算直接工程费，再按规定的计算计算方法计算间接费、利润、税金，汇总确定建筑安装工程造价。\n定额计价法的特点 定额计价法是我们使用了几十年的一种计价模式，其基本特征就是价格=定额+费用+文件规定，并作为法定性的依据强制执行，不论是工程招标编制标底还是投标报价均以此为唯一的依据，承发包双方共用一本定额和费用标准确定标底价和投标报价，一旦定额价与市场价脱节就会影响计价的准确性。\n定额计价是建立在以政府定价为主导的计划经济管理基础上的价格管理模式，它所体现的是政府对工程价格的直接管理和调控。\n工程量清单计价 这种计价方式，是时代的趋势，是市场经济的要求。\n工程量清单计价概念 工程量清单计价是指 投标人完成由 招标人提供的 工程量清单所需的全部费用，包括分部分项工程费、措施项目费、其他项目费、规费和税金\n工程量清单计价方式，是在建设工程招投标中，招标人自行或委托具有资质的中介机构编制反映工程实体消耗和措施性消耗的工程量清单，并作为招标文件的一部分提供给投标人，由投标人依据工程量清单自主报价的计价方式。在工程招标中采用工程量清单计价是国际上较为通行的做法。\n工程量清单计价的特点 1、工程量清单均采用了综合单价形式，综合单价中包含了工程直接费、间接费、管理费、风险费、利润、国家规定的各种规费等，一目了然，更适合工程招投标。\n2、工程量清单报价要求投标单位根据市场行情，自身实力报价，这就要求投标人注重工程单价的分析，在报价中反映本投标单位的实际能力。\n3、工程量清单报价具有合同化的法定性，本质上是单价合同的计价模式，中标后的单价一经合同确认，在竣工结算时不能调整，即量变价不变。\n4、工程量报价有利于加强合同的管理，明确承发包双方的责任，实现风险的合理分担，工程量的误差由发包方承担，工程报价的风险由投标方承担。\n5、工程量清单报价将推动计价依据的改革发展，推动企业编制自己的企业定额，提高自己的工程技术水平和经营管理能力。\n6、工程量清单计价是国际通行的计价办法，在我国实行工程量清单计价，有利于提高国内建设各方主体参与国际化竞争的能力。\n工程量清单计价与传统的定额计价的区别 抽象意义上的不同 1、工程量清单计价与定额计价不仅仅是在表现形式、计价方法上发生了变化，而是从定额管理方式和计价模式上发生了变化。首先，从思想观念上对定额管理工作有了新的认识和定位。 由于工程量清单计价提供的是计价规则、计价办法以及定额消耗量，摆脱了定额标准价格的概念，真正实现了量价分离、企业自主报价、市场有序竞争形式价格。工程量清单报价按相同的工程量和统一的计量规则，由企业根据自身情况报出综合单价，价格高低完全由企业自己确定，充分体现了企业的实力，同时也真正体现出公开、公平、公正。　采用行业统一定额计价，投标企业没有定价的发言权，只能被动接受。而工程量清单投标报价，可以充分发挥企业的能动性，企业利用自身的特点，使企业在投标中处于优势的位置。同时工程量清单报价体现了企业技术管理水平等综合实力，也促进企业在施工中加强管理、鼓励创新、从技术中要效率、从管理中要利润，在激烈的市场竞争中不断发展和壮大，企业的经营管理水平高，可以降低管理费，自有的机械设备齐全，可减少报价中的机械租赁费用，对未来要素价格发展趋势预测准确，就可以减少承包风险，增强竞争力，其结果促进了优质企业做大做强，使无资金、无技术，无管理的小企业、包工头退出市场，实现了优胜劣汰，从而形成管理规范、竞争有序的建设市场秩序。\n2、工程量清单计价是属于全面成本管理的范畴，其思路是“统一计算规则，有效控制水量，彻底放开价格，正确引导企业自主报价、市场有序竞争形成价格”。跳出传统的定额计价模式，建立一种全新的计价模式，依靠市场和企业的实力通过竞争形成价格，使业主通过企业报价可直观的了解项目造价。 具体表现的不同 1、编制对象与综合内容不同 工程量清单项目的工程内容是 以最终产品为对象，按实际完成一个综合实体项目所需工程内容列项。其工程量计算规则 是根据主体工程项目设置的，综合了清单项目的全部工程内容。\n基础定额项目主要 是以施工过程为对象划分的，工程量计算规则仅是单一的工程内容。\n2、计算口径不同 工程量清单项目工程量计算规则是 按工程实体尺寸的净量计算，不考虑施工方法和加工余量。\n基础定额则考虑了不同施工方法和加工余量的施工过程的实际数量。\n例如：土石方工程中的“挖基坑土方”，\n 按计算规范规定，工程量清单项目计算是按图示尺寸数量计算的净量（基础垫层底面积×挖土深度），不包括放坡及工作面等的开挖量。 基础定额项目计算则按实际开挖量计算，包括放坡及工作面等的开挖量，即包含了为满足施工工艺要求而增加的加工余量。  在工程量清单项目计算规范中，挖基坑土方的工程内容综合了排地表水、土方开挖、围护（挡土板）及支拆、基坑钎探、运输等内容。而在基础定额中则将上述的工程内容都作为单独的定额子目处理。\n3、计量单位不同 工程量清单项目的计量单位一般采用基本的物理计量单位或自然单位，如m^2,m^3基础定额中的计量单位 还包括扩大的物理计量单位，如100m^2，1000m^3,100m等。\n那么它们都什么时候用呢？  看合同约定，一般招投标都是清单计价 政府项目必须用清单计价，地产公司项目或私人项目可以采用 定额招标方式。  ","id":17,"section":"posts","summary":"定额计价法 定额计价法的概念 定额计价是根据招标文件，按照各国家建设行政主管部门发布的建设工程预算定额的“工程量计算规则”，同时参照省级建设主管","tags":["工程造价"],"title":"定额计价与清单计价","uri":"https://zhihao2020.github.io/2020/04/%E5%AE%9A%E9%A2%9D%E8%AE%A1%E4%BB%B7%E4%B8%8E%E6%B8%85%E5%8D%95%E8%AE%A1%E4%BB%B7/","year":"2020"},{"content":"对于爬虫来说，知道了网站的数据自增ID，那么就能将整个站点爬取下来。不过，那些大站，比如油管之类的，他们绝不会把业务的自增ID暴露出来，而是用一种可逆的字符串替代。\n一般有这么几种方法:\n 使用Hashids，Hashids是一个小型的开放源代码库，可从数字生成短的，唯一的，非顺序的ID。 Base64编码，这个方法最直接，大多数语言也具有这个功能。不过没有Hashids的花哨功能。 根据timestamp生成ID，使用计数器（如果有的话）+时间戳+一些系统值+一个随机整数。许多公司都采用这种方法，因为它在分布式系统中效果很好。这些id是彼此独立生成的，发生碰撞的风险非常小，可以忽略不计。 如果ID仅包含数字，可以使用Optimus，它基于Knuth的整数哈希方法，并产生混淆的整数ID。只有PHP和Go实现。 Nano ID，一个很小的，安全的，URL友好的，唯一的JavaScript字符串ID生成器。它也可用于多种语言。 其他的方法  使用hashids 安装\npip install hashids\r 使用\n首先初始化一个hashids示例\nfrom hashids import Hashids\r 编码（加密）\nid = hashids.encode(2)\r 生成的字符ID长度和数值大小有关。\n解码（解密）\nnum = hashids.decode('j0gW')\r 解码后返回时一个元组。如果你解码一个随机的字符串ID，不一定能恢复成数字，此时会返回空元组。\n不过，因为hashids可逆，所以拿到ID后可以反向推测出原始数字ID。我们在编码的时候可以指定盐值。理论上，盐值不泄露，就很难破解。\n指定盐值\nhashids = Hashids(salt=\u0026quot;aaa\u0026quot;)\rhashids.encode(123)\r 同样的数字使用不同的盐值编码得到的字符串是不同的，别人就无法猜出原始ID是多少了。\n限制hash长度\n默认情况下，数字越小，编码生成的字符串也比较断，为了讲不通大小的数值转化为统一长度的字符串，在初始化hashids时，可以指定hash的最小长度。\nhashids = Hashids(salt=\u0026quot;aaa\u0026quot;,min_length=10)\rhashids.encode(123)\r 限制hash的字符种类\n如果你不希望hash中有大写字母，那么可以在初始化的时候，指定hash字符串的范围，例如我们可以指定为所有的小写字母\nhashids = Hashids(alphabet=\u0026quot;abcdefghigklmopkrst\u0026quot;)\rhashids.encode(123)\r 需要注意的时候，alphabet至少要指定16个以上的不同字符。\nBase64 Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于\n$$ \\log_264=6 $$ 所以每6个比特为一个单元，可以对应某个打印字符。\n其它的方法之后会再写 ","id":18,"section":"posts","summary":"对于爬虫来说，知道了网站的数据自增ID，那么就能将整个站点爬取下来。不过，那些大站，比如油管之类的，他们绝不会把业务的自增ID暴露出来，而是","tags":["爬虫","反爬"],"title":"得到真正的业务ID","uri":"https://zhihao2020.github.io/2020/04/%E5%8F%8D%E6%89%92id%E4%B9%8Bhashids/","year":"2020"},{"content":"Git介绍 Git其实就是一个版本控制系统。它记录着文件内容的变化，你可以查阅每次修改的情况。\n其实很多人就一直在使用版本控制系统，许多人习惯把整个项目文件放到一个特定的文件夹中，并注明备份的时间以示区分。这是一个不错的整理自己文件的习惯，不过它虽然简单，但如果有时候一不小心混淆了所在的工作目录，或者写错文件，或者意外的覆盖了文件，那么就很难再将它们找回来了。\n其实除了Git，人们很早也开发了许多本地版本控制系统，早期的系统大多就是采用某种简单的数据库来记录文件历次更新的差异。但它们都是基于本地的系统。\n再后来，人们慢慢想到要让不同的开发者协同工作，这时候，就有了新的系统。它们都有单一的集中管理的服务器，服务器里保存着所有文件的修订版本。\n嗯，这样有了很大的进步。不过，把所有的鸡蛋都放在同一个菜篮子里，总是有那么些不安全。这样一来，分布式版本控制系统（DVCS)诞生了。在这个系统里，客户端是把代码仓库完整的拷贝下来，而不是像以前那样，仅仅就是最新文件的快照。这样即使服务器宕机，那么每一个拷贝下来的仓库，都能及时进行部署。\nGit就是有这个神奇功能的软件。\nGit特点 Git的三种状态 Git中的文件有三种状态。已提交（committed）、已修改（modified）和已暂存（staged）\n 已提交：表示数据已经安全保存在本地数据库中。 已修改：表示修改文件，但还没有保存都数据库中。 已暂存：表示对一个已修改文件的当前版本做了标记，是指包含了在下一次提交的快照中。  这三种状态，对应了三个工作区的概念：Git仓库、工作目录和暂存区域\nGit仓库目录，是Git用来保存项目数据和对象数据库的地方。这是Git最重要的部分。其实从其他计算机克隆仓库时，拷贝的就是这里的数据。\n工作目录 就是对项目的某个版本独立提取出来的内容。\n暂存文件 是一个文件，保存了下一次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称为“索引”\nGt直接记录快照，而非差异比较 每次你提交更新，或在Git中保存项目状态时，他主要对当时的文件制作一个快照并保存这个快照的索引。Git对待数据更像是一个快照流。\nGit中几乎所有操作都是本地执行 在Git中绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其他计算机的信息。这意味着，你在飞机或者火车上没有网络的情况下，想做些工作，你能愉快地提交，并且直到有网络连接时再上传。\nGit保证完整性 Git中的所有数据在存储前都计算校验和，然后以校验和来引用。这样，就能确保每次传输过程中，都能保证完整；如果不完整的话，Git就会及时发现。\nGit一般只添加数据 你在执行Git操作的时候，几乎只往Git数据库中增加数据，那么就很难执行不可逆的操作。当然你得需要每次都要进行提交。\n你了解了这个，我们使用Git就会很安心了。我们知道我们尝试了多种操作，而没有把事情搞糟的危险。\n当然，你也可以去参加开源社区做出贡献了！ 下一篇，我就会写关于Git的操作了。\n","id":19,"section":"posts","summary":"Git介绍 Git其实就是一个版本控制系统。它记录着文件内容的变化，你可以查阅每次修改的情况。 其实很多人就一直在使用版本控制系统，许多人习惯把","tags":["Git"],"title":"为什么要使用Git","uri":"https://zhihao2020.github.io/2020/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8git/","year":"2020"},{"content":"更新文章 hugo --theme= --baseUrl=\u0026quot;\u0026quot; --buildDrafts\rgit remote add origin https://github.com/XXX/XXX.github.io.git\rcd public\rgit add .\rgit commit -m \u0026quot;XXXX/XX/XX\u0026quot;\rgit push -u origin master\r ","id":20,"section":"posts","summary":"更新文章 hugo --theme= --baseUrl=\u0026quot;\u0026quot; --buildDrafts git remote add origin https://github.com/XXX/XXX.github.io.git cd public git add . git commit -m \u0026quot;XXXX/XX/XX\u0026quot; git push -u origin master","tags":["Hugo","Git"],"title":"Hugo的操作","uri":"https://zhihao2020.github.io/2020/04/%E6%9B%B4%E6%96%B0hugo/","year":"2020"},{"content":"简单介绍一下 汉语拼音，分为声母与韵母。全拼打字的时候，是将它们都打出来，比如[双]字 就需要打出shuang，相比双拼效率就低了。\n双拼，是将声母与韵母分开，除了zh、ch、sh之外，所有的声母都是键盘上的标准键。而把韵母分配的键盘26个按键上，这么一来每一个字字需要按两个键（一个声母和一个韵母）就可以完成输入了。\n我使用的就是[小鹤双拼]\n它为了让大家记住键位，还编了首曲子哈哈哈\n我的使用心得 使用了双拼之后，将自己所有电子设备的输入法都改为了双拼，现在，你在让我使用全拼到也很不适应了。\n从使用曲子辅助记忆到已经形成肌肉记忆，我大概花了一周的时间。之后就能熟练的使用双拼，学习新东西的那个过程是曲折的，但是一旦挺过来，那么就是光明的了。\n","id":21,"section":"posts","summary":"简单介绍一下 汉语拼音，分为声母与韵母。全拼打字的时候，是将它们都打出来，比如[双]字 就需要打出shuang，相比双拼效率就低了。 双拼，是将声","tags":["双拼"],"title":"从全拼到双拼","uri":"https://zhihao2020.github.io/2020/04/%E4%BB%8E%E5%85%A8%E6%8B%BC%E5%88%B0%E5%8F%8C%E6%8B%BC/","year":"2020"},{"content":"def teach_yourself(anything):\rwhile not creat(something):\rlearn()\rpractice()\rreturn teach_yourself(another)\rteach_yourself(something)\r 我挺赞同这个伪代码的，自学的过程就是不断学习、不断创造的过程，并将能否进行创造作为自学成功与否的关键。\n自学是时代的要求 在大学中，自学是必备的技能。学生时期是时间最为最为充分的时期，在这个时期吸足了养分，才能在接下来的漫长岁月中，更加茁壮。\n现在，是一个信息爆炸的时代，但是知识是不会爆炸的。那些之所以称为泡沫的东西，都是缺少了价值作为基础，反之，那些真正有价值的东西，是不会爆炸的，他会随着时间不断积累，不断增值。比如，现在的人工智能，它的理论在上个世纪就已经很完善了，只是当前机器的算力越来越强，才让那些理论真正的实现。\n求人不如求己，人与人之间的交往本质上就是交换，通过不断的自学，能实现自身价值的增值。在说后的社交中，也会处于更有利的地位。\n自学也是个人的一种乐趣 你不断的学习东西，通过他们进行创造，你将不断收获惊喜。并且，也会享受到之间你掌握那些手艺带来的方便、愉快。\n 用既有政策下的结果反对改革——陆铭\n 我也想通过不句话来说明，不要以为这些知识到来不了什么，只是你从未拥有，所以你才从未感受到，于是，你甚至信以为真，真的不去再学习。\n当这成为你的一种习惯，内化的你的骨子里。那么，不学习、不进步才会让你更加难受。这时你也真正的进化了。\n","id":22,"section":"posts","summary":"def teach_yourself(anything): while not creat(something): learn() practice() return teach_yourself(another) teach_yourself(something) 我挺赞同这个伪代码的，自学的过程就是不断学习、不断创造的过程，并将能否进行创造作为自学成功与否的关键。 自学是时代的要求 在","tags":["自学","自我提升"],"title":"关于自学的感想（1）","uri":"https://zhihao2020.github.io/2020/04/%E5%85%B3%E4%BA%8E%E8%87%AA%E5%AD%A6%E7%9A%84%E6%84%9F%E6%83%B31/","year":"2020"},{"content":" 人生而就是不平等的，但是在时间上却是平等的\n 珍惜自己的时间，远离焦虑 这个世界上又这么一个银行，他每天给你1440的资产，让你去消费，而且过了今天就一切清零，再给你1440.资产不会积累，只能不断消耗，但是每天的供应都是一样多。它其实就叫做时间银行。\n与其因焦虑而不断浪费自己的时间，不如去好好的利用它们、好好的享受它们。那些使用这些资产去学习、提升自己的人，其实本质上是相信自己以后的时间会更值钱。\n人就是很奇怪，对有形的东西感知能力还在线，对于那一些不容易感知的就会失去感觉，不信的话，想想你自己在家的这段时间，还能记得今天是周几吗？\n","id":23,"section":"posts","summary":"人生而就是不平等的，但是在时间上却是平等的 珍惜自己的时间，远离焦虑 这个世界上又这么一个银行，他每天给你1440的资产，让你去消费，而且过了今","tags":["爱自己"],"title":"爱惜自己的时间","uri":"https://zhihao2020.github.io/2020/04/%E7%88%B1%E6%83%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E9%97%B4/","year":"2020"}],"tags":[{"title":"Git","uri":"https://zhihao2020.github.io/tags/git/"},{"title":"Hugo","uri":"https://zhihao2020.github.io/tags/hugo/"},{"title":"JupyterLab","uri":"https://zhihao2020.github.io/tags/jupyterlab/"},{"title":"Markown","uri":"https://zhihao2020.github.io/tags/markown/"},{"title":"Python","uri":"https://zhihao2020.github.io/tags/python/"},{"title":"Python代码学习","uri":"https://zhihao2020.github.io/tags/python%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"title":"Python内建函数","uri":"https://zhihao2020.github.io/tags/python%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"title":"Python标准库","uri":"https://zhihao2020.github.io/tags/python%E6%A0%87%E5%87%86%E5%BA%93/"},{"title":"Python魔法方法","uri":"https://zhihao2020.github.io/tags/python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"},{"title":"双拼","uri":"https://zhihao2020.github.io/tags/%E5%8F%8C%E6%8B%BC/"},{"title":"反爬","uri":"https://zhihao2020.github.io/tags/%E5%8F%8D%E7%88%AC/"},{"title":"工程造价","uri":"https://zhihao2020.github.io/tags/%E5%B7%A5%E7%A8%8B%E9%80%A0%E4%BB%B7/"},{"title":"爬虫","uri":"https://zhihao2020.github.io/tags/%E7%88%AC%E8%99%AB/"},{"title":"爱自己","uri":"https://zhihao2020.github.io/tags/%E7%88%B1%E8%87%AA%E5%B7%B1/"},{"title":"自学","uri":"https://zhihao2020.github.io/tags/%E8%87%AA%E5%AD%A6/"},{"title":"自我提升","uri":"https://zhihao2020.github.io/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"}]}