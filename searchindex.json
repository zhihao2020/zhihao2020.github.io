{"categories":[{"title":"Python","uri":"https://xuzhihao.top/categories/python/"},{"title":"建筑方面","uri":"https://xuzhihao.top/categories/%E5%BB%BA%E7%AD%91%E6%96%B9%E9%9D%A2/"},{"title":"思考","uri":"https://xuzhihao.top/categories/%E6%80%9D%E8%80%83/"},{"title":"效率工具","uri":"https://xuzhihao.top/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"},{"title":"数据分析","uri":"https://xuzhihao.top/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"title":"数据库","uri":"https://xuzhihao.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"杂七杂八","uri":"https://xuzhihao.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"title":"生活","uri":"https://xuzhihao.top/categories/%E7%94%9F%E6%B4%BB/"},{"title":"神经网络","uri":"https://xuzhihao.top/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"title":"算法","uri":"https://xuzhihao.top/categories/%E7%AE%97%E6%B3%95/"}],"posts":[{"content":"粒子群算法介绍 粒子群算法(PSO)也是一种仿生算法，它模拟的是鸟类觅食过程，和遗传算法一样，刚开始也需要初始化一个种群(模拟鸟群)，每个粒子携带着位置信息和当前的运动速度。在每一步迭代中需要更新所有粒子的速度信息和位置信息(当前最好的位置)。 每个粒子的位置对应于求解问题中的自变量，判断当前位置好不好的标准和遗传算法一样，是通过适应度函数得到的(比如说对于求解最大值的问题，值越大越好)。在求解高维函数的最值问题当中，每个粒子的位置信息就是该高维函数的一组自变量值。 这个算法的核心在于速度更新公式。\n1、初始化 首先设置最大迭代次数，目标函数的自变量个数，粒子的最大速度，位置信息为整个搜索空间，我们在速度区间和搜索空间上随机初始化速度和位置，设置粒子群规模为M，每个粒子随机初始化一个飞翔速度。\n2、个体极值与全局最优解 定义适应度函数，个体极值为每个粒子找到最优解，从这些最优解找到一个全局值，叫做本次全局最优解。与历史全局最优比较，进行更新。\n3、更新速度和位置公式 $$ V_{id}=\\omega V_{id}+C_{1}random(0,1)(P_{id}-X_{id})+C_2random(0,2)(P_{id}-X_{id}) $$\n$$ X_{id}=X_{id}+V_{id} $$\n算法实现 1、初始化粒子，计算适应度值 初始化粒子x与速度v，并调用适应度函数计算适应度值。并选出最小适应度值及对应的x值\nx=[]\rv=[]\rfor j in range(self.N):\rx.append([random.random() for i in range(self.dim)])\rv.append([random.random() for m in range(self.dim)])\rfitness = [self.fun(x[j]) for j in range(self.N)]\rp = x\rbest = min(fitness)\rpg = x[fitness.index(min(fitness))]\r 2、更新粒子位置，计算新适应度 根据公式更新粒子位置及速度，并调用适应度函数计算适应度值\nfor t in range(self.T):\rfor j in range(self.N):\rfor m in range(self.dim):\rv[j][m] = self.w * v[j][m] + self.c1 * random.random() * (\rp[j][m] - x[j][m]) + self.c2 * random.random() * (pg[m] - x[j][m])\rfor j in range(self.N):\rfor m in range(self.dim):\rx[j][m] = x[j][m] + v[j][m]\rif x[j][m] \u0026gt; self.x_bound[1]:\rx[j][m] = self.x_bound[1]\rif x[j][m] \u0026lt; self.x_bound[0]:\rx[j][m] = self.x_bound[0]\rfitness_ = []\rfor j in range(self.N):\rfitness_.append(self.fun(x[j]))\r 3、更新粒子全局最优解 如果新计算出的适应值比前期计算的适应度值小，则更新粒子全局最优解\n4、整体代码 T为迭代次数，x_bound为粒子范围，w、C1、C2为公式参数，dim为粒子维度，N为 每次迭代粒子总数。fun函数根据自己需要可以进行修改。\nimport random\rimport matplotlib.pyplot as plt\rplt.rcParams['font.sans-serif'] = ['SimHei'] # 步骤一（替换sans-serif字体）\rplt.rcParams['axes.unicode_minus'] = False\rclass PSO(object):\rdef __init__(self):\rself.x_bound = [-1, 1]\rself.T = 100\rself.w = 0.15\rself.N = 10000\rself.dim = 20\rself.c1 = 1.5\rself.c2 = 1.5\rdef fun(self, x):\rresult = 0\rfor i in x:\rresult = result + pow(i, 2)\rreturn result\rdef pso_main(self):\rx = []\rv = []\rfor j in range(self.N):\rx.append([random.random() for i in range(self.dim)])\rv.append([random.random() for m in range(self.dim)])\rfitness = [self.fun(x[j]) for j in range(self.N)]\rp = x\rbest = min(fitness)\rpg = x[fitness.index(min(fitness))]\rbest_all = []\rfor t in range(self.T):\rfor j in range(self.N):\rfor m in range(self.dim):\rv[j][m] = self.w * v[j][m] + self.c1 * random.random() * (\rp[j][m] - x[j][m]) + self.c2 * random.random() * (pg[m] - x[j][m])\rfor j in range(self.N):\rfor m in range(self.dim):\rx[j][m] = x[j][m] + v[j][m]\rif x[j][m] \u0026gt; self.x_bound[1]:\rx[j][m] = self.x_bound[1]\rif x[j][m] \u0026lt; self.x_bound[0]:\rx[j][m] = self.x_bound[0]\rfitness_ = []\rfor j in range(self.N):\rfitness_.append(self.fun(x[j]))\rif min(fitness_) \u0026lt; best:\rpg = x[fitness_.index(min(fitness_))]\rbest = min(fitness_)\rbest_all.append(best)\rprint('第' + str(t) + '次迭代：最优解位置在' + str(pg) + '，最优解的适应度值为：' + str(best))\rplt.plot([t for t in range(self.T)], best_all)\rplt.ylabel('适应度值')\rplt.xlabel('迭代次数')\rplt.title('粒子群适应度趋势')\rplt.show()\rPSO_intance = PSO()\rPSO_intance.pso_main()\r 参考：https://mp.weixin.qq.com/s/gV39R_w25PXGcqc-AW5ZGg\n","id":0,"section":"posts","summary":"粒子群算法介绍 粒子群算法(PSO)也是一种仿生算法，它模拟的是鸟类觅食过程，和遗传算法一样，刚开始也需要初始化一个种群(模拟鸟群)，每个粒子","tags":["粒子算法"],"title":"Python实现粒子算法","uri":"https://xuzhihao.top/2020/06/python%E5%AE%9E%E7%8E%B0%E7%B2%92%E5%AD%90%E7%AE%97%E6%B3%95/","year":"2020"},{"content":"根据施工组织形式的不同，产生的经济效益也会不同。\n常见的施工组织形式就是：依次施工、平行施工、流水施工。\n依次施工 就是各个施工过程都是依次进行的，后序工序的实施需要前序工程的完成。这种施工方式是最常见、最简单的施工方式。\n它类似于我们初中物理学过的串联\n平行施工 就是几个相同的工程，在同一时间，不同地点上平行进行施工。\n它类似于并联。\n流水施工 就是在工艺上划分为若干个施工过程，在平面上划分为若干个施工段，在竖直方向上划分若干个施工层，然后按照施工顺序依次不断的投入到各施工层的施工段中。\n它的表现形式类似于阶梯那样。\n我们完全可以将这些理念。用于我们的日常生活中。\n比如，华罗庚提出的泡茶问题：\n 生活中经常需要沏茶。如果当时的情况是：没有开水，开水壶、茶壶、茶杯都要洗，还需要准备茶叶，应该怎么安排？\n办法甲：先做好准备工作，洗开水壶、茶壶、茶杯，拿茶叶。一切就绪后，灌水，烧水，等水开了泡茶喝。\n办法乙：洗净开水壶后，灌水，烧水。等水开了之后，洗茶壶、茶杯，拿茶叶，泡茶喝。\n办法丙：洗净开水壶后，灌水，烧水。利用等待水开的时候，洗茶壶、茶杯，拿茶叶，等水开了泡茶喝。\n哪种办法节省时间？显然是办法丙，因为前两种办法都“窝工”了。事实上，洗开水壶是烧开水的先决条件：没开水，没茶叶，不洗茶壶、茶杯，就不能泡茶，因而这些都是泡茶的先决条件。而烧开水，洗茶壶、茶杯，拿茶叶没有严格的先后关系。\n 流水施工中的参数 **施工过程数n：**它就是施工项目中划分为几个过程，例如：地下工程、一楼、二楼等等\n**施工段数m：**即施工过程数中又可以划分为几段。\n**流水节拍Ti：**某个专业队在一个施工段上工作的持续时间。我还是想亲切地称它为流水时间: )\n**流水步距K：**相邻两个专业队伍投入同一个施工段开始工作的时间间隔 $$ T=(m+n-1)K $$\n$$ T_{1}=mt_{i}=mK $$\n流水施工的组织方法 根据流水参数和工程施工特点，流水施工可以分为固定节拍流水、成倍节拍流水和分别流水。\n**固定流拍流水：**所有施工过程在各施工段的流水节拍彼此相等，且等于流水步距。\n**成倍节拍流水：**同一施工过程过程在各施工段上的流水节拍相等，不同施工过程在同一施工段上的流水节拍之间存在一个最大公约数，能使各施工过程的流水节拍互为整倍数。\n**分别漏水：**各个专业生产队的流水节拍不同，但按照施工顺序要求。使相邻两个专业工作队，能够最大程度的搭接起来，并能形成连续作业的非节奏流水施工。\n","id":1,"section":"posts","summary":"根据施工组织形式的不同，产生的经济效益也会不同。 常见的施工组织形式就是：依次施工、平行施工、流水施工。 依次施工 就是各个施工过程都是依次进行的","tags":["项目管理"],"title":"施工组织形式","uri":"https://xuzhihao.top/2020/06/%E6%96%BD%E5%B7%A5%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F/","year":"2020"},{"content":"numpy.random.uniform介绍：\n函数原型： numpy.random.uniform(low,high,size)\n功能：从一个均匀分布[low,high)中随机采样，注意定义域是左闭右开，即包含low，不包含high.\n参数介绍:\nlow: 采样下界，float类型，默认值为0；\rhigh: 采样上界，float类型，默认值为1；\rsize: 输出样本数目，为int或元组(tuple)类型，例如，size=(m,n,k), 则输出m*n*k个样本，缺省时输出1个值。\r 返回值：ndarray类型，其形状和参数size中描述一致。\nndarray类型，表示一个N维数组对象，其有一个shape（表维度大小）和dtype（说明数组数据类型的对象）\n","id":2,"section":"posts","summary":"numpy.random.uniform介绍： 函数原型： numpy.random.uniform(low,high,size) 功能：从一个均匀分布[low,high)中随机采样，注意定义域是左闭右开，即包含l","tags":["数据分析"],"title":"Numpy中的random.uniform","uri":"https://xuzhihao.top/2020/06/numpy%E4%B8%AD%E7%9A%84random.uniform/","year":"2020"},{"content":"常用功能 namedtuple 把元组变成一个针对简单任务的容器。你不需要使用整数索引来访问一个namedtuples的数据。你可以像字典(dict)⼀样访问namedtuples， 但namedtuples是不可变的。\nfrom collections import namedtuple\rUser = namedtuple(\u0026quot;User\u0026quot;,[\u0026quot;name\u0026quot;, \u0026quot;age\u0026quot;, \u0026quot;weight\u0026quot;])\ruser = User(\u0026quot;admin\u0026quot;, \u0026quot;20\u0026quot;, \u0026quot;60\u0026quot;)\rname, age, weight = userprint(user[0])\rprint(name, age, weight)\rprint(user.name, user.age, user.weight)# 输出结果如下\radmin\radmin 20 60\radmin 20 60\r namedtuple()相当于直接定义了一个新类，但是这个类跟创痛的定义class方式有巨大区别。该方式会比直接定义 class 的方式省很多空间，其次其返回值是一个 tuple，支持 tuple 的各种操作。\n有两个好用的方法：\n#将序列直接转换为新的tuple对象\ruser = [\u0026quot;root\u0026quot;,32,65]\ruser = User._make(user)\rprint(user)\r# 输出 User(name='root', age=32, weight=65)\r# 返回一个 dict\ruser = User(\u0026quot;admin\u0026quot;, 20, 60)\rprint(user._asdict())\r# 输出 OrderedDict([('name', 'admin'), ('age', 20), ('weight', 60)])\r ChainMap ChainMap() 可以将多个字典集合到一个字典中去，对外提供一个统一的视图。注意：该操作并是不将所有字典做了一次拷贝，实际上是在多个字典的上层又进行了一次封装而已。\nfrom collections import ChainMap\ruser1 = {\u0026quot;name\u0026quot;:\u0026quot;admin\u0026quot;, \u0026quot;age\u0026quot;:\u0026quot;20\u0026quot;}\ruser2 = {\u0026quot;name\u0026quot;:\u0026quot;root\u0026quot;, \u0026quot;weight\u0026quot;: 65}\rusers = ChainMap(user1, user2)\rprint(users.maps)\rusers.maps[0][\u0026quot;name\u0026quot;] = \u0026quot;tiger\u0026quot;\rprint(users.maps)\rfor key, value in users.items():\rprint(key, value)\r# 输出如下\r[{'name': 'admin', 'age': '20'}, {'name': 'root', 'weight': 65}][{'name': 'tiger', 'age': '20'}, {'name': 'root', 'weight': 65}]\rname tiger\rweight 65\rage 20\r 由此可见，如果 ChainMap() 中的多个字典有重复 key，查看的时候可以看到所有的 key，但遍历的时候却只会遍历 key 第一次出现的位置，其余的忽略。同时，我们可以通过返回的新的视图来更新原来的的字典数据。进一步验证了该操作不是做的拷贝，而是直接指向原字典。\ndeque dqueue 是 ”double-ended queue” 的简称，是一种类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop)操作。大大加快了遍历速度\nfrom collections import deque\rq = deque([1,2,3])\rq.append('4')\rq.appendleft('0')\rprint(q)\rprint(q.popleft())\r# 输出如下\rdeque(['0', 1, 2, 3, '4'])\r0\r Counter Counter 可以简单理解为一个计数器，可以统计每个元素出现的次数，同样 Counter() 是需要接受一个可迭代的对象的。\nfrom collections import Counter\ranimals = [\u0026quot;cat\u0026quot;, \u0026quot;dog\u0026quot;, \u0026quot;cat\u0026quot;, \u0026quot;bird\u0026quot;, \u0026quot;horse\u0026quot;, \u0026quot;tiger\u0026quot;, \u0026quot;horse\u0026quot;, \u0026quot;cat\u0026quot;]\ranimals_counter = Counter(animals)\rprint(animals_counter)\rprint(animals_counter.most_common(2))\rCounter({'cat': 3, 'horse': 2, 'dog': 1, 'bird': 1, 'tiger': 1})[('cat', 3), ('horse', 2)]\r# 输出如下\rCounter({'cat': 3, 'horse': 2, 'dog': 1, 'bird': 1, 'tiger': 1})[('cat', 3), ('horse', 2)]\r 其实一个 Counter 就是一个字典，其额外提供的 most_common() 函数通常用于求 Top k 问题。\nOrderedDict OrderedDict 是字典的子类，保证了元素的插入顺序。在 3.7 版本下，字典同样也保证了元素的插入顺序。那相比内置字典 OrderedDict 有哪些升级呢。\n 算法上， OrderedDict 可以比 dict 更好地处理频繁的重新排序操作。在跟踪最近的访问这种场景（例如在 LRU cache）下非常适用。 OrderedDict 类有一个 move_to_end() 方法，可以有效地将元素移动到任一端。  from collections import OrderedDict\ruser = OrderedDict()\ruser[\u0026quot;name\u0026quot;] = \u0026quot;admin\u0026quot;\ruser[\u0026quot;age\u0026quot;] = 23\ruser[\u0026quot;weight\u0026quot;] = 65\rprint(user)\ruser.move_to_end(\u0026quot;name\u0026quot;) # 将元素移动至末尾\rprint(user)\ruser.move_to_end(\u0026quot;name\u0026quot;, last = False) # 将元素移动至开头print(user)# 输出如下\rOrderedDict([('name', 'admin'), ('age', 23), ('weight', 65)])\rOrderedDict([('age', 23), ('weight', 65), ('name', 'admin')])\rOrderedDict([('name', 'admin'), ('age', 23), ('weight', 65)])\r defaultdict defaultdict 是内置 dict 类的子类。它实现了当 key 不存在是返回默认值的功能，除此之外，与内置 dict 功能完全一样。\nfrom collections import defaultdict\rdefault_dict = defaultdict(int)\rdefault_dict[\u0026quot;x\u0026quot;] = 10\rprint(default_dict[\u0026quot;x\u0026quot;])\rprint(default_dict[\u0026quot;y\u0026quot;])\r# 输出如下\r10\r0\r 注意，defaultdict 的参数必须是可操作的。比如 python 内置类型，或者无参的可调用的函数.\ndef getUserInfo():\rreturn {\r\u0026quot;name\u0026quot; : \u0026quot;\u0026quot;,\r\u0026quot;age\u0026quot; : 0 }\rdefault_dict = defaultdict(getUserInfo)\radmin = default_dict[\u0026quot;admin\u0026quot;]\rprint(admin)\radmin[\u0026quot;age\u0026quot;] = 34\rprint(admin)\r# 输出如下\r{'name': '', 'age': 0}\r{'name': '', 'age': 34}\r 上述示例我们给 defaultdict 传了一个自定义函数，当字典中不存在所取 key 时返回默认的用户信息。\n另⼀种重要的是例⼦就是：当你在⼀个字典中对⼀个键进⾏嵌套赋值时，如果这个键不存 在，会触发keyError异常。 defaultdict允许我们⽤⼀个聪明的⽅式绕过这个问题。 ⾸先我分享⼀个使⽤dict触发KeyError的例⼦，然后提供⼀个使⽤defaultdict的解解决方案。\n问题：\nsome_dict = {}\rsome_dict['colours']['favourite'] = \u0026quot;yellow\u0026quot;\r 异常输出：KeyError: \u0026lsquo;colours\u0026rsquo; 解决方案：\nimport collections\rtree = lambda: collections.defaultdict(tree)\rsome_dict = tree()\rsome_dict['colours']['favourite'] = \u0026quot;yellow\u0026quot;\r 运⾏正常 你可以⽤json.dumps打印出some_dict，例如：\nimport json\rprint(json.dumps(some_dict))\r 输出: {\u0026ldquo;colours\u0026rdquo;: {\u0026ldquo;favourite\u0026rdquo;: \u0026ldquo;yellow\u0026rdquo;}}\n参考：\n[1]https://docs.python.org/zh-cn/3/library/collections.html\n[2]《Python进阶》\n","id":3,"section":"posts","summary":"常用功能 namedtuple 把元组变成一个针对简单任务的容器。你不需要使用整数索引来访问一个namedtuples的数据。你可以像字典(dict)⼀样访问na","tags":["Python标准库"],"title":"Python collection","uri":"https://xuzhihao.top/2020/05/python-collection/","year":"2020"},{"content":"pip install qrcode/myqr/zxing\r 背景知识 二维码整体划分为功能图形和编码区两大部分。功能图形又细分为：空白区、位置探测图形、位置探测图形分隔符、定位图形、校正图形，而编码区细分为：格式信息、版本信息、数据和纠错码字。\n 空白区：留白，不需要做任何处理 位置探测图形：协助扫描软件定位二维码 位置探测图形分隔符：区分功能图形和编码区 定位图形：指示标识密度和确定坐标系 校正图形：校正图形的数量换位置 格式信息：准方格式化数据的信息 版本信息：二维码的规格，二维码符号共有40钟规格的矩阵 数据和纠错码字：实际保存的二维码信息和纠错码（用于修正二维码损坏带来的错误）  创建二维码 使用qrcode和myqr。\nqrcode 扫描之后跳转到某个地址。\nimport qrcode\r#二维码内容（链接地址或文字）\rdata = \u0026quot;https://www.baidu.com/\u0026quot;\r#生成二维码\rimg = qrcode.make(data=data)\r#显示二维码\rimg.show()\r#保存二维码\rimg.save('qr.jpg')\r import qrcode\r'''version：二维码的格子矩阵大小，可以是 1 到 40，1 最小为 21*21，40 是 177*177\rerror_correction：二维码错误容许率，默认 ERROR_CORRECT_M，容许小于 15% 的错误率\rbox_size：二维码每个小格子包含的像素数量\rborder：二维码到图片边框的小格子数，默认值为 4'''\rqr = qrcode.QRCode( version=2, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=15, border=3,)\r# 二维码内容\rdata = 'https://www.baidu.com/'\rqr.add_data(data=data)\r# 启用二维码颜色设置\rqr.make(fit=True)\rimg = qr.make_image(fill_color='blue', back_color='white')# 显示二维码\rimg.show()\r myqr qrcode只能生成普通二维码，myqr除了可以生成普通二维码，还可以生成带图片的二维码以及动态二维码，但我们想要查看生成的二维码时，需要到保存位置手动打开查看。\n普通二维码 from MyQR import myqr\r\u0026quot;\u0026quot;\u0026quot;\rwords：内容\rversion：容错率\rsave_name:保存名字\r\u0026quot;\u0026quot;\u0026quot;\rmyqr.run(words=\u0026quot;https://baidu.com\u0026quot;,version=1,save_name='myqr.png')\r 带图二维码 from MyQR import myqr\r'''\rpicture：生成二维码用到的图片\rcolorized：False 为黑白，True 为彩色\r'''\rmyqr.run(words='https://www.baidu.com/', version=1, picture='bg.jpg', colorized=True, save_name='pmyqr.png')\r 动态二维码 from MyQR import myqr\rmyqr.run(words='https://www.baidu.com/',\rversion=1, picture='my.gif',\rcolorized=True,\rsave_name='myqr.gif')\r 解析二维码 使用zxing\nimport zxing\rreader = zxing.BarCodeReader()\rbarcode = reader.decode('myqr.gif')\rprint(barcode.parsed)\r ","id":4,"section":"posts","summary":"pip install qrcode/myqr/zxing 背景知识 二维码整体划分为功能图形和编码区两大部分。功能图形又细分为：空白区、位置探测图形、位置探测图形分隔符、定位图形、校正图形，而编","tags":["办公自动化"],"title":"生成二维码","uri":"https://xuzhihao.top/2020/05/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/","year":"2020"},{"content":"我感觉印象笔记就是一个不错的笔记软件\n概念和原理 要用好 印象笔记 的 API 需要了解一些概念和原理。\n概念  NoteStore：NoteStore 是印象笔记的主模块，通过 NoteStore 实例可以访问所有的 API 操作 guid：印象笔记中各个对象的唯一标识，如标识具体的 笔记本、标签、笔记等，要操作某个实体，需要先获取到它的 guid 数据结构：印象笔记中将除了 NoteStore 以外的模块或类都叫数据结构，通过 evernote.edam.type.ttypes 和 evernote.edam.notestore.ttypes 两个模块来定义，在接口中提到的  原理   为了提高传输效率，将数据分为属性部分和内容部分，例如在获取列表类的操作中，得到的是对象的属性集合，如果要获取内容，通过 guid 调用单独的接口\n  接口中，除了 guid 和 token 外，其他参数都是通过相应对象实体传递的，例如查询笔记接口 findNotes，具体条件通过 NoteFilter 结构传递\n  申请开发者 token 印象笔记提供两种授权模式沙箱模式，\n 支持 OAuth 验证，可以为多个用户提供基于 印象笔记 的服务 普通模式，仅支持自己的账号，可以用 API 来操作自己的资源  我采用普通模式，一是申请方便，二是只用来处理自己笔记\n请求普通开发模式的地址是：https://app.yinxiang.com/api/DeveloperToken.action\n填写自己的登录信息（印象笔记的用户名，密码），进入获取 开发者 token 的页面，点击创建 token 按钮，创建 token，复制并像保存账号密码一样妥善保存 token。\n如果泄露或者丢失，还来这里重置。token 有效期为一周，过期需要重新申请。\n安装SDK 印象笔记提供了多种语言的 SDK，我们选用 Python3 版的，地址是：https://github.com/evernote/evernote-sdk-python3\n下载源码后，解压，在解压文件夹下执行:\npython setup.py install\r 一切正常的话，执行下面语句，不会报错：\npython -c 'from evernote.api.client import EvernoteClient\r 注意：通过 pip install evernote 也能安装，不过是 Python2.x 版的\nAPI测试 from evernote.api.client import EvernoteClient\rauth_token = \u0026quot;S=s1:U\u0026lt;...\u0026gt;5369\u0026quot; # 开发 token\rclient = EvernoteClient(token=auth_token, sandbox=False,china=True)\rnote_store = client.get_note_store()\r  引入 印象笔记 客户端模块 注意：用 EvernoteClient 创建客户端实体，因为是普通开发模式，sandbox 和 china 参数设置为 False 和 True, 与沙箱模式相反 通过客户端实体，获得 note_store，如果能成功执行，说明一切顺利  实现 SDK 中提供了很多方法，不过使用并不方便，所以创建了一个代理类 EverNote，将需要用的操作包装成习惯用的，创建类的好处还有，不必将 token 和 evernote 终端实体到处传。\nEverNote定义 class EverNote(): def __init__(self, auth_token): self.auth_token = auth_token self.client = EvernoteClient(token=auth_token, sandbox=False,china=True) self.note_store = self.client.get_note_store()\rself.template = '\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;' self.template +='\u0026lt;!DOCTYPE en-note SYSTEM \u0026quot;http://xml.evernote.com/pub/enml2.dtd\u0026quot;\u0026gt;' self.template +='\u0026lt;en-note\u0026gt;%s\u0026lt;/en-note\u0026gt;'\r  构造方法接受一个参数 auth_toke nauth_token 被设置为内部变量，为了反复使用 创建 evernote 终端实例， client，由于是普通模式，设置 sandbox 为 False, china 为 True 通过 终端实例 client 获得 NoteStore 实例，后续操作都基于这个实例 template 是 evernote 笔记的 xml 框架，笔记内容放在 en-note 标记之间  工具方法 API: https://dev.yinxiang.com/doc/reference\nSDK: https://github.com/evernote/evernote-sdk-python3\nhttps://dev.evernote.com/doc/start/python.php\nhttps://stackoverflow.com/questions/41710896/getuser-return-edamsystemexception-errorcode-8\nhttps://www.jianshu.com/p/bda26798f3b3\n","id":5,"section":"posts","summary":"我感觉印象笔记就是一个不错的笔记软件 概念和原理 要用好 印象笔记 的 API 需要了解一些概念和原理。 概念 NoteStore：NoteStore 是印象笔记","tags":["办公自动化"],"title":"印象笔记API介绍","uri":"https://xuzhihao.top/2020/05/%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0api%E4%BB%8B%E7%BB%8D/","year":"2020"},{"content":"布谷鸟算法，英文叫做Cuckoo search(CS algorithm)。它是为了寻找最小值而产生的一种算法。\n举一个例子： $$ y=(x-0.5)^2+1 $$ 我们有4个布谷鸟蛋（也就是4个x坐标），鸟妈妈发现不是自己的宝宝的概率是0.25，我们x的取值范围是[0,1]之间，前提有了咱们来运算吧。\n目标：求x在[0,1]之内的函数y=(x-0.5)^2+1d的最小值。\n  初始化x的位置。随机生成4个x的坐标，x1=0.4,x2=0.6,x3=0.8,x4=0.3,即x=[0.4,0.6,0.8,0.3]\n  求出y1~y4的值。把x1~x4带入函数就可以得到y=[1,31,1.46,1.69,1.265]，并取当前最小值ymin=y4=1.265\n  开始定出一个y的最大值为Y_global=INF(无穷大),然后与ymin比较，把Y中最小的位置和值保留，令Y_global=1.265\n  记录Y_global的位置，(0.3,1.265)\n  按概率0.25,随机地把X中的值过筛子，选储备发现的蛋。例如第二个蛋被发现，即x2=0.6被发现，那么他就要变换位置，生成一个随机数，例如0.02。这样更新X与Y，X=[0.4,0.62,0.8,0.3],Y=[1.31,1.4794,1.69,1.265]\n  进行莱维飞行。也就是把x的位置随机变换。\n按照公式: $$ x=x+alpha×L $$\n$$ L=S×(X-Y_global)×Rand3 $$\n$$ S=[Rand1\\frac{sigma}{Rand2}]^\\frac{1}{beta} $$\n$$ sigma=0.6966 $$\n$$ beta=1.5 $$\n$$ alpha=0.01 $$\n$$ Rand1~Rand3为正态分布的随机数 $$\n首先随机生成Rand1=-1.2371，rand2=-2.1935，rand3=-0.3209，接下来将X带入公式中，获得\nx1=0.3985\nx2=0.6172\nx3=0.7889\nx4=0.3030\n  更新矩阵X，X=[0.3985, 0.6172, 0.7889, 0.3030]\n  计算Y=[1.3092, 1.4766, 1.6751, 1.2661]，并选取当前最小值ymin= y4=1.2661，然后与ymin比较，把Y中最小的位置和值保留，例如Y_global=1.265\u0026lt;ymin=1.2661，所以令Y_global=1.265\n  返回步骤5 用更新的X去循环执行。警告牌单纯计算即可获得y的最小值和最佳位置(x,y)\n  用Python代码实现：\n 首先，数据初始化  self.nests = [random.uniform(x_min, x_max,1) for i in range(n)]\rself.fit_val = self.fit_fun(self.nests)\rself.best_fit = min(self.fit_val)\rself.best_index = list(self.fit_val).index(self.best_fit)\rself.best_nest = self.nests[self.best_index]\r  适应函数：  def fit_fun(self,xs):\rys = [(x-0.5)**2+1 for x in xs]\rreturn ys\r  莱维飞行  def levyFlight(self,val_min, val_max, location, beta=1.5, alpha=0.01):\r\u0026quot;\u0026quot;\u0026quot;\rArgs:\rval_min: 输入值的最大值\rval_max: 输入值的最小值\rlocation: 位置\rcount: 飞行次数\rbeta: 公式中的β\ralpha: 公式中的α\rReturns:如果count==1，则返回飞行后的位置\r否则返回包括初始位置在内的所有位置\r\u0026quot;\u0026quot;\u0026quot;\rx = location# 初始化位置\r# 公式中u和v的sigma\r# sigma_u = 0.6965745025576967 (beta=1.5)\rsigma_u = power(gamma(1 + beta) * sin(pi*beta / 2) / (gamma((1 + beta) / 2) * beta * power(2, (beta - 1) / 2)),1 / beta)\rsigma_v = 1\r# 获得一对x的u和v\ru_x = random.normal(0, sigma_u)\rv_x = random.normal(0, sigma_v)\rx_new = dot(alpha, u_x / power(abs(v_x), 1 / beta))\rwhile (x_new \u0026lt; val_min) or (x_new \u0026gt; val_max):\r# 不在范围内就重新生成\ru_x = random.normal(0, sigma_u)\rv_x = random.normal(0, sigma_v)\rx_new = dot(alpha, u_x / power(abs(v_x), 1 / beta))\r#x.append(x[-1] + x_new) # 更新x\r#print(\u0026quot;now\u0026quot;,location + x)\rreturn (location + x)\r  运行代码  for num in range(self.iters):\r# 以pa的概率丢弃旧的解，由Levy飞行产生新解\rprobs = random.random(self.n)\rfor i in range(self.n):\rif probs[i] \u0026lt; self.pa:\rself.nests[i] = self.levyFlight(self.x_min, self.x_max, location=self.nests[i])\r# 在新解集中找到最优解\rself.fit_val = self.fit_fun(self.nests)\rnew_best_fit = min(self.fit_val)\rif new_best_fit \u0026lt; self.best_fit:\rself.best_fit = new_best_fit\rself.best_index = list(self.fit_val).index(new_best_fit)\rself.best_nest = self.nests[list(self.fit_val).index(new_best_fit)]\r 汇总：\nfrom numpy import random, sin, power, pi, dot\rfrom math import gamma\rimport matplotlib.pyplot as plt\rclass CS(object):\rdef __init__(self, x_min, x_max, iters=20, n=12, pa=0.25):\r\u0026quot;\u0026quot;\u0026quot;\rx_min, x_max：x取值范围\riters：迭代次数（遗传代数）\rdim：输入数据维度\rn：鸟巢个数\rpa：布谷鸟蛋被发现概率\r\u0026quot;\u0026quot;\u0026quot;\rself.x_min = x_min\rself.x_max = x_max\rself.iters = iters\rself.n = n\rself.pa = pa\r# 初始化n个解\rself.nests = [random.uniform(x_min, x_max,1) for i in range(n)]\rprint(\u0026quot;初始化鸟巢：\u0026quot;,self.nests)\r# 计算适应度\rself.fit_val = self.fit_fun(self.nests)\r# print(\u0026quot;初始适应度：\u0026quot;,self.fit_val)\r# 适应度最优值与位置\rself.best_fit = min(self.fit_val)\r#print(\u0026quot;初始化最优解:\u0026quot;,self.best_fit)\rself.best_index = list(self.fit_val).index(self.best_fit)#最优值 所在索引\rself.best_nest = self.nests[self.best_index]\r#print(\u0026quot;初始化最优解位置：\u0026quot;,self.best_nest)\rdef fit_fun(self,xs):\rys = [(x-0.5)**2+1 for x in xs]\r#print(ys)\rreturn ys\rdef levyFlight(self,val_min, val_max, location, beta=1.5, alpha=0.01):\r\u0026quot;\u0026quot;\u0026quot;\rArgs:\rval_min: 输入值的最大值\rval_max: 输入值的最小值\rlocation: 位置\rcount: 飞行次数\rbeta: 公式中的β\ralpha: 公式中的α\rReturns:如果count==1，则返回飞行后的位置\r否则返回包括初始位置在内的所有位置\r\u0026quot;\u0026quot;\u0026quot;\rx = location# 初始化位置\r# 公式中u和v的sigma\r# sigma_u = 0.6965745025576967 (beta=1.5)\rsigma_u = power(gamma(1 + beta) * sin(pi*beta / 2) / (gamma((1 + beta) / 2) * beta * power(2, (beta - 1) / 2)),1 / beta)\rsigma_v = 1\r# 获得一对x的u和v\ru_x = random.normal(0, sigma_u)\rv_x = random.normal(0, sigma_v)\rx_new = dot(alpha, u_x / power(abs(v_x), 1 / beta))\rwhile (x_new \u0026lt; val_min) or (x_new \u0026gt; val_max):\r# 不在范围内就重新生成\ru_x = random.normal(0, sigma_u)\rv_x = random.normal(0, sigma_v)\rx_new = dot(alpha, u_x / power(abs(v_x), 1 / beta))\r#x.append(x[-1] + x_new) # 更新x\r#print(\u0026quot;now\u0026quot;,location + x)\rreturn (location + x)\rdef run(self):\rfor num in range(self.iters):\r# 上一代鸟巢经过Levy飞行后的解(除去当前最优位置)\r#print(\u0026quot;鸟巢：\u0026quot;,self.nests)\r# 以pa的概率丢弃旧的解，由Levy飞行产生新解\rprobs = random.random(self.n)\rfor i in range(self.n):\rif probs[i] \u0026lt; self.pa:\rself.nests[i] = self.levyFlight(self.x_min, self.x_max, location=self.nests[i])\r# 在新解集中找到最优解\rself.fit_val = self.fit_fun(self.nests)\rnew_best_fit = min(self.fit_val)\rif new_best_fit \u0026lt; self.best_fit:\rself.best_fit = new_best_fit\rself.best_index = list(self.fit_val).index(new_best_fit)\rself.best_nest = self.nests[list(self.fit_val).index(new_best_fit)]\r# print(self.best_fit)\rplt.ylim([0.90, 1.1])\rplt.plot(num,self.best_fit,\u0026quot;ro\u0026quot;)\rplt.show()\rcs = CS(x_min=-5, x_max=5)\rcs.run()\rprint(cs.best_nest)\rprint(cs.best_fit)\r ","id":6,"section":"posts","summary":"布谷鸟算法，英文叫做Cuckoo search(CS algorithm)。它是为了寻找最小值而产生的一种算法。 举一个例子： $$ y=(x-0.5)^2+1 $$ 我们有4个布谷鸟蛋（也就是4个","tags":["布谷鸟算法"],"title":"Python实现布谷鸟算法","uri":"https://xuzhihao.top/2020/05/python%E5%AE%9E%E7%8E%B0%E5%B8%83%E8%B0%B7%E9%B8%9F%E7%AE%97%E6%B3%95/","year":"2020"},{"content":"在Python 3中，range返回一个惰性序列对象-它不返回列表。无法重新排列范围对象中的元素，因此无法重新排列它。\npython2.x改为python3.x时应将其转换为列表。\nlist(range(len(people)))\r ","id":7,"section":"posts","summary":"在Python 3中，range返回一个惰性序列对象-它不返回列表。无法重新排列范围对象中的元素，因此无法重新排列它。 python2.x改为p","tags":["错误记录"],"title":"TypeError: 'range' object does not support item assignment","uri":"https://xuzhihao.top/2020/05/typeerror-range-object-does-not-support-item-assignment/","year":"2020"},{"content":"定位算法大致分为基于距离的定位算法和距离无关的定位算法。\n在传感器节点定位中，已知自身位置信息的节点成为锚节点，锚节点能通过自身的定位设备获取精确的位置信息.\n自身位置不确定的节点成为未知节点,未知节点需要通过一定的通信方式获取锚节点的信息，并以锚节点的信息作为参考，根据某种算法或定位机制估算出自身的位置信息。\n一般的，当未知节点获取了 3 个或 3 个以上的锚节 点的信息时，便可以利用到锚节点的距离信息估算自身 的位置。为了进一步提高定位精度，未知节点在估算其 位置时，一般通过引入更多的锚节点信息来减少个别测 距误差对定位结果的影响。因此，使用最小二乘原理估 算未知节点的位置。\n","id":8,"section":"posts","summary":"定位算法大致分为基于距离的定位算法和距离无关的定位算法。 在传感器节点定位中，已知自身位置信息的节点成为锚节点，锚节点能通过自身的定位设备获取","tags":["布谷鸟算法"],"title":"基于布谷鸟搜索算法的无线传感器网络节点定位","uri":"https://xuzhihao.top/2020/05/%E5%9F%BA%E4%BA%8E%E5%B8%83%E8%B0%B7%E9%B8%9F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C%E8%8A%82%E7%82%B9%E5%AE%9A%E4%BD%8D/","year":"2020"},{"content":"PyQt5 中的QtableWidget项排序 项排序是指针对表格部件中的数据行进行排序，调用语法如下： sortItems(column,Qt.AscendingOrder) 排序依据参数column指定列进行。Qt.SortOrder为枚举类，有两个常量值，分别为：AscendingOrder升序，对应数值为0，DescendingOrder为降序，对应数值为1。\n注意column必须为整数\n","id":9,"section":"posts","summary":"PyQt5 中的QtableWidget项排序 项排序是指针对表格部件中的数据行进行排序，调用语法如下： sortItems(column,Qt.AscendingOrder) 排序依据参数column指定列进行。Qt.So","tags":["PyQt5"],"title":"QtableWidget中单元格排序","uri":"https://xuzhihao.top/2020/05/qtablewidget%E4%B8%AD%E5%8D%95%E5%85%83%E6%A0%BC%E6%8E%92%E5%BA%8F/","year":"2020"},{"content":"从原理上说可以使用张量构建计算图来定义神经网络，并通过自动微分机制训练模型。\n但为简洁，我们大多使用TensorFlow的高层次keras接口来实现神经网络网模型。\n使用TensorFlow实现神经网络模型的一般流程包括：\n 准备数据 定义模型 训练模型 评估模型 使用模型 保存模型  refer:https://lyhue1991.github.io/eat_tensorflow2_in_30_days/%E4%B8%80%E3%80%81TensorFlow%E7%9A%84%E5%BB%BA%E6%A8%A1%E6%B5%81%E7%A8%8B.html\n","id":10,"section":"posts","summary":"从原理上说可以使用张量构建计算图来定义神经网络，并通过自动微分机制训练模型。 但为简洁，我们大多使用TensorFlow的高层次keras接口","tags":["TensorFlow"],"title":"TensorFlow的建模流程","uri":"https://xuzhihao.top/2020/05/tensorflow%E7%9A%84%E5%BB%BA%E6%A8%A1%E6%B5%81%E7%A8%8B/","year":"2020"},{"content":"简介 pickle使用二进制协议，用于对Python对象结构进行序列化和反序列化\n“Pickling”是将Python对象层次结构转化为字节流的过程，“unpickling”是逆运算，将字节流转换回对象层次结构的过程\n 注意：pickle仅用于释放你信任的数据，陌生数据可能是构造的恶意数据，这些数据将在解码过程中执行任意代码。\n如果处理不安全数据，json模块更加适合\n 模块接口 序列化Python对象，使用dumps()函数。反序列化数据，要调用loads()函数。\n但是，要更多的控制序列化和反序列化，则应该创建一个Pickler或一个Unpickler对象。\npickle.dump(obj,file,protocol=None,*,fix_import=True,buffer_callback=None) 将Python对象写入文件中，这等效为Pickler(file,protocol).dump(obj)\npickle.dumps(obj,protocol=None,*,fix_imports=True,buffer_callback=None) 将Python对象 表示为pickled后的作为字节的对象，这并不是写入文件中。\npickle.load(file,*,fix_imports=True.encoding=\u0026quot;ASCII\u0026rdquo;,errors=\u0026quot;strict\u0026rdquo;,buffers=None) 从一个open的文件对象中读取已经被腌制的Python对象，返回原有的Python结构。它等效于Unpickler(file).load()\npickle.loads(data,*,fix_imports=True,encoding=\u0026quot;ASCII\u0026rdquo;,errors=\u0026quot;strict\u0026rdquo;,buffers=None) 返回对象的腌制表示数据的重构对象层次结构 。注意data必须是bytes-like object.\n异常 pickle.PickleError 是pickle的通用基类，它继承了PickleError\npickle.PicklingError 当遇到无法拾取的对象时引发的错误\npickle.UnpicklingError 解开对象时出现问题，例如数据损坏或安全冲突，将引发错误\n例子 写入与读取 import pickle\rdata = {\r'a': [1, 2.0, 3, 4+6j],\r'b': (\u0026quot;character string\u0026quot;, b\u0026quot;byte string\u0026quot;),\r'c': {None, True, False}\r}\rwith open('data.pickle','wb') as f:\rpickle.dump(data,f,pickle.HIGHEST_PROTOCOL)\r import pickle\rwith open('data.pickle','rb') as f:\rdata = pickle.load(f)\r 修改 import pickle\ra={}\rwith open(\u0026quot;temp.io\u0026quot;,\u0026quot;rb\u0026quot;) as f:\ra=pickle.load(f)\rwith open(\u0026quot;temp.io\u0026quot;,\u0026quot;wb\u0026quot;) as f:\ra['test'] = 10\rpickle.dump(a,f)\r ","id":11,"section":"posts","summary":"简介 pickle使用二进制协议，用于对Python对象结构进行序列化和反序列化 “Pickling”是将Python对象层次结构转化为字节流的","tags":["Python标准库"],"title":"Python持久化处理——pickle","uri":"https://xuzhihao.top/2020/05/python%E6%8C%81%E4%B9%85%E5%8C%96%E5%A4%84%E7%90%86pickle/","year":"2020"},{"content":"用Flask可以快速开发，大小网站都可以通过Flask搭建，扩展性也很好。比如有Bootstrap-Flask这样的插件。\n先来一个极其简单的展示，作为Flask开发的入口。\n# coding=utf-8\rfrom flask import Flask\rapp = Flask(__name__)\r@app.route('/')\rdef hello_world():\rreturn 'Hello World'\rif __name__ == '__main__':\rapp.run(host='0.0.0.0',port=9000)\r   第1行，“# coding=utf-8”是声明Python源文件编码的语法。该编码信息后续会被Python解析器用于解析源文件。\n  第2行，引入Flask类，Flask类实现了一个WSGI应用。\n  第4行，app是Flask的实例，它接收包或者模块的名字作为参数，但一般都是传递__name__。让flask.helpers.get_root_path函数通过传入这个名字确定程序的根目录，以便获得静态文件和模板文件的目录。\n  第7~9行，使用app.route装饰器会将URL和执行的视图函数的关系保存到app.url_map属性上。处理URL和视图函数的关系的程序就是路由，这里的视图函数就是hello_world。\n  第12行，使用这个判断可以保证当其他文件引用这个文件的时候（例如“from hello import app”）不会执行这个判断内的代码，也就是不会执行app.run函数。\n  第13行，执行app.run就可以启动服务了。默认Flask只监听虚拟机的本地127.0.0.1这个地址，端口为5000。而我们对虚拟机做的端口转发端口是9000，所以需要指定host和port参数，0.0.0.0表示监听所有地址，这样就可以在本机访问了。服务器启动后，会调用werkzeug.serving.run_simple进入轮询，默认使用单进程单线程的werkzeug.serving.BaseWSGIServer处理请求，实际上还是使用标准库Base-HTTPServer.HTTPServer，通过select.select做0.5秒的“while True”的事件轮询。当我们访问“http://127.0.0.1:9000/”，通过app.url_map找到注册的“/”这个URL模式，就找到了对应的hello_world函数执行，返回“Hello World!”，状态码为200。如果访问一个不存在的路径，如访问“http://127.0.0.1:9000/a”，Flask找不到对应的模式，就会向浏览器返回“Not Found”，状态码为404。\n  这里需要说明的是，默认的app.run的启动方式只适合调试，不要在生产环境中使用，生产环境应该使用Gunicorn或者uWSGI\n","id":12,"section":"posts","summary":"用Flask可以快速开发，大小网站都可以通过Flask搭建，扩展性也很好。比如有Bootstrap-Flask这样的插件。 先来一个极其简单的","tags":["Python Web"],"title":"Flask入口","uri":"https://xuzhihao.top/2020/05/flask%E5%85%A5%E5%8F%A3/","year":"2020"},{"content":"首先 pip install lxml\rpip install docx-mailmerge\r 处理Word文档 为了让docx-mailmerge能够正常工作，你需要在word中定义一个MergeField,这个在字段中的域 可以设置。\n比如，将MergeField定义为Name，你在文档中 将会看到\u0026laquo;Name\u0026raquo;。\n填充Word文档 from mailmerge import MailMerge\rfrom datetime import date\rtemplate = \u0026quot;text.docx\u0026quot;\r#创建一个mailmerge文档\rdocument = MailMerge(teplate)\r#查看Word中可以填充的区域\rprint(document.get_merge_fields())\rdocument.merge(\rName = 'Gold',\rcity = 'sh',\rzip = '555'\r)\rdocument.write('test-output.docx')\r 使用merge_pages 如果你要在一个word文档中，生成多个页面，你或许就会用到这个方法。它通过获取键、值对的字典流标，在单个文件中创建多个页面。\ncust_1={\r'status': 'Gold',\r'city': 'Springfield',\r'phone_number': '800-555-5555'\r}\rcust_2 = {\r'status': 'Silver',\r'city': 'Columbus',\r'phone_number': '800-555-5551'\r}\rdocument.merge_pages([cust_1, cust_2])\rdocument.write('test-output-mult-custs.docx')\r 这将生成两个页面。\n填充表格 当我们不知道要填充多少行时，使用merge_rows也许会更好。\n首先，咱们需要创建一个1行的标准word表格，并将字段插入到适当地列中。不需要特别格式，它可以看起来像这样。\n\ndata = [{ 'name' : '1' ，\r'tel' : '1235' ，\r'year' : '18' ，\r'place' : 'z' 'H':'No'\r}， { 'name' : '2' ，\r'tel' : '1235' ，\r'year' : '18' ，\r'place' : 'z' 'H':'No'\r}， { 'name' : '3' ，\r'tel' : '1235' ，\r'year' : '18' ，\r'place' : 'z' 'H':'No'\r}]\rdocument.merge(**cust_2)\rdocust.merge_rows('name',data)\rdocument.write('test-output-table.docx')\r 完整代码 from __future__ import print_function\rfrom mailmerge import MailMerge\rfrom datetime import date\r# Define the templates - assumes they are in the same directory as the code\rtemplate_1 = \u0026quot;Practical-Business-Python.docx\u0026quot;\rtemplate_2 = \u0026quot;Practical-Business-Python-History.docx\u0026quot;\r# Show a simple example\rdocument_1 = MailMerge(template_1)\rprint(\u0026quot;Fields included in {}: {}\u0026quot;.format(template_1,\rdocument_1.get_merge_fields()))\r# Merge in the values\rdocument_1.merge(\rstatus='Gold',\rcity='Springfield',\rphone_number='800-555-5555',\rBusiness='Cool Shoes',\rzip='55555',\rpurchases='$500,000',\rshipping_limit='$500',\rstate='MO',\raddress='1234 Main Street',\rdate='{:%d-%b-%Y}'.format(date.today()),\rdiscount='5%',\rrecipient='Mr. Jones')\r# Save the document as example 1\rdocument_1.write('example1.docx')\r# Try example number two where we create multiple pages\r# Define a dictionary for 3 customers\rcust_1 = {\r'status': 'Gold',\r'city': 'Springfield',\r'phone_number': '800-555-5555',\r'Business': 'Cool Shoes',\r'zip': '55555',\r'purchases': '$500,000',\r'shipping_limit': '$500',\r'state': 'MO',\r'address': '1234 Main Street',\r'date': '{:%d-%b-%Y}'.format(date.today()),\r'discount': '5%',\r'recipient': 'Mr. Jones'\r}\rcust_2 = {\r'status': 'Silver',\r'city': 'Columbus',\r'phone_number': '800-555-5551',\r'Business': 'Fancy Pants',\r'zip': '55551',\r'purchases': '$250,000',\r'shipping_limit': '$2000',\r'state': 'OH',\r'address': '1234 Elm St',\r'date': '{:%d-%b-%Y}'.format(date.today()),\r'discount': '2%',\r'recipient': 'Mrs. Smith'\r}\rcust_3 = {\r'status': 'Bronze',\r'city': 'Franklin',\r'phone_number': '800-555-5511',\r'Business': 'Tango Tops',\r'zip': '55511',\r'purchases': '$100,000',\r'shipping_limit': '$2500',\r'state': 'KY',\r'address': '1234 Adams St',\r'date': '{:%d-%b-%Y}'.format(date.today()),\r'discount': '2%',\r'recipient': 'Mr. Lincoln'\r}\rdocument_2 = MailMerge(template_1)\rdocument_2.merge_pages([cust_1, cust_2, cust_3])\rdocument_2.write('example2.docx')\r# Final Example includes a table with the sales history\rsales_history = [{\r'prod_desc': 'Red Shoes',\r'price': '$10.00',\r'quantity': '2500',\r'total_purchases': '$25,000.00'\r}, {\r'prod_desc': 'Green Shirt',\r'price': '$20.00',\r'quantity': '10000',\r'total_purchases': '$200,000.00'\r}, {\r'prod_desc': 'Purple belt',\r'price': '$5.00',\r'quantity': '5000',\r'total_purchases': '$25,000.00'\r}]\rdocument_3 = MailMerge(template_2)\rdocument_3.merge(**cust_2)\rdocument_3.merge_rows('prod_desc', sales_history)\rdocument_3.write('example3.docx')\r ","id":13,"section":"posts","summary":"首先 pip install lxml pip install docx-mailmerge 处理Word文档 为了让docx-mailmerge能够正常工作，你需要在word中定义一个MergeField,这个在字段中","tags":["办公自动化"],"title":"自动填充Word文档","uri":"https://xuzhihao.top/2020/05/%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85word%E6%96%87%E6%A1%A3/","year":"2020"},{"content":"import sys\r# 从PyQt库导入QtWidget通用窗口类,基本的窗口集在PyQt5.QtWidgets模块里.\rfrom PyQt5.QtWidgets import QApplication, QWidget, QSystemTrayIcon, QAction, QMenu, qApp, QMessageBox\rfrom PyQt5.QtGui import QIcon\rfrom PyQt5.QtCore import QCoreApplication\rif __name__ == '__main__':\r# pyqt窗口必须在QApplication方法中使用 # 每一个PyQt5应用都必须创建一个应用对象.sys.argv参数是来自命令行的参数列表.Python脚本可以从shell里运行.这是我们如何控制我们的脚本运行的一种方法.\rapp = QApplication(sys.argv)\r# 关闭所有窗口,也不关闭应用程序\rQApplication.setQuitOnLastWindowClosed(False)\rfrom PyQt5 import QtWidgets\r# QWidget窗口是PyQt5中所有用户界口对象的基本类.我们使用了QWidget默认的构造器.默认的构造器没有父类.一个没有父类的窗口被称为一个window.\rw = QWidget()\r# resize()方法调整了窗口的大小.被调整为250像素宽和250像素高.\rw.resize(250, 250)\r# move()方法移动了窗口到屏幕坐标x=300, y=300的位置.\rw.move(300, 300)\r# 在这里我们设置了窗口的标题.标题会被显示在标题栏上.\rw.setWindowTitle('Simple')\r# show()方法将窗口显示在屏幕上.一个窗口是先在内存中被创建,然后显示在屏幕上的.\rw.show()\r# from PyQt5.QtWidgets import QSystemTrayIcon\r# from PyQt5.QtGui import QIcon\r# 在系统托盘处显示图标\rtp = QSystemTrayIcon(w)\rtp.setIcon(QIcon(r'F:\\Pomodoro\\materials\\lemon.ico'))\r# 设置系统托盘图标的菜单\ra1 = QAction('\u0026amp;显示(Show)', triggered=w.show)\rdef quitApp():\rw.show() # w.hide() #隐藏\rre = QMessageBox.question(w, \u0026quot;提示\u0026quot;, \u0026quot;退出系统\u0026quot;, QMessageBox.Yes |\rQMessageBox.No, QMessageBox.No)\rif re == QMessageBox.Yes:\r# 关闭窗体程序\rQCoreApplication.instance().quit()\r# 在应用程序全部关闭后，TrayIcon其实还不会自动消失，\r# 直到你的鼠标移动到上面去后，才会消失，\r# 这是个问题，（如同你terminate一些带TrayIcon的应用程序时出现的状况），\r# 这种问题的解决我是通过在程序退出前将其setVisible(False)来完成的。 tp.setVisible(False)\ra2 = QAction('\u0026amp;退出(Exit)', triggered=quitApp) # 直接退出可以用qApp.quit\rtpMenu = QMenu()\rtpMenu.addAction(a1)\rtpMenu.addAction(a2)\rtp.setContextMenu(tpMenu)\r# 不调用show不会显示系统托盘\rtp.show()\r# 信息提示\r# 参数1：标题\r# 参数2：内容\r# 参数3：图标（0没有图标 1信息图标 2警告图标 3错误图标），0还是有一个小图标\rtp.showMessage('tp', 'tpContent', icon=0)\rdef message():\rprint(\u0026quot;弹出的信息被点击了\u0026quot;)\rtp.messageClicked.connect(message)\rdef act(reason):\r# 鼠标点击icon传递的信号会带有一个整形的值，1是表示单击右键，2是双击，3是单击左键，4是用鼠标中键点击\rif reason == 2 or reason == 3:\rw.show()\r# print(\u0026quot;系统托盘的图标被点击了\u0026quot;)\rtp.activated.connect(act)\r# sys为了调用sys.exit(0)退出程序\r# 最后,我们进入应用的主循环.事件处理从这里开始.主循环从窗口系统接收事件,分派它们到应用窗口.如果我们调用了exit()方法或者主窗口被销毁,则主循环结束.sys.exit()方法确保一个完整的退出.环境变量会被通知应用是如何结束的.\r# exec_()方法是有一个下划线的.这是因为exec在Python中是关键字.因此,用exec_()代替.\rsys.exit(app.exec_())\r ","id":14,"section":"posts","summary":"import sys # 从PyQt库导入QtWidget通用窗口类,基本的窗口集在PyQt5.QtWidgets模块里. from PyQt5.QtWidgets import QApplication, QWidget, QSystemTrayIcon, QAction, QMenu, qApp, QMessageBox from PyQt5.QtGui import QIcon from PyQt5.QtCore import QCoreApplication if","tags":["PyQt5"],"title":"PyQt5应用最小化到托盘","uri":"https://xuzhihao.top/2020/05/pyqt5%E5%BA%94%E7%94%A8%E6%9C%80%E5%B0%8F%E5%8C%96%E5%88%B0%E6%89%98%E7%9B%98/","year":"2020"},{"content":"提升窗口控件，就是指有些窗口控件是用户自己基于PyQt定义的衍生窗口控件，这些窗口控件在Qt Designer中没有直接提供，但是可以通过提升窗口控件这个功能实现。\n从 Container导航栏中找到 QWidget并拖入主窗口中，然后 对其 单击 鼠标 右键，从弹出的快捷菜单中选择“ 提升”，打开“ 提升的窗口控件” 对话框， 如下图，按照图中所示进行输入。\n然后，点击“添加”。这就会在Qt Designer中引入DataTableWidget类。\n我们对Widget 重命名 为“ pandastablewidget”，这样就基本完成了对提升的窗口控 件的操作。核心 代码 如下：\nfrom qtpandas.views.DataTableView import DataTableWidget self.pandastablewidget = DataTableWidget( self.centralWidget) self.pandastablewidget.setGeometry( QtCore.QRect(10,30,591,331)) self.pandastablewidget.setStyleSheet(\u0026quot;\u0026quot;)\rself.pandastablewidget.setObjectName(\u0026quot; pandastablewidget\u0026quot;)  至此，我们已经实现了DataTableWidget类在Qt Designer 中的引用。提升的窗口 控件是 PyQt 中非常简单、实用而又强大的功能，利用该功能可以通过 Qt Designer 来实现 PyQt 与 Python 的一些强大的模块之间的交互功能，可以充分利用 PyQt 和 Python 两者的 优点来快速开发程序。\n","id":15,"section":"posts","summary":"提升窗口控件，就是指有些窗口控件是用户自己基于PyQt定义的衍生窗口控件，这些窗口控件在Qt Designer中没有直接提供，但是可以通过提升","tags":["PyQt5"],"title":"Qtdesigner提升窗口控件","uri":"https://xuzhihao.top/2020/05/qtdesigner%E6%8F%90%E5%8D%87%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6/","year":"2020"},{"content":"使用MatplotlibWidget 设置绘图类 class Canvas(FigureCanvas):\rdef __init__(self,parent=None,width=5,height=4,dpi=100):\rplt.rcParams['font.family'] = ['SimHei']#显示中文标签\rplt.reParams['axes.unicode_minus'] = False#显示负号\rself.fig = Figure(figsize=(eidth,height),dpi=dpi)\rself.axes = self.fig.add_subplot(111)\rself.axes.hold(False)#每次绘图不保留输一次绘图结果\rFigureCanvas.__init__(self,self.fig)\rself.setParaent(parent)\rFigureCanvas.setSizePolicy(self,QSizePolicy.Expanding,QSizePolicy.Expanding)\rFigureCanvas.updateGeometry(self)\r 定义绘制静态图函数，调用这个函数可以在上一步所创建的空白的图像中绘图。\n静态图：\ndef start_static_plot(self):\rself.fig.suptitle('静态图')\rt = arange(0.0,3.0,0.01)\rs = sin(s*pi*t)\rself.axes.plot(t,s)\rself.axes.set_ylabel('静态图：Y轴')\rself.axes.set_xlabel('静态图：X轴')\rself.axes.grid(True)\r 动态图\ndef start_dynamic_plot(self,*args,**kwargs):\rtimer = QtCore.QTimer(self)\rtimer.timeout.connect(self.update_figure)#每隔一段时间出发一次update_figure()函数\rtimer.start(1000)#触发时间间隔为1秒\rdef update_figure(self):\rself.fig.suptitle('动态图')\rl = [random.randint(0,10) for i in range(4)]\rself.axes.plot([0,1,2,3],1,'r')\rself.axes.set_ylabel('动态图：Y轴')\rself.axes.set_xlabel('动态图：x轴')\rself.axes.grid(True)\rself.draw()\r 封装绘图类 这是使用QWidget把上面的绘图类和工具栏封装到MatplotlibWidget,我们Vic顺序调用MatplotlibWidge这个类可以实现绘图功能了\nclass MatplotlibWidget(QWidget):\rdef __init__(self,parent-None):\rsuper(MatplotlibWidget,self).__init__(parent)\rself.initUi()\rdef initUi():\rself.layout = QVboxLayout(self)\rself,mpl.start_static_plot()\rself.mpl_ntb = NavigationToolbar(self,mpl,self)#添加完整工具栏\rself.layout.addWidget(self.mpl)\rself.layout.addWidget(self.mpl_ntb)\rif __name__ == \u0026quot;__main__\u0026quot;:\rapp = QApplication(sys.argv)\rui = MatplotlibWidget()\rui.mpl.start_static_plot()\rui.show()\rsys.exit(app.exec_)\r 实例：\nimport sys\rimport random\rimport matplotlib\rmatplotlib.use(\u0026quot;Qt5Agg\u0026quot;)\rfrom PyQt5 import QtCore\rfrom PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QSizePolicy, QWidget\rfrom numpy import arange, sin, pi\rfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\rfrom matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar\rfrom matplotlib.figure import Figure\rimport matplotlib.pyplot as plt\rclass MyMplCanvas(FigureCanvas):\r\u0026quot;\u0026quot;\u0026quot;FigureCanvas的最终的父类其实是QWidget。\u0026quot;\u0026quot;\u0026quot;\rdef __init__(self, parent=None, width=5, height=4, dpi=100):\r# 配置中文显示\rplt.rcParams['font.family'] = ['SimHei'] # 用来正常显示中文标签\rplt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号\rself.fig = Figure(figsize=(width, height), dpi=dpi) # 新建一个figure\rself.axes = self.fig.add_subplot(111) # 建立一个子图，如果要建立复合图，可以在这里修改\r#self.axes.hold(False) # 每次绘图的时候不保留上一次绘图的结果\rFigureCanvas.__init__(self, self.fig)\rself.setParent(parent)\r'''定义FigureCanvas的尺寸策略，这部分的意思是设置FigureCanvas，使之尽可能的向外填充空间。'''\rFigureCanvas.setSizePolicy(self,\rQSizePolicy.Expanding,\rQSizePolicy.Expanding)\rFigureCanvas.updateGeometry(self)\r'''绘制静态图，可以在这里定义自己的绘图逻辑'''\rdef start_static_plot(self):\rself.fig.suptitle('测试静态图')\rt = arange(0.0, 3.0, 0.01)\rs = sin(2 * pi * t)\rself.axes.plot(t, s)\rself.axes.set_ylabel('静态图：Y轴')\rself.axes.set_xlabel('静态图：X轴')\rself.axes.grid(True)\r'''启动绘制动态图'''\rdef start_dynamic_plot(self, *args, **kwargs):\rtimer = QtCore.QTimer(self)\rtimer.timeout.connect(self.update_figure) # 每隔一段时间就会触发一次update_figure函数。\rtimer.start(1000) # 触发的时间间隔为1秒。\r'''动态图的绘图逻辑可以在这里修改'''\rdef update_figure(self):\rself.fig.suptitle('测试动态图')\rl = [random.randint(0, 10) for i in range(4)]\rself.axes.plot([0, 1, 2, 3], l, 'r')\rself.axes.set_ylabel('动态图：Y轴')\rself.axes.set_xlabel('动态图：X轴')\rself.axes.grid(True)\rself.draw()\rclass MatplotlibWidget(QWidget):\rdef __init__(self, parent=None):\rsuper(MatplotlibWidget, self).__init__(parent)\rself.initUi()\rdef initUi(self):\rself.layout = QVBoxLayout(self)\rself.mpl = MyMplCanvas(self, width=5, height=4, dpi=100)\r# self.mpl.start_static_plot() # 如果你想要初始化的时候就呈现静态图，请把这行注释去掉\r#self.mpl.start_dynamic_plot() # 如果你想要初始化的时候就呈现动态图，请把这行注释去掉\rself.mpl_ntb = NavigationToolbar(self.mpl, self) # 添加完整的 toolbar\rself.layout.addWidget(self.mpl)\rself.layout.addWidget(self.mpl_ntb)\rif __name__ == '__main__':\rapp = QApplication(sys.argv)\rui = MatplotlibWidget()\rui.mpl.start_static_plot() # 测试静态图效果\r# ui.mpl.start_dynamic_plot() # 测试动态图效果\rui.show()\rsys.exit(app.exec_())  ","id":16,"section":"posts","summary":"使用MatplotlibWidget 设置绘图类 class Canvas(FigureCanvas): def __init__(self,parent=None,width=5,height=4,dpi=100): plt.rcParams['font.family'] = ['SimHei']#显示中文标签 plt.reParams['axes.unicode_minus'] = False#显示负号 self.fig = Figure(figsize=(eidth,height),dpi=dpi) self.axes = self.fig.add_subplot(111) self.a","tags":["PyQt5"],"title":"在PyQt5中使用Matplotlib","uri":"https://xuzhihao.top/2020/05/%E5%9C%A8pyqt5%E4%B8%AD%E4%BD%BF%E7%94%A8matplotlib/","year":"2020"},{"content":"介绍 信号（Signal）和信号槽（Slot）是Qt的核心机制，它是PyQT编程对象之间进行通信的机制。\n在Qt中，每一给QObject对象和PyQt中所有继承在QWidget的控件都支持信号与槽机制。当信号发射时，连接的槽函数将会自动执行。在PyQt5中信号与槽通过object.singanl.connect()方法连接。\n信号与槽有下列特点：\n 一个信号可以连接多个槽 一个信号可以连接另一个信号 信号参数可以是任何Python类型 一个槽可以监听多个信号 信号与槽的连接方式可以使同步连接，也可以是异步连接 信号与槽的连接可能会跨线程 信号可能断开  信号与槽机制如下：\n\n定义信号 PyQt中的信号是自动定义的。使用PyQt5.Qtcore.pyqtSignal()函数可以为QObject创建一个信号，使用PyqtSignal()函数可以把信号定义为类属性。\nPyqtSignal()函数信息如下:\nPyQt5.QtCore.pyqtSignal(types[, name[, revision=0[, arguments=[]]]])\nCreate one or more overloaded unbound signals as a class attribute.\n  Parameters\ntypes – the types that define the C++ signature of the signal. Each type may be a Python type object or a string that is the name of a C++ type. Alternatively each may be a sequence of type arguments. In this case each sequence defines the signature of a different signal overload. The first overload will be the default.name – the name of the signal. If it is omitted then the name of the class attribute is used. This may only be given as a keyword argument.revision – the revision of the signal that is exported to QML. This may only be given as a keyword argument.arguments – the sequence of the names of the signal’s arguments that is exported to QML. This may only be given as a keyword argument.\n  Return type\nan unbound signal\n  1、为QObject对象操作信号 使用pyqtSignal()函数创建一个或多个重载的未绑定信号作为累的属性，信号只能在QObject子类中定义。\n信号必须在类创建时定义，不能在类创建后作为类的属性动态添加进来。Types参数表示定义信号时参数的类型，name参数表示信号名字，该项缺省时实用类的属性名字\n使用pyqtSignal()函数创建信号时，信号可以床底多个参数，并指定参数的类型，参数类型是标准的Python数据类型（字符串、日期、布尔值、数字、列表、元组和字典）\n2、为控件创建信号 from PyQt5.Qtcore import pyqtSignal\rfrom PyQt5.QtWidgets import QMainWindow\rclass WinForm(QMainWindow):\rbtnClickedSignal = pyqtSignal()  操作信号 使用connect()将信号绑定在函数上。\nconnect(slot[, type=PyQt5.QtCore.Qt.AutoConnection[, no_receiver_check=False]]) → PyQt5.QtCore.QMetaObject.Connection\nConnect a signal to a slot. An exception will be raised if the connection failed.Parametersslot – the slot to connect to, either a Python callable or another bound signal.type – the type of the connection to make.no_receiver_check – suppress the check that the underlying C++ receiver instance still exists and deliver the signal anyway.Returnsa Connection object which can be passed to disconnect(). This is the only way to disconnect a connection to a lambda function.\nSignals are disconnected from slots using the disconnect() method of a bound signal.\n使用disconnect()解除信号与槽函数的绑定\ndisconnect([slot])\nDisconnect one or more slots from a signal. An exception will be raised if the slot is not connected to the signal or if the signal has no connections at all.Parametersslot – the optional slot to disconnect from, either a Connection object returned by connect(), a Python callable or another bound signal. If it is omitted then all slots connected to the signal are disconnected.\nSignals are emitted from using the emit() method of a bound signal.\n使用emit()发射信号\nemit(*args)\nEmit a signal.\n  Parameters\nargs – the optional sequence of arguments to pass to any connected slots.\n  使用方法 内置信号与槽 使用窗口控件的函数，而不是自定义函数。在信号与槽中可以通过QObject.signal,connect将一个QObject信号连接到另一个QObject的槽函数。\nfrom PyQt5.QtWidgets import QPushButton,QApplication,QWidget\rfrom PyQt5.QtWidgets import QMessageBox\rimport sys\rapp = QApplication([])\rwidget = QWidget()\rdef showMsg():\rQMessageBox.information(widget,\u0026quot;信息提示框\u0026quot;,\u0026quot;OK\u0026quot;)\rbtn = QPushButton(\u0026quot;测试点击按钮\u0026quot;,widget) btn.clicked.connect(showMsg)\rwidget.show()\rsys.exit(app.exec_())\r 自定义信号与槽 在发射信号时，不使用窗口控件，而是使用自定义的函数（就是使用pyqtSignal类实例发射信号）。\n内置函数只包含一些常用信号，有些信号的发射找不到对应的内置函数；其次，只有在特定情况下（如点击按钮）才能发送信号；最后内置函数床底的参数是特定的，不可以自定义。\n# -*- coding: utf-8 -*-\rfrom PyQt5.QtCore import QObject, pyqtSignal\r# 信号对象\rclass QTypeSignal(QObject):\r# 定义一个信号\rsendmsg = pyqtSignal(object)\rdef __init__(self):\rsuper(QTypeSignal, self).__init__()\rdef run(self):\r# 发射信号\rself.sendmsg.emit('Hello Pyqt5')\r# 槽对象 class QTypeSlot(QObject):\rdef __init__(self):\rsuper(QTypeSlot, self).__init__()\r# 槽对象里的槽函数\rdef get(self, msg):\rprint(\u0026quot;QSlot get msg =\u0026gt; \u0026quot; + msg)\rif __name__ == '__main__':\rsend = QTypeSignal()\rslot = QTypeSlot()\r# 1\rprint('--- 把信号绑定到槽函数 ---')\rsend.sendmsg.connect(slot.get)\rsend.run()\r# 2\rprint('--- 把信号断开槽函数 ---')\rsend.sendmsg.disconnect(slot.get)\rsend.run()\r 装饰器的信号与槽 Refer：http://pyqt.sourceforge.net/Docs/PyQt5/signals_ slots.html?highlight=pyqtsignal#PyQt5.QtCore.pyqtSignal\n","id":17,"section":"posts","summary":"介绍 信号（Signal）和信号槽（Slot）是Qt的核心机制，它是PyQT编程对象之间进行通信的机制。 在Qt中，每一给QObject对象和P","tags":["PyQt5"],"title":"PyQt5中的信号槽","uri":"https://xuzhihao.top/2020/05/pyqt5%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E6%A7%BD/","year":"2020"},{"content":"tkinker编程就像是作画，先支起一个画架，放上画板，蒙上画布，构思内容，用铅笔画草图，组织结构和比例，调色板调色，最后画笔勾勒。这对应到tkinker，显示器就是画架，画板就是Toplevel，画布就是tkinker中的容器，对应Frame，画板上可以放很多张画布，tkinkrt中的容器也可以放很多容器，绘图中的构图布局则是tkinker中的布局管理器（几何管理器），绘图的内容就是tkinker中的一个个小组件，一幅画有许多元素构成，而我们的GUI界面，就是有一个个组件拼装起来的，他们都是widget。\nTkinter模块元素简要说明    tkinker类 元素 简要说明     Frame 框架 用来承载放置组件   Label 标签 用来显示不可编辑的文本或图标   Button 按钮 点击执行一个动作   Entry 单行文本框 显示一行文本   Text 多行文本框 显示多行文本   Checkbutton 复选框 允许用户选择或反选一个选项   Radiobutton 单选框 允许用户从多个选项中选取一个   Canvas 画布 提供绘图功能（直线椭圆、多边形、举行）可以包含图形或位图   Listbox 列表框 一个选项列表，用户可以从中选择   Menu 菜单 点下菜单按钮后弹出一个选项列表，用户可以从中选择   Menubutton 菜单按钮 用来包含菜单的组件（有下拉式、层叠式等等）   Message 消息框 类似于标签，但可以显示多行文本   Scale 进度条 线性滑块组件，可设定起始值和结束值   Scrollbar 滚动条 对其支持的组件（文本域、画布、列表框、文本框）提供滚动功能   Toplevel 顶层 类似框架，为其他控件提供单独的容器   Spinbox 输入控件 与Entry类似，但是可以指定输入范围值   PanedWindow 窗口布局管理 是一个窗口布局管理的插件，可以包含一个或多个子控件   LabelFrame 容器控件 是一个简单容器控件。常用于复杂窗口布局   messageBox 信息框 用于显示你应用程序的消息框。（Python2中时tkMessagebox)    from tkinter import *\r#创建根窗口\rroot = Tk()\r#设置窗口标题\rroot.title(\u0026quot;你好\u0026quot;)\r#设置窗口大小\rroot.geometry(\u0026quot;300x200\u0026quot;)\r#在窗体中创建一个框架，用它来承载其它部件\rapp = Frame(root)\r#设置布局管理器\rapp.grid()\rlabel = Label(app,text=\u0026quot;Hello Word!\u0026quot;)\rlabel.grid()\rbtn = Button(app)\rbtn.grid()\r#小部件的任何选项都可以通过configure()方法操作\rbtn.configure(text=\u0026quot;click\u0026quot;)\rroot.mainloop()\r tkinker编程关键就是，你要弄懂之间的层次关系。\n这里首先我们获得了画板，也就是根窗体root，然后又创建了一个容器Frame，也就是我们画布，在创建Frame时，我们很清楚画布必须放在画板上，所以传入了一个参数root，通常所有tkinker组件实例化时，第一个参数都是指定父控件，就是表示自己放在哪里。\n绝大多数控件共享属性    选项（别名） 说明 单位 典型值 没有这个属性的控件     background(bg) 当控件显示时，给出正常颜色 color gray5    borderwidth(bd) 设置一个非负值，该值显示控件外围3D边界的宽度； pixel 3    cursor 指定控件使用的鼠标光标，该值可以是Tkinker接受的任何格式 cursor grumby    font 指定控件内部文本的字体 font (\u0026lsquo;Verdana\u0026rsquo;,8) Canvas\\Frame\\Scrollbar\\Toplevel   foreground(fg) 指定控件的前景色 color gray30 Menu   highlightbackground 指定经过没有输入焦点的控件      highlightcolor 指出经过没有输入焦点的控件周围长方区域加亮颜色 color gray30 Menu   highlightthickness 设置一个非负值,该值指出一个有输入焦点的控件周围加亮方形区域的宽度,该值可以是 Tk_GetCursor接受的任何格式.如果为0,则不画加亮区域 pixel 2.1m Menu   relief 指出控件3D效果.可选值为RAISED,SUNKEN,FLAT,RIDGE,SOLID,GROOVE.该值指出控件内部相对于外部的外观样式,比如RAISED意味着控件内部相对于外部突出 constant RAISED、GROOVE    takefocus 定窗口在键盘遍历时是否接收焦点(比如Tab,shift-Tab).在设定焦点到一个窗口之前,遍历脚本检查takefocus选项的值,值0意味着键盘遍历时完全跳过,值1意味着只要有输入焦点(它及所有父代都映射过)就接收.空值由脚本自己觉定是否接收,当前的算法是如果窗口被禁止,或者没有键盘捆绑或窗口不可见时,跳过 boolean 1、YES    width 指定一个整数,设置控件宽度,控件字体的平局字符数.如果值小于等于0,控件选择一个能够容纳目前字符的宽度 integer 32 Menu    多控件共享属性：    选项(别名) 说明 类型 典型值 仅此控件     activebackground 指定画活动元素的背景颜色.元素(控件或控件的一部分)在鼠标放在其上并按动鼠标按钮引起某些行为的发生时,是活动的.如果严格的Modf一致性请求通过设置tk_strictModf变量完成,该选项将被忽略,正常背景色将被使用.对Windows和Macintosh系统,活动颜色将只有在鼠标按钮1被按过元素时使用 color red Button、Checkbutton、Menu、Menubutton、Radiobutton、Scale、Scrollbar   activeforeground 指定画活动元素时的前景颜色.参见上面关于活动元素的定义 color cabebule Button、Menu、Ckeckbutton、Menubutton   anchor 指出控件信息(比如文本或者位图)如何在控件中显示.必须为下面值之一:N,NE,E,SE,S,SW,W,NW或者CENTER.比如NW(NorthWest)指显示信息时使左上角在控件的左上端 constant NW ButtonCheckbuttonLabelMessageMenubuttonRadiobutton   bitmap 指定一个位图在控件中显示,以Tkinter(Tk_GetBitmap)接受的任何形式.位图显示的精确方式受其他选项如锚或对齐的影响.典型的,如果该选项被指定,它覆盖指定显示控件中文本的其他选;bitmap选项可以重设为空串以使文本能够被显示在控件上.在同时支持位图和图像的控件中,图像通常覆盖位图 bitmap  ButtonCheckbuttonLabelMenubuttonRadiobutton   command 指定一个与控件关联的命令.该命令通常在鼠标离开控件之时被调用,对于单选按钮和多选按钮,tkinter变量(通过变量选项设置)将在命令调用时更新\tcommand function类型  ButtonCheckbuttonRadiobuttonScaleScrollbar   disabledforeground 绘画元素时的前景色.如果选项为空串(单色显示器通常这样设置),禁止的元素用通常的前景色画,但是采用点刻法填充模糊化 color gray ButtonCheckbuttonRadiobuttonMenuMenubutton   height 指定窗口的高度,采用字体选项中给定字体的字符高度为单位,至少为1 integer 14 ButtonCanvasFrameLabelListboxCheckbuttonRadiobuttonMenubuttonTextToplevel   image 指定所在控件中显示的图像,必须是用图像create方法产生的.如果图像选项设定,它覆盖已经设置的位图或文本显示;更新恢复位图或文本的显示需要设置图像选项为空串 image  ButtonCheckbuttonLabelMenubuttonRadiobutton   justify 当控件中显示多行文本的时候,该选项设置不同行之间是如何排列的,其值为如下之一:LEFT,CENTER或RIGHT.LEFT指每行向左对齐,CENTER指每行居中对齐,RIGHT指向右对齐 constant  ButtonCheckbuttonEntryLabelMenubuttonMessageRadiobutton   padx 指定一个非负值设置控件X方向需要的边距.该值为Tkinter(Tk_GetPixels)接受的格式.当计算需要多大的窗口时,控件会把此值加到正常大小之上(由控件中显示内容决定);如果几何管理器能够满足此请求,控件将在左端或右端得到一个给定的多余空边.大部分控件只用此项于文本,如果它们显示位图或图像,通常忽略空边选项 pixel 10 ButtonCheckbuttonLabelMenubuttonMessageRadiobuttonText   pady 指定一个非负值设置控件Y方向需要的边距.该值为Tkinter(Tk_GetPixels)接受的格式.当计算需要多大的窗口时,控件会把此值加到正常大小之上(由控件中显示内容决定);如果几何管理器能够满足此请求,控件将在上端或下端得到一个给定的多余空边.大部分控件只用此项于文本,如果它们显示位 图或图像,通常忽略空边选项 pixels 12 ButtonCheckbuttonLabelMenubuttonMessageRadiobuttonText   selectbackground 指定显示选中项时的背景颜色 color  CanvasListboxEntryText   selectborderwidth 指定一个非负值,给出选中项的三维边界宽度,值可以是任何Tkinter(Tk_GetPixels)接受的格式 pixel 3 CanvasEntryListboxText   selectforeground 指定显示选中项的前景颜色 color yellow CanvasEntryListboxText   stat 指定控件下列两三个状态之一(典型是复选按钮)： NORMAL和DISABLED或NORMAL,ACTIVE和NORMAL.在NORMAL状态,控件有前景色和背景显示;在ACTIVE状态,控件按activeforeground和activebackground选项显示;在DISABLED状态下,控件不敏感,缺省捆绑将拒绝激活控件,并忽略鼠标行为,此时,由disabled foreground和background选项决定如何显示 constant active ButtonCheckbuttonEntryMenubuttonScaleRadiobuttonText   text 指定控件中显示的文本,文本显示格式由特定控件和其他诸如锚和对齐选项决定 string \u0026lsquo;Display\u0026rsquo; ButtonCheckbuttonLabelMenubuttonMessageRadiobutton   textvariable 指定一个变量名字.变量值被转变为字符串在控件上显示.如果变量值改变,控件将自动更新以反映新值,字符串显示格式由特定控件和其他诸如锚和对齐选项决定   ButtonCheckbuttonEntryLabelMenubuttonMessageRadiobutton   underline 指定控件中加入下划线字符的整数索引.此选项完成菜单按钮与菜单输入的键盘遍历缺省捆绑.0对应控件中显示的第一个字符,1对应第二个,以此类推 integer 2 ButtonCheckButtonLabelMenubuttonRadiobutton   wraplength 对于能够支持字符换行的控件,该选项指定行的最大字符数,超过最大字符数的行将转到下行显示,这样一行不会超过最大字符数.该值可以是窗口距离的任何标准格式.如果该值小于或等于0,不换行,换行只有在文本中的换行符的地方才出现 pixel 31 ButtonCheckbuttonLabelMenubuttonRadiobutton   xscrollcommand 定一个用来与水平滚动框进行信息交流的命令前缀,当控件窗口视图改变(或者别的任何滚动条显示的改变,如控件的总尺寸改变等等),控件将通过把滚动命令和两个数连接起来产生一个命令.两个数分别为0到1之间的分数,代表文档中的一个位置,0表示文档的开头,1.0表示文档的结尾处,0.333表示整个文档的三分之一处,如此等等.第一个分数代表窗口中第一个可见文档信息,第二个分数代表紧跟上一个可见部分之后的信息.然后命令把它们传到Tcl解释器执行.典型的,xscrollcommand选项由滚动条标识跟着set组成,如set.x.scrollbar set将引起滚动条在窗口中视图变化时被更新.如果此项没有指定,不执行命令   CanvasEntryListboxText   yscrollcommand 指定一个用来与垂直滚动框进行信息交流的命令前缀,当控件窗口视图改变(或者别的任何滚动条显示的改变,如控件的总尺寸改变等等),控件将通过把滚动命令和两个数连接起来产生一个命令.两个数分别为0到1之间的分数,代表文档中的一个位置,0表示文档的开头,1.0表示文档的结尾处,0.333表示整个文档的三分之一处,如此等等.第一个分数代表窗口中第一个可见文档信息,第二个分数代表紧跟上一个可见部分之后的信息.然后命令把它们传到Tcl解释器执行.典型的,yscrollcommand选项由滚动条标识跟着set组成,如set.y.scrollbar set将引起滚动条在窗口中视图变化时被更新.如果此项没有指定,不执行命令 function  CanvasEntryListboxText    refer：https://blog.csdn.net/yingshukun/article/details/53985080\nrefer：https://docs.python.org/zh-cn/3/library/tk.html\n","id":18,"section":"posts","summary":"tkinker编程就像是作画，先支起一个画架，放上画板，蒙上画布，构思内容，用铅笔画草图，组织结构和比例，调色板调色，最后画笔勾勒。这对应到","tags":["Python标准库"],"title":"Tkinker简单了解","uri":"https://xuzhihao.top/2020/05/tkinker%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/","year":"2020"},{"content":"方法一: 我们要使用到两个方法：decode解码 、encode编码\n假设一个网站的编码是\u0026rsquo;iso-8859-1\u0026rsquo;，通过requests.get(url).encoding获取编码形式。\n编写爬虫返回文本就会发生乱码。\n解码就是将其它编码转为Unicode，编码就是将Unicode编码成其他形式。\nres.encode('iso-8859-1').decode('utf-8')\r 这里采用的就是一个曲折的方式，将某一编码转化为Unicode，再讲Unicode转化为UTF-8。\n这个以作为一个爬虫程序的前置检查。\n使用replace 我遇见过一个符号不能被写入，它其实是一个空格。\n这里提供一个思路\ntext = text.replace('\\x00',' ')\r ","id":19,"section":"posts","summary":"方法一: 我们要使用到两个方法：decode解码 、encode编码 假设一个网站的编码是\u0026rsquo;iso-8859-1\u0026rsquo;，通过r","tags":["爬虫"],"title":"爬虫解决乱码","uri":"https://xuzhihao.top/2020/05/%E7%88%AC%E8%99%AB%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81/","year":"2020"},{"content":"我们大多数都是数学运算，其实我们还有另外一种方式——符号数学（symbolic math）。这个需要我们是要第三方库Sympy。\n定义符号与运算 符号是构成符号运算的基础。\n\u0026gt;\u0026gt;\u0026gt;from sympy import Symbol\r\u0026gt;\u0026gt;\u0026gt;x = Symbol('x')\r 这里创建了一个Symbol类的对象，将\u0026rsquo;x'作为参数传递。注意\u0026rsquo;x'是作为有引号包围的字符串传递。\n这里建议，你使用一个与被指代符号字母相同的标签。\n我们可以多次创建单独的Symbol对象或者使用symbols()函数更简洁地定义。\n\u0026gt;\u0026gt;\u0026gt;from sympy import symbols\r\u0026gt;\u0026gt;\u0026gt;x,y,z = symbols('x,y,z')\r 分解与展开表达式 factor()函数分解表达式；expand()函数展开表达式，将表达式表示为单个项目的总和。\n\u0026gt;\u0026gt;\u0026gt;from sympy import Symbol\r\u0026gt;\u0026gt;\u0026gt;from sympy import factor\r\u0026gt;\u0026gt;\u0026gt;x = Symbol('x')\r\u0026gt;\u0026gt;\u0026gt;y = Symbol('y')\r\u0026gt;\u0026gt;\u0026gt;expr = x**2 - y**2\r\u0026gt;\u0026gt;\u0026gt;factor = factor(expr)\r(x-y) * (x+y)\r\u0026gt;\u0026gt;\u0026gt;expand(factor)\rx**2 - y**2\r 如果你试图分解无法分解的表达式，factor()函数会返回原始表达式。\n让表达式整齐输出 我们就要使用pprint()函数，这个函数将使表达式看起来整齐些。\n\u0026gt;\u0026gt;\u0026gt;from sympy import pprint\r\u0026gt;\u0026gt;\u0026gt;expr = x**2 + 2*x*y + y**2\r\u0026gt;\u0026gt;\u0026gt;pprint(expr)\r 这些项按x的幂顺序排列，从最低次到最高次，这需要init_pprint()函数。\n\u0026gt;\u0026gt;\u0026gt;from sympy import init_print\r\u0026gt;\u0026gt;\u0026gt;from sympy import pprint\r\u0026gt;\u0026gt;\u0026gt;init_print(order='rev-lex')\r\u0026gt;\u0026gt;\u0026gt;expr = x**2 + 2*x*y + y**2\r\u0026gt;\u0026gt;\u0026gt;pprint(expr)\r 为符号赋值 使用sub()函数将值带入：\n\u0026gt;\u0026gt;\u0026gt;expr = x*x + x*y +y*y\r\u0026gt;\u0026gt;\u0026gt;res = expr.subs({x:1,y:2})\r 我们其实也可以用一个符号表示另一个符号：\n\u0026gt;\u0026gt;\u0026gt;expr = x*x + x*y +y*y\r\u0026gt;\u0026gt;\u0026gt;expr.subs({x:1-y})\r 简化结果 如果存在相互抵消的项，我们可以用Sympy的simplify()函数\n\u0026gt;\u0026gt;\u0026gt;from sympy import simplify\r\u0026gt;\u0026gt;\u0026gt;expr = x*x + x*y +y*y - y*y\r\u0026gt;\u0026gt;\u0026gt;simplify(expr)\r 将字符串转换为数学表达式 将用户输入的（字符串）转换为可以执行的数学运算内容。\nsympify()函数就可以完成这个任务。\n\u0026gt;\u0026gt;\u0026gt;from sympy import sympify\r\u0026gt;\u0026gt;\u0026gt;expr = input('Please enter a mathematical expression:')\r\u0026gt;\u0026gt;\u0026gt;expr = sympify(expr)\r 这里可能会出现用户表达式输入错误的情况。这时候，我们可以从sympy.core.sympfy导入SympifyError异常，然后进行异常处理。\n表达式乘法 如果我们想计算两个表达式的成绩并输出结果，那就要使用expand()函数\nfrom sympy import expand,sympify\rfrom sympy.core.sympify import SympifyError\rdef product(expr1,expr2):\rprint(expand(expr1*expr2))\rif __name__ == \u0026quot;__main__\u0026quot;:\rexpr1 = input('Enter the first expression:')\rexpr2 = input('Enter the second expression:')\rtry:\rexpr1 = sympify(expr1)\rexpr2 = sympify(expr2)\rexcept SympifyError:\rprint(\u0026quot;Invaild input:\u0026quot;)\relse:product(expr1,expr2)\r 解方程 使用slove()解方程。当你输入一个代表变量（比如x）的符号表达式时，slove()函数可以计算出该符号的值。不过，该函数总是通过假设输入的表达式等于0来计算的。\nfrom sympy import Symbol,solve\rx = Symbol('x')\rexpr = x -5 -7\rprint(slove(expr))\r [12]\r 解二元方程 from sympy import solve,Symbol\rx = Symbol('x')\rexpr = x**2 + 5*x +4\rprint(solve(expr,dict=True))\r [{x:-4,{x:-1}}]\r 其中dict=True就是指定结果作为一个列表返回，其中每个元素都是Python字典。\n用其他变量求解一个变量 这其实也是都solve(),不过就是多了一个参数。\nfrom sympy import solve,Symbol\rx = Symbol('x')\ry = Symbol('y')\rz = Symbol('z')\rexpr = a*x*x +b*x +c\rprint(solve(expr,x,dict=True))\r 多的这个参数，就是告诉slve()函数，你要去解哪个变量。\n解线性方程 例如: $$ 2x+3y=6 $$\n$$ 3x+2y=12 $$\n我们可以这样做：\nfrom sympy import Symbol,solve\rx = Symbol('x')\ry = Symbol('y')\rexpr1 = 2*x+3*y-6\rexpr2 = 3*x+2*y-12\rprint(solve((expr1,expr2),dict=True))\r [{y:-6/5,x:24/5}]\r 用SymPy绘图 Sympy绘图其实是调用了matplotlib。\nfrom sympy import Symbol\rfrom sympy.plotting import plot\rx = Symbol('x')\rplot(2*x+3)\r 这里x轴的坐标是默认自动选择的。我们可以通过调节plot()函数中的参数，改变x轴的范围。我们也可以改变x轴标签，y轴标签和标题名称\nplot((2*x+3),(x,-5,5),title='Line',xlabel='x',ylabel='2x+3')\r 可以将plot对象调用save()函数将图形保存为图像。\n多图像绘制 from sympy import Symbol\rfrom sympy.plotting import plot\rx = Symbol('x')\rp = plot(2*x+3,3*x+1,legend=True,show=False)\rp[0].line_color = 'b'\rp[1].line_color = 'r'\rp.show()\r legend参数用于显示图例。rashow之所以设为不显示，是为了更改线条的颜色。\n解单变量不等式 slove_ploly_inequality()函数，用于解多项式不等式。\nslove_rational_inequality()函数，用于解有理式不等式。\nslove_univariate_inequality()函数，用于解非有理式，非多项式的不等式\n","id":20,"section":"posts","summary":"我们大多数都是数学运算，其实我们还有另外一种方式——符号数学（symbolic math）。这个需要我们是要第三方库Sympy。 定义符号与运算","tags":["数据分析"],"title":"Sympy解代数问题","uri":"https://xuzhihao.top/2020/05/sympy%E8%A7%A3%E4%BB%A3%E6%95%B0%E9%97%AE%E9%A2%98/","year":"2020"},{"content":"简单介绍下基础 import matplotlib.pyplot as plt\rx = [1,2,3]\ry = [1,2,3]\rfig = plt.figure()\rax = plt.axes()\rplt.plot(x,y)\rplt.show()\r 这里，我们使用figure()函数创建Figure对象（fig），然后使用axes()创建坐标轴。axes()函数同时也将坐标轴添加都Figure对象中。\n除了手动，创建Figure对象和Axes对象之外，还可以使用pyplot模块中的两个不同函数(gcf()函数和gca()函数)来获取对当前Figure和Axes对象的引用；当调用gca()函数时，它返回当前Axes对象的引用；当调用gcf()函数时，它返回当前Figure对象的引用。这两个函数都有一个特性：如果对象不存在，他们将分别创建相应的对象、\n接下来，我们做一个图：\nimport matplotlib.pyplot as plt\rdef create_circle():\rcircle = plt.Circle((0,0),radius = 0.5)\rreturn circle\rdef show_shape(patch):\rax = plt.gca()\rax.add_patch(patch)\rplt.axis('scaled')\rplt.show()\rif __name__ == \u0026quot;__main__\u0026quot;:\rc = create_circle()\rshow_shape(c)\r 这里调用gca()函数，获得对当前Axes对象的引用，接着使用add_patch()函数将其添加到它的块。\n当然，这里plt的axis参数，选择了\u0026quot;scaled\u0026rdquo;，这使matplotlib能够自动调节数轴的取值范围。如果，用ax.set_aspect('equal')，就会使x轴和y轴的长度比都是1:1。\n提示:plt.Circle()中的fc可以指定边缘颜色，ec是内部填充的颜色。\n创建简单动画 from matplotlib import pyplot as plt\rfrom matplotlib import animation\rdef create_circle():\rcircle = plt.Circle((0, 0), 0.05)\rreturn circle\rdef update_radius(i, circle):\rcircle.radius = i * 0.5\rreturn circle\rdef create_animation():\rfig = plt.gcf()\rax = plt.axes(xlim=(-10, 10), ylim=(-10, 10))\rax.set_aspect('equal')\rcircle = create_circle()\rax.add_patch(circle)\ranim = animation.FuncAnimation(fig, update_radius, fargs=(circle,), frames=30, interval=5)\rplt.title(\u0026quot;simple circle Animation\u0026quot;)\rplt.show()\rif __name__ == \u0026quot;__main__\u0026quot;:\rcreate_animation()\r 这里，animation.FuncAnimation(fig,update_radius,fargs,frames,interval)\n fig:它是指当前的Figure对象 update_radius:负责绘制每一帧的函数，它需要两个参数——一个调用时自动传递给他的帧编号，以及更新每一帧时的块对象。这个函数必须返回一个块对象。（return) fargs:这个元组包含所有（除了帧编号）要传递给update_radius()函数的参数。 frames:这是指动画中的帧数，也是update_radius()函数被调用的次数。 interval:指两个动画之间的时间间隔（毫秒）。  注意：anim = animation.FuncAnimation(fig, update_radius, fargs=(circle,), frames=30, interval=5)，这里anim在之后虽然没有被引用，但是这是必须的，不然，受Python中垃圾回收机制的影响，动画不会被创建。\n绘制抛物轨迹动画 from matplotlib import pyplot as plt\rfrom matplotlib import animation\rimport math\rg = 9.8\rdef get_intervals(u,theta):\rt_filght = 2*u*math.sin(theta) / g\rintervals = []\rstart = 0\rinterval = 0.005\rwhile start \u0026lt; t_filght:\rintervals.append(start)\rstart = start + interval\rreturn intervals\rdef update_position(i,circle,intervals,u,theta):\rt = intervals[i]\rx = u*math.cos(theta)*t\ry = u*math.sin(theta)*t - 0.5*g*t*t\rcircle.center = x,y\rreturn circle\rdef create_animation(u,theta):\rintervals = get_intervals(u,theta)\rxmin = 0\rxmax = u*math.cos(theta)*intervals[-1]\rymin = 0\rt_max = u*math.sin(theta)/g\rymax = u*math.sin(theta)*t_max - 0.5*g*t_max**2\rfig = plt.gcf()\rax = plt.axes(xlim=(xmin,xmax),ylim=(ymin,ymax))\rcircle = plt.Circle((xmin,ymin),1.0)\rax.add_patch(circle)\rax.set_aspect('equal')\ranim = animation.FuncAnimation(fig,update_position,fargs=(circle,intervals,u,theta),frames=len(intervals),interval=1,repeat=False)\rplt.title('Projectile Motion')\rplt.xlabel('X')\rplt.ylabel('Y')\rplt.show()\rif __name__==\u0026quot;__main__\u0026quot;:\rtry:\ru = float(input('Enter the initial velocity(m/s):'))\rtheta = float(input('Enter the angle of Projection(degre):'))\rexcept ValueError:\rprint('You entered an invalid input')\relse:\rtheta = math.radians(theta)\rcreate_animation(u,theta)\r  update_position:改变每一帧中圆的圆心 fargs:update_position中需要的时间间隔列表、间隔、初始速度和theta frames:每一个时间间隔绘制的帧的数量 repeat:默认情况下动画将无线重复，设为False就不会无限重复。  ","id":21,"section":"posts","summary":"简单介绍下基础 import matplotlib.pyplot as plt x = [1,2,3] y = [1,2,3] fig = plt.figure() ax = plt.axes() plt.plot(x,y) plt.show() 这里，我们使用figure()函数创建Figure对象（fig），然后使用axes()创建","tags":["数据可视化"],"title":"Matplotlib绘制动画","uri":"https://xuzhihao.top/2020/05/matplotlib%E7%BB%98%E5%88%B6%E5%8A%A8%E7%94%BB/","year":"2020"},{"content":"正则表达式本质上是个独立的语言，短小却格外强悍。\n他的含义就是：我们可以书写特定的规则，用来在文本中捕获与规则一致的字符串，而后对其进行操作\u0026hellip;\u0026hellip;\n例如\nimport re\rstr = 'The quick brown fox jumps over the lazy dog'\rpttn = re.compile(r'\\wo\\w')\rre.findall(pttn, str)\r ['row', 'fox', 'dog']\r 其中，有人就已经总结过了：\n 规则表达式（Regular Expressions，通常缩写为 Regex）是最强大且不可或缺的文本处理工具 —— 它的用处就是在文本中扫描/搜索（Scan/Search）与某一规则（Pattern）匹配（Match，即，与规则一致）的所有实例，并且还可以按照规则捕获（Capture）其中的部分或者全部，对它们进行替换（Replace）。\n 当然，有时候 大家使用正则表达式，并不是为了替换或搜索，而是为了检查格式，比如，可以用Regex检查用户输入的密码是否过于简单（比如，全部都由数字组成），比如可以用来验证用户输入的电话号码、证件是否符号特定格式等。\n视觉体验 Python代码仓库里面有个简短的Demo程序，叫redemo.py，它使用Tcl/Tk作为图形界面，也可以用来测试正则表达。\n https://raw.githubusercontent.com/python/cpython/master/Tools/demo/redemo.py\n 准备工作 这里我就借用了李老师的东西了。\n下面将使用文件regex-target-text-simple.txt。\n\u0026lt;ol\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;pre\u0026gt;begin began begun bigins begining\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;pre\u0026gt;google gooogle goooogle goooooogle\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;pre\u0026gt;coloured color coloring colouring colored\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;pre\u0026gt;never ever verb however everest\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;pre\u0026gt;520 52000 5200000 520000000 520000000000\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;pre\u0026gt;error wonderer achroiocythaemia achroiocythemia\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;pre\u0026gt;The white dog wears a black hat.\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;pre\u0026gt;Handel, Händel, Haendel\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;/ol\u0026gt;\r\u0026lt;dl\u0026gt;(843) 542-4256\u0026lt;/dl\u0026gt; \u0026lt;dl\u0026gt;(431) 270-9664\u0026lt;/dl\u0026gt;\r\u0026lt;dl\u0026gt;3336741162\u0026lt;/dl\u0026gt; \u0026lt;dl\u0026gt;3454953965\u0026lt;/dl\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;peoplesr@live.com\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;jaxweb@hotmail.com\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;dhwon@comcast.net\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;krueger@me.com\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;h3\u0026gt;URLs\u0026lt;/h3\u0026gt;\rhttps://docs.python.org/3/howto/regex.html\rhttps://docs.python.org/3/library/re.html\r\u0026lt;h3\u0026gt;passwords\u0026lt;/h3\u0026gt;\rPasw0rd~\ri*Eh,GF67E\ra$4Bh9XE\u0026amp;E\r\u0026lt;h3\u0026gt;duplicate words\u0026lt;/h3\u0026gt;\r\u0026lt;p\u0026gt;It's very very big.\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;Keep it simple, simple, simple!\u0026lt;/p\u0026gt;\r 基本实例\nimport re\rwith open('regex-target-text-sample.txt','r') as f:\rstr = f.read()\rpattn = r'beg[iau]ns?'\rre.findall(pattn,str)\r ['begin','began','begun','begin']\r 优先级 编程语言无非就是用来运算的，而运算就要有操作符和操作元，操作符就有优先级之分。\nRegex也一样，它本身就是个迷你语音。在Regex中，操作符肯定有优先级。它的操作元有个专有的名称：原子。\n   排列 原子与操作符优先级 （从高到低）     1 转义符号 (Escaping Symbol) \\ |   2 分组、捕获 (Grouping or Capturing) (...) (?:...) (?=...) (?!...) (?\u0026lt;=...) `(? |   3 数量 (Quantifiers) a* a+ a? a{n, m}   4 序列与定位（Sequence and Anchor） abc ^ $ \\b \\B   5 或（Alternation） a|b|c   6 原子 (Atoms) a [^abc] \\t \\r \\n \\d \\D \\s \\S \\w \\W .    原子 在Regex的Patten中，操作元，即，被运算的“值”，被称为原子。\n本义字符 最基本的原子，就是本义字符，他们都是单个字符。\n本义字符包括从 a 到 z，A 到 Z，0 到 9，还有 _ —— 它们所代表的就是它们的字面值。\n即，相当于，string.ascii_letters 和 string.digits 以及 _。\n以下字符在 Regex 中都有特殊含义：\n \\` `+` `*` `.` `?` `-` `^` `$` `|` `(` `)` `[` `]` `{` `}` `\u0026lt;` `\u0026gt;\r  当你在写 Regex 的时候，如果你需要搜索的字符不是本义字符，而是以上这些特殊字符时，建议都直接加上转义符号 \\ 来表示，比如，你想搜索 '，那你就写 \\'，或者你想搜索 # 那你就写 \\#（事实上，# 并不是 Regex 的特殊符号，所以，它之前的转义符号可有可无）—— 这对初学者来说可能是最安全的策略。\n集合原子 集合原子还是原子。\n标示集合原子，使用方括号 []。[abc] 的意思是说，“a or b or c”，即，abc 中的任意一个字符。\n比如，beg[iau]n 能够代表 begin、began，以及 begun\nstr = 'begin began begun bigins begining'\rpttn = r'beg[iau]n'\rre.findall(pttn, str)\r ['begin', 'began', 'begun', 'begin']\r 在方括号中，我们可以使用两个操作符：-（区间）和 ^（非）。\n [a-z] 表示从小写字母 a 到小写字母 z 中的任意一个字符。 [^abc] 表示 abc 以外的其它任意字符，即，非 [abc]。  注意，一个集合原子中，^ 符号只能用一次，只能紧跟在 [ 之后。否则不起作用。\n类别原子 类别原子，是指那些能够代表 “一类字符” 的原子，它们都得使用转义符号再加上另外一个符号表达，包括：\n\\d` 任意数字；等价于 `[0-9]\r\\D` 任意非数字；等价于 `[^0-9]\r\\w` 任意本义字符；等价于 `[a-zA-Z0-9_]\r\\W` 任意非本义字符；等价于 `[^a-zA-Z0-9_]\r \\s 任意空白；相当于 [ \\f\\n\\r\\t\\v]（注意，方括号内第一个字符是空格符号）\n\\S 任意非空白；相当于 [^ \\f\\n\\r\\t\\v]（注意，紧随 ^ 之后的是一个空格符号） . 是除 \\r \\n 之外的任意字符；相当于 \\r\\n\n类别原子挺好记忆的，如果你知道各个字母是哪个词的首字母的话：\n  d 是 digits w 是 word characters s 是 spaces   另外，在空白的集合 [ \\f\\n\\r\\t\\v] 中：\\f 是分页符；\\n \\r 是换行符；\\t 是制表符；\\v 是纵向制表符（很少用到）。各种关于空白的转义符也同样挺好记忆的，如果你知道各个字母是那个词的首字母的话：\n  f 是 flip n 是 new line r 是 return t 是 tab v 是 vertical tab   import re\rstr = '\u0026lt;dl\u0026gt;(843) 542-4256\u0026lt;/dl\u0026gt; \u0026lt;dl\u0026gt;(431) 270-9664\u0026lt;/dl\u0026gt;'\rpttn = r'\\d\\d\\d\\-'\rre.findall(pttn, str)\r ['542-', '270-']\r 边界原子 我们可以用边界原子指定边界。也可以称作 “定位操作符”。\n^ 匹配被搜索字符串的开始位置；\n$ 匹配被搜索字符串的结束位置；\n\\b 匹配单词的边界；er\\b，能匹配 coder 中的 er，却不能匹配 error 中的 er；\n\\B 匹配非单词边界；er\\B，能匹配 error 中的 er，却不能匹配 coder 中的 er。\nimport re\rstr = 'never ever verb however everest'\rpttn = r'er\\b'\rre.findall(pttn, str)\rpttn = r'er\\B'\rre.findall(pttn, str)\r ['er', 'er', 'er']\r['er', 'er']\r 注意：^ 和 $ 在 Python 语言中被 \\A 和 \\Z 替代。\n事实上，每种语言或多或少都对 Regex 有自己的定制。不过，这里绝大多数细节，都是通用的。\n组合原子 我们可以用圆括号 () 将多个单字符原子组合成一个原子 —— 这么做的结果是，() 内的字符串将被当作一整个原子，可以被随后我们要讲解的数量操作符操作。\n另外，() 这个操作符，有两个作用：组合（Grouping），就是我们刚刚讲到的作用；而另外一个作用是捕获（Capturing)，后面会讲到。\n注意区别，er、[er\\]和 (er)各不相同。\n  er 是两个原子，'e' 和紧随其后的 'r' [er] 是一个原子，或者 'e' 或者 'r'； (er) 是一个原子，'er'   下一节中讲到数量操作符的时候，会再次强调这点。\n数量操作符 数量操作符有：+ ? * {n, m}。\n它们是用来限定位于它们之前的原子允许出现的个数；不加数量限定则代表出现一次且仅出现一次：\n+ 代表前面的原子必须至少出现一次，即：`出现次数 ≧ 1\n 例如，go+gle可以匹配 google gooogle goooogle 等；\n ? 代表前面的原子最多只可以出现一次，即：0 ≦ 出现次数 ≦ 1\n 例如，colou?red可以匹配 colored 或者 coloured;\n * 代表前面的原子可以不出现，也可以出现一次或者多次，即：出现次数 ≧ 0\n 例如，520*可以匹配 52 520 52000 5200000 520000000000 等。\n {n} 之前的原子出现确定的 n 次；\n{n,} 之前的原子出现至少 n 次；\n{n, m} 之前的原子出现至少 n 次，至多 m 次\n 例如，go{2,5}gle，能匹配 google gooogle goooogle 或 gooooogle，但不能匹配 gogle 和 gooooooogle\n import re\rwith open('regex-target-text-sample.txt', 'r') as f:\rstr = f.read()\rpttn = r'go+gle'\rre.findall(pttn, str)\rpttn = r'go{2,5}gle'\rre.findall(pttn, str)\rpttn = r'colou?red'\rre.findall(pttn, str)\rpttn = r'520*'\rre.findall(pttn, str)\r ['google', 'gooogle', 'goooogle', 'goooooogle']\r['google', 'gooogle', 'goooogle']\r['coloured', 'colored']\r['520', '52000', '5200000', '520000000', '520000000000']\r 数量操作符是对它之前的原子进行操作的，换言之，数量操作符的操作元是操作符之前的原子。\n上一节提到，要注意区别：er、[er] 和 (er) 各不相同。\n  er 是两个原子，'e' 之后 'r' [er] 是一个原子，或者 'e' 或者 'r'； (er) 是一个原子，'er'   import re\rstr = 'error wonderer severeness'\rpttn = r'er'\rre.findall(pttn, str)\rpttn = r'[er]'\rre.findall(pttn, str)\rpttn = r'(er)'\rre.findall(pttn, str)\r ['er', 'er', 'er', 'er']\r['e', 'r', 'r', 'r', 'e', 'r', 'e', 'r', 'e', 'e', 'r', 'e', 'e']\r['er', 'er', 'er', 'er']\r 在以上的例子中，看不出 er 和 (er) 的区别，但是，加上数量操作符就不一样了 —— 因为数量操作符只对它之前的那一个原子进行操作：\nimport re\rstr = 'error wonderer severeness'\rpttn = r'er+'\rre.findall(pttn, str)\rpttn = r'[er]+'\rre.findall(pttn, str)\rpttn = r'(er)+'\rre.findall(pttn, str)\r [28]:\n['err', 'er', 'er', 'er']\r['err', 'r', 'erer', 'e', 'ere', 'e']\r['er', 'er', 'er']\r 或操作符 | 或操作符 | 是所有操作符中优先级最低的，数量操作符的优先级比它高，所以，在 | 前后的原子被数量操作符（如果有的话）操作之后才交给 | 操作。\n于是，begin|began|begun 能够匹配 begin 或 began 或 begun。\nimport re\rstr = 'begin began begun begins beginn'\rpttn = r'begin|began|begun'\rre.findall(pttn, str)\r ['begin', 'began', 'begun', 'begin', 'begin']\r 在集合原子中（即，[] 内的原子）各个原子之间的关系，只有 “或” —— 相当于方括号中的每个原子之间都有一个被省略的 |。\n注意：方括号的 | 不被当作特殊符号，而是被当作 | 这个符号本身。在方括号中的圆括号，也被当作圆括号 () 本身，而无分组含义。\nimport re\rstr = 'achroiocythaemia achroiocythemia a|e'\rpttn = r'[a|ae]'\rre.findall(pttn, str)\rpttn = r'[a|e]'\rre.findall(pttn, str)\rpttn = r'[ae]'\rre.findall(pttn, str)\rpttn = r'[(ae)]'\rre.findall(pttn, str)\rpttn = r'[a|ae|(ae)]'\rre.findall(pttn, str)\r ['a', 'a', 'e', 'a', 'a', 'e', 'a', 'a', '|', 'e']\r 匹配并捕获 捕获（Capture），使用的是圆括号 ()。使用圆括号得到的匹配的值被暂存成一个带有索引的列表，第一个是 $1，第二个是 $2…… 以此类推。随后，我们可以在替换的过程中使用 $1 $2 中所保存的值。\n注意：在 Python 语言中调用 re 模块之后，在 re.sub() 中调用被匹配的值，用的索引方法是 \\1、\\2…… 以此类推。\nimport re\rstr = 'The white dog wears a black hat.'\rpttn = r'The (white|black) dog wears a (white|black) hat.'\rre.findall(pttn, str)\rrepl = r'The \\2 dog wears a \\1 hat.'\rre.sub(pttn, repl, str)\rrepl = r'The \\1 dog wears a \\1 hat.'\rre.sub(pttn, repl, str)\r 'The white dog wears a white hat.'\r 非捕获匹配 有时，你并不想捕获圆括号中的内容，在那个地方你使用括号的目的只是分组，而非捕获，那么，你就在圆括号内最开头加上 ?: —— (?:...)：\nimport re\rstr = 'The white dog wears a black hat.'\rpttn = r'The (?:white|black) dog wears a (white|black) hat.'\rre.findall(pttn, str) # 只捕获了一处，也就是说只有一个值将来可以被引用\rrepl = r'The \\1 dog wears a \\1 hat.' # 之前的一处捕获，在替换时可被多次引用\rre.sub(pttn, repl, str)\r ['black']\r'The black dog wears a black hat.'\r 在 Python 代码中使用正则表达式，匹配和捕获以及随后的替换，有更灵活的方式，因为可以对那些值直接编程。re.sub() 中，repl 参数甚至可以接收另外一个函数作为参数 —— 以后你肯定会自行认真阅读以下页面中的所有内容：\n https://docs.python.org/3/library/re.html\n 非捕获匹配，还有若干个操作符：\n(?=pattern)\r  正向肯定预查（look ahead positive assert），在任何匹配规则的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，Windows(?=95|98|NT|2000) 能匹配 Windows2000 中的 Windows，但不能匹配 Windows3.1 中的 Windows。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。\n (?!pattern)\r  正向否定预查（negative assert），在任何不匹配规则的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如Windows(?!95|98|NT|2000) 能匹配 Windows3.1 中的 Windows，但不能匹配 Windows2000 中的 Windows。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。\n (?\u0026lt;=pattern)\r  反向（look behind）肯定预查，与正向肯定预查类似，只是方向相反。例如，(?\u0026lt;=95|98|NT|2000)Windows 能匹配 2000Windows 中的 Windows，但不能匹配 3.1Windows 中的 Windows。\n `(?\n 反向否定预查，与正向否定预查类似，只是方向相反。例如 (? 能匹配 3.1Windows中的Windows，但不能匹配 2000Windows中的Windows`。\n 控制标记 有几个全局控制标记（Flag）需要了解，其中最常默认指定的有 G 和 M：\nA/ASCII，默认为 False\n  \\d, \\D, \\w, \\W, \\s, \\S, \\b, 和 \\B 等只限于 ASCII 字符 行内写法：(?a) Python re 模块中的常量：re.A re.ASCII   I/IGNORECASE，默认为 False\n  忽略字母大小写 行内写法：(?i) Python re 模块中的常量：re.I re.IGNORECASE   G/GLOBAL，默认为 True\n  找到第一个 match 之后不返回 行内写法：(?g) Python re 模块中这个标记不能更改，默认为 TRUE   L/LOCALE，默认为 False\n  由本地语言设置决定 \\d, \\D, \\w, \\W, \\s, \\S, \\b, 和 \\B 等等的内容 行内写法：(?L) Python re 模块中的常量：re.L re.LOCALE   M/MULTILINE，默认为 True\n  使用本标志后，^ 和 $ 匹配行首和行尾时，会增加换行符之前和之后的位置。 行内写法：(?m) Python re 模块中的常量：re.M re.MULTILINE   S/DOTALL，默认为 False\n  使 . 完全匹配任何字符，包括换行；没有这个标志，. 匹配除了 n r 之外的任何字符。 行内写法：(?s) Python re 模块中的常量：re.S re.DOTALL   X/VERBOSE，默认为 False\n  当该标志被指定时，Pattern 中的的空白符会被忽略，除非该空白符在圆括号或方括号中，或在反斜杠 \\ 之后。这样做的结果是允许将注释写入 Pattern，这些注释会被 Regex 解析引擎忽略。注释用 # 号来标识，不过该符号不能在字符串或反斜杠之后。 行内写法：(?x) Python re 模块中的常量：re.X re.VERBOSE   几个最常用的 Regex 以下是几个常用的 Regex，值得保存：\n  matching username\n /^[a-z0-9_-\\]{3,16}$/\n   matching password[3]\n /^[a-z0-9_-\\]{6,18}$/\n   matching a HEX value\n /^#?([a-f0-9\\]{6}|[a-f0-9]{3})$/\n   matching a slug\n /^[a-z0-9-\\]+$/\n   matching email address\n /^([a-z0-9_\\.-\\]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/\n   matching a URL\n /^(https?:\\/\\/)?([\\da-z\\.-\\]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/\n   matching an IP address\n /^(?:(?:25[0-5\\]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/\n   matching a HTML tag\n /^\u0026lt;([a-z\\]+)([^\u0026lt;]+)*(?:\u0026gt;(.*)\u0026lt;\\/\\1\u0026gt;|\\s+\\/\u0026gt;)$/\n   感谢，李笑来老师\n","id":22,"section":"posts","summary":"正则表达式本质上是个独立的语言，短小却格外强悍。 他的含义就是：我们可以书写特定的规则，用来在文本中捕获与规则一致的字符串，而后对其进行操作\u0026","tags":null,"title":"正则表达","uri":"https://xuzhihao.top/2020/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/","year":"2020"},{"content":"这需要一个comtypes的简单示例,不过这个只能用于Windows\nimport sys\rimport os\rimport comtypes.client\rwdFormatPDF = 17\rin_file = os.path.abspath(sys.argv[1])\rout_file = os.path.abspath(sys.argv[2])\rword = comtypes.client.CreateObject('Word.Application')\rdoc = word.Documents.Open(in_file)\rdoc.SaveAs(out_file, FileFormat=wdFormatPDF)\rdoc.Close()\rword.Quit()\r ","id":23,"section":"posts","summary":"这需要一个comtypes的简单示例,不过这个只能用于Windows import sys import os import comtypes.client wdFormatPDF = 17 in_file = os.path.abspath(sys.argv[1]) out_file = os.path.abspath(sys.argv[2]) word = comtypes.client.CreateObject('Word.Application') doc = word.Documents.Open(in_file) doc.SaveAs(out_file, FileFormat=wdFormatPDF) doc.Close() word.Quit()","tags":["办公自动化"],"title":"docx转为PDF","uri":"https://xuzhihao.top/2020/05/docx%E8%BD%AC%E4%B8%BApdf/","year":"2020"},{"content":"这个问题其实就是 它在路径方面出现了问题。\n文件路径输出为了D://\\\\demo,这当然是错误的了\n解决方法是\nimport os\ros.chdir(\u0026quot;E:/demo\u0026quot;)\rfile = os.getcwd()+'\\\\'+path\r ","id":24,"section":"posts","summary":"这个问题其实就是 它在路径方面出现了问题。 文件路径输出为了D://\\\\demo,这当然是错误的了 解决方法是 import os os.chdir(\u0026quot;E:/demo\u0026quot;) file = os.getcwd()+'\\\\'+path","tags":["错误记录"],"title":"Error in converting file using python COM","uri":"https://xuzhihao.top/2020/05/error-in-converting-file-using-python-com/","year":"2020"},{"content":"Python中的容器都是可迭代的，准确说，这些容器都可以通过迭代器遍历每一个元素。\n内建函数iter()就是用于把一个可迭代对象转换为迭代器。\n例如：\ni = iter(\u0026quot;Python\u0026quot;)\ri = iter((1,2,3,4))\r 使用迭代器，你需要用到next()\ni = iter('Python')\rnext(i)\rnext(i)\r 'p'\r'y'\r 这个迭代器里面有6个元素，所以next(i)在调用6次之后就不能再被调用了，一旦再被调用就会触发StopIteration错误。\n实现迭代器 class Counter(object):\rdef __init__(self,start,stop):\rself.current = start\rself.stop = stop\rdef __iter__(self):\rreturn self\rdef __next__(self):\rif self.current \u0026gt; self.stop:\rraise StopIteration\relse:\rc = self.current\rself.current += 1\rreturn c\r 这里重点是__iter__(self)、__next__(self)\ndef __iter__(self):\rreturn self\r 这两句是约定俗成的，写上它们，Counter这个类就会被识别为Iterator类型，后面再加上__next__(self)，就是一个完整的迭代器了。\n","id":25,"section":"posts","summary":"Python中的容器都是可迭代的，准确说，这些容器都可以通过迭代器遍历每一个元素。 内建函数iter()就是用于把一个可迭代对象转换为迭代器。","tags":null,"title":"Python中的迭代器","uri":"https://xuzhihao.top/2020/05/python%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/","year":"2020"},{"content":" 参考地址：https://beautifulsoup.readthedocs.io/zh_CN/\n Beautiful Soup将复杂HTML文档转化为一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种：Tag、NavigableString、BeautifulSoup、Comment。\nTag tag对象与XML或HTML原生文档中的tag相同。\nsoup = BeautifulSoup('\u0026lt;b class =\u0026quot;boldest\u0026quot;\u0026gt;Extremely blod\u0026lt;/b\u0026gt;')\rtag = soup.b\rtype(tag)\r# \u0026lt;class 'bs4.element.Tag'\u0026gt;\r Name 每个tag都有自己的名字，通过.name来获取\ntag.name = b\r#u'b'\r Attributes 一个tag可能有很多个属性.tag\u0026lt;b class=\u0026quot;blodest\u0026quot;\u0026gt;有一个“class”的属性，值为“blodest”\n从tag中获取属性的操作方法，与字典差不多。\ntag['class']\r#u'boldest'\r 也可以直接“点”取属性，比如：.attrs:\ntag.attrs\r#{u'class':u'blodest'}\r 多值属性 HTML 4定义了一系列可以包含多个值的属性.在HTML5中移除了一些,却增加更多.最常见的多值的属性是 class (一个tag可以有多个CSS的class). 还有一些属性 rel , rev , accept-charset , headers , accesskey . 在Beautiful Soup中多值属性的返回类型是list:\ncss_soup = BeautifulSoup('\u0026lt;p class=\u0026quot;body strikeout\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;')\rcss_soup.p['class']\r# [\u0026quot;body\u0026quot;, \u0026quot;strikeout\u0026quot;]\rcss_soup = BeautifulSoup('\u0026lt;p class=\u0026quot;body\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;')\rcss_soup.p['class']\r# [\u0026quot;body\u0026quot;]\r 如果某个属性看起来好像有多个值,但在任何版本的HTML定义中都没有被定义为多值属性,那么Beautiful Soup会将这个属性作为字符串返回。\nid_soup = BeautifulSoup('\u0026lt;p id=\u0026quot;my id\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;')\rid_soup.p['id']\r# 'my id'\r 将tag转换为字符串时，多值会合并为一个值。\nrel_soup = BeautifulSoup('\u0026lt;p\u0026gt;Back to the \u0026lt;a rel=\u0026quot;index\u0026quot;\u0026gt;homepage\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;')\rrel_soup.a['rel']\r# ['index']\rrel_soup.a['rel'] = ['index', 'contents']\rprint(rel_soup.p)\r# \u0026lt;p\u0026gt;Back to the \u0026lt;a rel=\u0026quot;index contents\u0026quot;\u0026gt;homepage\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\r 如果转换的文档是XML格式，那么tag不包含多值属性。\nxml_soup = BeautifulSoup('\u0026lt;p class=\u0026quot;body strikeout\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;', 'xml')\rxml_soup.p['class']\r# u'body strikeout'\r 可遍历的字符串 字符串常被包含在tag内.Beautiful Soup用 NavigableString 类来包装tag中的字符串:\ntag.string\r# u'Extremely bold'\rtype(tag.string)\r# \u0026lt;class 'bs4.element.NavigableString'\u0026gt;\r BeautifulSoup BeautifulSoup对象表示的是一个文档的全部内容。大多时候，可以把它当做tag对象，它支持遍历文档和搜索文档树从描述的大部分方法。\n因为 BeautifulSoup 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性.但有时查看它的 .name 属性是很方便的,所以 BeautifulSoup 对象包含了一个值为 “[document]” 的特殊属性 .name\n注释及特殊字符 Tag , NavigableString , BeautifulSoup 几乎覆盖了html和xml中的所有内容,但是还有一些特殊对象.容易让人担心的内容是文档的注释部分:\nmarkup = \u0026quot;\u0026lt;b\u0026gt;\u0026lt;!--Hey, buddy. Want to buy a used parser?--\u0026gt;\u0026lt;/b\u0026gt;\u0026quot;\rsoup = BeautifulSoup(markup)\rcomment = soup.b.string\rtype(comment)\r# \u0026lt;class 'bs4.element.Comment'\u0026gt;\r Comment 对象是一个特殊类型的 NavigableString 对象:\ncomment\r# u'Hey, buddy. Want to buy a used parser'\r 但是当它出现在HTML文档中时, Comment 对象会使用特殊的格式输出:\nprint(soup.b.prettify())\r# \u0026lt;b\u0026gt;\r# \u0026lt;!--Hey, buddy. Want to buy a used parser?--\u0026gt;\r# \u0026lt;/b\u0026gt;\r Beautiful Soup中定义的其它类型都可能会出现在XML的文档中: CData , ProcessingInstruction , Declaration , Doctype .与 Comment 对象类似,这些类都是 NavigableString 的子类,只是添加了一些额外的方法的字符串独享.下面是用CDATA来替代注释的例子:\nfrom bs4 import CData\rcdata = CData(\u0026quot;A CDATA block\u0026quot;)\rcomment.replace_with(cdata)\rprint(soup.b.prettify())\r# \u0026lt;b\u0026gt;\r# \u0026lt;![CDATA[A CDATA block]]\u0026gt;\r# \u0026lt;/b\u0026gt;\r 遍历文档树 html_doc = \u0026quot;\u0026quot;\u0026quot;\r\u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;The Dormouse's story\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p class=\u0026quot;title\u0026quot;\u0026gt;\u0026lt;b\u0026gt;The Dormouse's story\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;p class=\u0026quot;story\u0026quot;\u0026gt;Once upon a time there were three little sisters; and their names were\r\u0026lt;a href=\u0026quot;http://example.com/elsie\u0026quot; class=\u0026quot;sister\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;,\r\u0026lt;a href=\u0026quot;http://example.com/lacie\u0026quot; class=\u0026quot;sister\u0026quot; id=\u0026quot;link2\u0026quot;\u0026gt;Lacie\u0026lt;/a\u0026gt; and\r\u0026lt;a href=\u0026quot;http://example.com/tillie\u0026quot; class=\u0026quot;sister\u0026quot; id=\u0026quot;link3\u0026quot;\u0026gt;Tillie\u0026lt;/a\u0026gt;;\rand they lived at the bottom of a well.\u0026lt;/p\u0026gt;\r\u0026lt;p class=\u0026quot;story\u0026quot;\u0026gt;...\u0026lt;/p\u0026gt;\r\u0026quot;\u0026quot;\u0026quot;\rfrom bs4 import BeautifulSoup\rsoup = BeautifulSoup(html_doc, 'html.parser')\r 子节点 一个tag可能包含多个字符串或其他的Tag，这些都是这个Tag的子节点。\ntag名字 操作文档树最简单的方法就是告诉它你想获取的tag的name.如果想获取 标签,只要用 soup.head :\nsoup.head\r# \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;The Dormouse's story\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\rsoup.title\r# \u0026lt;title\u0026gt;The Dormouse's story\u0026lt;/title\u0026gt;\r 这是个获取tag的小窍门,可以在文档树的tag中多次调用这个方法.下面的代码可以获取标签中的第一个标签:\nsoup.body.b\r# \u0026lt;b\u0026gt;The Dormouse's story\u0026lt;/b\u0026gt;\r 通过点取属性的方式只能获得当前名字的第一个tag:\nsoup.a\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/elsie\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;\r 如果想要得到所有的标签,或是通过名字得到比一个tag更多的内容的时候,就需要用到 Searching the tree 中描述的方法,比如: find_all()\n.contents 和 .children tag的 .contents 属性可以将tag的子节点以列表的方式输出:\nhead_tag = soup.head\rhead_tag\r# \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;The Dormouse's story\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\rhead_tag.contents\r[\u0026lt;title\u0026gt;The Dormouse's story\u0026lt;/title\u0026gt;]\rtitle_tag = head_tag.contents[0]\rtitle_tag\r# \u0026lt;title\u0026gt;The Dormouse's story\u0026lt;/title\u0026gt;\rtitle_tag.contents\r# [u'The Dormouse's story']\r BeautifulSoup 对象本身一定会包含子节点,也就是说标签也是 BeautifulSoup 对象的子节点:\nlen(soup.contents)\r# 1\rsoup.contents[0].name\r# u'html'\r 字符串没有 .contents 属性,因为字符串没有子节点:\ntext = title_tag.contents[0]\rtext.contents\r# AttributeError: 'NavigableString' object has no attribute 'contents'\r 通过tag的 .children 生成器,可以对tag的子节点进行循环:\nfor child in title_tag.children:\rprint(child)\r# The Dormouse's story\r CSS选择器 Beautiful Soup支持大部分的CSS选择器，在Tag或BeautifulSoup对象的.select()方法中传入字符串参数，即可使用CSS选择器的语法找到tag。\nsoup.select(\u0026quot;title\u0026quot;)\r# [\u0026lt;title\u0026gt;The Dormouse's story\u0026lt;/title\u0026gt;]\rsoup.select(\u0026quot;p nth-of-type(3)\u0026quot;)\r# [\u0026lt;p class=\u0026quot;story\u0026quot;\u0026gt;...\u0026lt;/p\u0026gt;]\r 通过tag标签逐层查找:\nsoup.select(\u0026quot;body a\u0026quot;)\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/elsie\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/lacie\u0026quot; id=\u0026quot;link2\u0026quot;\u0026gt;Lacie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/tillie\u0026quot; id=\u0026quot;link3\u0026quot;\u0026gt;Tillie\u0026lt;/a\u0026gt;]\rsoup.select(\u0026quot;html head title\u0026quot;)\r# [\u0026lt;title\u0026gt;The Dormouse's story\u0026lt;/title\u0026gt;]\r 找到某个tag标签下的直接子标签 [6] :\nsoup.select(\u0026quot;head \u0026gt; title\u0026quot;)\r# [\u0026lt;title\u0026gt;The Dormouse's story\u0026lt;/title\u0026gt;]\rsoup.select(\u0026quot;p \u0026gt; a\u0026quot;)\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/elsie\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/lacie\u0026quot; id=\u0026quot;link2\u0026quot;\u0026gt;Lacie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/tillie\u0026quot; id=\u0026quot;link3\u0026quot;\u0026gt;Tillie\u0026lt;/a\u0026gt;]\r 通过限定ID的值\nsoup.select(\u0026quot;p \u0026gt; #link1\u0026quot;) # [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/elsie\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;]\r \rsoup.select(\u0026quot;p \u0026gt; a:nth-of-type(2)\u0026quot;)\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/lacie\u0026quot; id=\u0026quot;link2\u0026quot;\u0026gt;Lacie\u0026lt;/a\u0026gt;]\rsoup.select(\u0026quot;body \u0026gt; a\u0026quot;)\r# []\r 找到兄弟节点标签:\nsoup.select(\u0026quot;#link1 ~ .sister\u0026quot;)\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/lacie\u0026quot; id=\u0026quot;link2\u0026quot;\u0026gt;Lacie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/tillie\u0026quot; id=\u0026quot;link3\u0026quot;\u0026gt;Tillie\u0026lt;/a\u0026gt;]\rsoup.select(\u0026quot;#link1 + .sister\u0026quot;)\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/lacie\u0026quot; id=\u0026quot;link2\u0026quot;\u0026gt;Lacie\u0026lt;/a\u0026gt;]\r 通过CSS的类名查找:\nsoup.select(\u0026quot;.sister\u0026quot;)\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/elsie\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/lacie\u0026quot; id=\u0026quot;link2\u0026quot;\u0026gt;Lacie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/tillie\u0026quot; id=\u0026quot;link3\u0026quot;\u0026gt;Tillie\u0026lt;/a\u0026gt;]\rsoup.select(\u0026quot;[class~=sister]\u0026quot;)\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/elsie\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/lacie\u0026quot; id=\u0026quot;link2\u0026quot;\u0026gt;Lacie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/tillie\u0026quot; id=\u0026quot;link3\u0026quot;\u0026gt;Tillie\u0026lt;/a\u0026gt;]\r 通过tag的id查找:\nsoup.select(\u0026quot;#link1\u0026quot;)\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/elsie\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;]\rsoup.select(\u0026quot;a#link2\u0026quot;)\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/lacie\u0026quot; id=\u0026quot;link2\u0026quot;\u0026gt;Lacie\u0026lt;/a\u0026gt;]\r 同时用多种CSS选择器查询元素:\nsoup.select(\u0026quot;#link1,#link2\u0026quot;)\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/elsie\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/lacie\u0026quot; id=\u0026quot;link2\u0026quot;\u0026gt;Lacie\u0026lt;/a\u0026gt;]\r 通过是否存在某个属性来查找:\nsoup.select('a[href]')\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/elsie\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/lacie\u0026quot; id=\u0026quot;link2\u0026quot;\u0026gt;Lacie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/tillie\u0026quot; id=\u0026quot;link3\u0026quot;\u0026gt;Tillie\u0026lt;/a\u0026gt;]\r 通过属性的值来查找:\nsoup.select('a[href=\u0026quot;http://example.com/elsie\u0026quot;]')\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/elsie\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;]\r 属性的前半部分：\nsoup.select('a[href^=\u0026quot;http://example.com/\u0026quot;]')\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/elsie\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/lacie\u0026quot; id=\u0026quot;link2\u0026quot;\u0026gt;Lacie\u0026lt;/a\u0026gt;,\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/tillie\u0026quot; id=\u0026quot;link3\u0026quot;\u0026gt;Tillie\u0026lt;/a\u0026gt;]\r 属性的中间部分：\nsoup.select('a[href*=\u0026quot;.com/el\u0026quot;]')\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/elsie\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;]\r 属性的后半部分：\nsoup.select('a[href$=\u0026quot;tillie\u0026quot;]')\r# [\u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/tillie\u0026quot; id=\u0026quot;link3\u0026quot;\u0026gt;Tillie\u0026lt;/a\u0026gt;]\r 通过语言设置来查找:\nmultilingual_markup = \u0026quot;\u0026quot;\u0026quot;\r\u0026lt;p lang=\u0026quot;en\u0026quot;\u0026gt;Hello\u0026lt;/p\u0026gt;\r\u0026lt;p lang=\u0026quot;en-us\u0026quot;\u0026gt;Howdy, y'all\u0026lt;/p\u0026gt;\r\u0026lt;p lang=\u0026quot;en-gb\u0026quot;\u0026gt;Pip-pip, old fruit\u0026lt;/p\u0026gt;\r\u0026lt;p lang=\u0026quot;fr\u0026quot;\u0026gt;Bonjour mes amis\u0026lt;/p\u0026gt;\r\u0026quot;\u0026quot;\u0026quot;\rmultilingual_soup = BeautifulSoup(multilingual_markup)\rmultilingual_soup.select('p[lang|=en]')\r# [\u0026lt;p lang=\u0026quot;en\u0026quot;\u0026gt;Hello\u0026lt;/p\u0026gt;,\r# \u0026lt;p lang=\u0026quot;en-us\u0026quot;\u0026gt;Howdy, y'all\u0026lt;/p\u0026gt;,\r# \u0026lt;p lang=\u0026quot;en-gb\u0026quot;\u0026gt;Pip-pip, old fruit\u0026lt;/p\u0026gt;]\r 返回查找到的元素的第一个\nsoup.select_one(\u0026quot;.sister\u0026quot;)\r# \u0026lt;a class=\u0026quot;sister\u0026quot; href=\u0026quot;http://example.com/elsie\u0026quot; id=\u0026quot;link1\u0026quot;\u0026gt;Elsie\u0026lt;/a\u0026gt;\r 对于熟悉CSS选择器语法的人来说这是个非常方便的方法.Beautiful Soup也支持CSS选择器API, 如果你仅仅需要CSS选择器的功能,那么直接使用 lxml 也可以, 而且速度更快,支持更多的CSS选择器语法,但Beautiful Soup整合了CSS选择器的语法和自身方便使用API.\n[refer] https://beautifulsoup.readthedocs.io/zh_CN/\n","id":26,"section":"posts","summary":"参考地址：https://beautifulsoup.readthedocs.io/zh_CN/ Beautiful Soup将复杂HTML文档转化为一个复杂的","tags":["爬虫"],"title":"爬虫——BeautifulSoup","uri":"https://xuzhihao.top/2020/05/%E7%88%AC%E8%99%ABbeautifulsoup/","year":"2020"},{"content":"Python中，每个类都有实例属性。默认情况下Python用一个字典来保存一个对象的实例属性。这样，它允许我们再运行时取设置任意的新属性。\n然而，对于已知属性的小类来说，他可能是个瓶颈。这个字典浪费很多内存。Python不能在对象创建时直接分配一个固定量的内存来保存所有的属性。因此如果你创建许多对象，他会消耗掉很多内存。\n__slot__可以告诉Python不要使用字典，而且只给一个固定集合属性分配空间。\n 不使用__slots__:  class MyClass(object):\rdef __init__(self,name,identifier):\rself.name = name\rself.identifier = identifier\rself.set_up()\r...\r  使用__slot__:  class MyClass(object):\r__slot__ = ['name','identifer']\rdef __init__(self,name,identifier):\rself.name = name\rself.identifier = identifier\rself.set_up()\r...\r 如果你想有一个固定集合属性分配空间，那你就需要这样做：\n__slot__ = ('x','y')\r __slots__ 设置了一个元组，来限制类能添加的属性。现在，如果我们想绑定一个新的属性，比如 z，就会出错了.\n注意：\n slots 魔法：限定允许绑定的属性. __slots__ 设置的属性仅对当前类有效，对继承的子类不起效，除非子类也定义了 slots，这样，子类允许定义的属性就是自身的 slots 加上父类的 slots。  ","id":27,"section":"posts","summary":"Python中，每个类都有实例属性。默认情况下Python用一个字典来保存一个对象的实例属性。这样，它允许我们再运行时取设置任意的新属性。 然","tags":["Python魔法方法"],"title":"Python中__slots__","uri":"https://xuzhihao.top/2020/05/python%E4%B8%AD__slots__/","year":"2020"},{"content":"Python中的协程和生成器相似但又有不同。主要区别在于：\n 生成器是数据的生成器 协程则是数据的消费者  首先，我们先来回顾下生成器的创建过程。\ndef fib():\ra,b = 0,1\rwhile True:\ryield a\ra,b = b,a+b\r 使用的方法就是：\nfor i in fib():\rprint(i)\r 这样做不仅快，而且不会给内存带来压力，因为我们所需要的值都是动态生成的而不是将他们存储在一个列表中。更概括的说如果现在我们在上面的例子中使用yield便可获得一个协程。协程会消费掉发送给它的值。\ndef grep(pattern):\rprint(\u0026quot;Searching for \u0026quot;,pattern)\rwhile True:\rline = (yield)\rif pattern in line:\rprint(line)\r yield将不会包含任何初值，它需要从外部传值给它，我们可以用send()方法向他传值。\nsearch = grep('coroutine')\rnext(search)\rsearch.send(\u0026quot;I love you\u0026quot;)\rsearch.send(\u0026quot;Don't you love me?\u0026quot;)\rsearch.send(\u0026quot;I Love coroutine instead!\u0026quot;)\r#output:I Love coroutine instead!\r 这里，next()方法就是启动一个协程。因为协程中包含的生成器并不是立刻执行，而是通过next()方法来响应send()方法。\n所以，要用next()方法来执行yield表达式。\n可以通过调用close()来关闭一个协程。\n","id":28,"section":"posts","summary":"Python中的协程和生成器相似但又有不同。主要区别在于： 生成器是数据的生成器 协程则是数据的消费者 首先，我们先来回顾下生成器的创建过程。 def fib():","tags":null,"title":"Python中的协程","uri":"https://xuzhihao.top/2020/05/python%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/","year":"2020"},{"content":"生成器的实现需要yield。\n例如这样：\ndef counter(start,stop):\rwhile start\u0026lt;=stop:\ryield start\rstart += 1\rfor i in counter(101,105):\rprint(i)\r yield和return最明显的区别是yield之后的语句可以被执行，而return后面语句会被忽略。\n并且，生成器也是一种迭代器，但是你只能对其迭代一次。这是因为他们并没有把所有的值存在内存中，而是运行时生成值。\n生成器被next()调用后，执行yield语句并生成一个值返回（然后，继续执行next()之外的语句）。下次，再被next()调用的时候，将从上次生成返回值yield语句处继续执行。\n在yield掉所有的值后，next()触发了⼀个StopIteration的异常。 基本上这个异常告诉我们，所有的值都已经被yield完了。你也许会奇怪，为什么我们在使⽤for循环时没有这个异常呢？答案很简单。for循环会⾃动捕捉到这个异常并停⽌调⽤next()。\n","id":29,"section":"posts","summary":"生成器的实现需要yield。 例如这样： def counter(start,stop): while start\u0026lt;=stop: yield start start += 1 for i in counter(101,105): print(i) yield和return最明显的区别是yield之后的语句可以被执行，而r","tags":null,"title":"Python中的生成器","uri":"https://xuzhihao.top/2020/05/python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8/","year":"2020"},{"content":"使用范本： from functools import wraps\rdef decorator_name(f):\r@wraps(f)\rdef decorated(*args,**kwargs):\rif not can_run:\rreturn \u0026quot;Function will not run\u0026quot;\rreturn decorated\r@decorator_name\rdef func():\rreturn(\u0026quot;Function is running\u0026quot;)\rcan_run - True\rprint(func())\rcan_run = False\rprint(func())\r 注意：@wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。\n不然，被装饰的函数，它的函数名称已经不是原来的名称了。\n使用场景 授权 from functools import wraps\rdef requires_auth(f):\r@wraps(f)\rdef decorated(*args,**kwargs):\rauth = request.authorization\rif not auth or not check_auth(auth,username,auth.password):\rreutrn f(*args,**kwargs)\rreturn decorated\r 日志 from functools import wraps\rdef logit(logfile='out.log'):\rdef logging_decorator(func):\r@wraps(func)\rdef wrapped_function(*args,**kwargs):\rlog_string = func.__name__ + \u0026quot; was called\u0026quot;\rprint(log_string)\rwith open(logfile,'a') as opened_file:\ropened_file.write(log_string + '\\n')\rreturn func(*args,**kwargs)\rreturn wrapped_function\rreturn logging_decorator\r@logit()\rdef myfunc1():\rpass\rmyfunc1()\r# Output: myfunc1 was called\r# 现在⼀个叫做 out.log 的⽂件出现了，⾥⾯的内容就是上⾯的字符串\r 升级一下日志 from functools import wraps\rclass logit(object):\rdef __init__(self,logfile='out.log'):\rself.logfile = logfile\rdef __call__(self,func):\r@wraps(func)\rdef wrapped_function(^args,**kwargs):\rlog_string = func.__name__+\u0026quot; was called\u0026quot;\rprint(log_string)\rwith open(self,logfile,'a') as opened_file:\ropened_file.write(log_string+'\\n')\r#发送一个通知。\rself.notify()\rreturn func(*args,**kwargs)\rreturn wrapped_function\rdef notify(self):\rpass\r 如果要添加email这个功能，可以使用继承：\nclass email_logit(logit):\rdef __init__(self,email='XXX',*args,**kwargs):\rself.email = email\rsuper(logit,self).__init__(*args,**kwargs)\rdef notify(self):\r#这里发送一封email\rpass\r ","id":30,"section":"posts","summary":"使用范本： from functools import wraps def decorator_name(f): @wraps(f) def decorated(*args,**kwargs): if not can_run: return \u0026quot;Function will not run\u0026quot; return decorated @decorator_name def func(): return(\u0026quot;Function is running\u0026quot;) can_run - True print(func()) can_run = False print(func()) 注意：@wraps接受一个函数来进行装饰，并加入了复制函数名称、","tags":null,"title":"Python中的装饰器(2)","uri":"https://xuzhihao.top/2020/05/python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A82/","year":"2020"},{"content":"原文链接：https://realpython.com/intermediate-pythonproject-ideas/\nWeb 项目设计 内容聚合器（Content Aggregator） ****1. 技术细节****该项目设计的主要目标是聚合内容。首先，我们需要知道内容聚合器从哪些站点获取内容。然后，使用请求库来发送 HTTP 请求，并使用 BeautifulSoup 解析和抓取站点的必要内容。 该应用程序可以将其内容聚合作为后台进程进行实现。celery 或 apscheduler 等库可以提供帮助。建议尝试 apscheduler。它非常适用于小型后台进程。 从各个站点抓取的内容需要进行保存。因此，需要使用数据库。 ****2. 额外挑战****对于更严峻的挑战，可以通过以下网站进行学习并获得更多信息：https://realpython.com/python-web-scraping-practical-introduction/ 还可以在网站上订阅内容聚合文章。每天结束时，内容聚合器会将当天的文章发送到用户的电子邮箱。\n正则表达式查询工具 ****1. 技术细节****这类项目的主要目的是判别用户输入的查询字符串的有效性。可以让它给出有效和无效的判别，例如「查询字符串有效」和「查询字符串无效」，以绿色显示有效，以红色显示无效。 不必从头开始构造查询工具。使用 Python 的标准 relibrary，就可以对输入的文本运行查询字符串。当查询字符串不匹配时，re 库将返回 None，当匹配时，将返回匹配的字符串。 有些用户可能无法完全理解正则表达式，因此读者可以自己创建一个页面来解释正则表达式的工作原理。写一个足够有趣的文档，让用户对学习和理解正则表达式产生兴趣。 ****2. 额外挑战****制作一个只返回正则表达式有效性的项目很好。但也可以添加替换功能。这意味着应用程序将检查正则表达式的有效性，并允许用户用其他内容替换匹配的字符串。因此，该工具不再只是查询工具，也成为了替换工具。 网址缩短（URL Shortener） ***1. 技术细节***该项目设计的主要目标是缩短 URL。应用程序在缩短 URL 后，再访问缩短的 URL 时将用户重定向到原始 URL。 在应用程序中，用户将输入原始 URL，最后获得新的缩短 URL。为此，可以使用 random 和 string 模块的组合来生成缩短版 URL 的字符。 由于用户将在几天、几个月甚至几年后访问缩短的 URL，因此需要将原始 URL 和缩短的 URL 保存在数据库中。当出现请求时，应用程序会检查 URL 是否存在并重定向到原始 URL，否则会重定向到 404 页面。 ****2. 额外挑战****使用随机字符生成缩短 URL 比长且随机字符的 URL 更好。通过添加功能来自定义 URL，用户就可以自定义生成的 URL。 毫无疑问，自定义 xyz.com/mysite URL 比随机生成的 xyz.com/piojwr URL 更好。\n便利贴功能 ****1. 技术细节****该项目的主要目的是让用户记下自己的想法。即每个用户都有自己的笔记，因此应用程序需要具有帐户创建功能。这确保了每个用户的笔记都是私人的。 django 带有用户身份验证系统，因此它可能是一个不错的选择。你可以使用其他框架，如 bottle 和 flask，但你必须自己实现用户身份验证系统。 由于用户可能需要在不同情境下记录不同的笔记，因此实现用户的笔记分类功能将使应用程序更实用。 例如，你可能需要记录一些算法和数据结构，因此需要将不同的笔记划分到各自类别中。 你需要存储每个用户的信息和笔记，因此数据库成为该项目的重要组成部分。如果想使用 MySQL 数据库或用于 PostgreSQL 数据库的 psycopg2 模块，可以使用 MySQLdb 模块。还可以使用其他模块，但这完全取决于你选择使用的数据库。 ****2. 额外挑战****用户忘记自己的想法是人之常情，甚至有时会忘记自己记了笔记。你可以添加一个功能，提醒用户他们记了笔记。此功能允许用户设置提醒时间，应用程序将通过电子邮件提醒用户。\n测验 ****1. 技术细节****这个项目的主要目标是设置测验并让人们作答。因此，用户应该能够设置问题，其他用户应该能够回答这些问题。然后，应用程序将显示最终得分和正确答案。 如果希望用户能够记录他们的分数，则需要实现帐户创建功能。 创建测试的用户应该能够通过上传文本文件来创建带有问题和答案的测试。文本文件应该能够转换成用户需要的格式，因此应用程序可以将文件转换为测验格式。 你还需要为此项目创建数据库。数据库将存储每个用户的问题、可能的答案、正确的答案和分数。 ****2. 额外挑战****可以允许用户在测验中添加计时器。这样，测验的创建者可以确定用户在测验中的每个问题上花多长时间。 同时拥有测验分享功能也很棒，这样用户可以在其他平台上与朋友分享有趣的测验。\nGUI 项目设计 MP3 播放器 ****1. 技术细节****该项目的主要目标是允许用户播放 MP3 和数字音频文件。为了吸引用户，应用程序必须具有简单但美观的用户界面。 可以添加一个能列出可用 MP3 文件的界面。还可以为用户列出其他非 MP3 的数字音频文件。 用户还希望 MP3 播放器具有显示正在播放的文件信息的界面。其中可以包括文件名、长度、播放时长以及未播放时长（以分钟和秒为单位）。 Python 具有可以播放音频文件的库，如 pygame，使用几行代码即可处理多媒体文件。还可以查看 pymedia（https://pypi.org/project/PyMedia/）和 simpleaudio。 这些库可以处理大量的数字音频文件。包括 MP3 文件和其他格式的音频文件。 此外，这些库还有允许用户创建播放列表的功能。为此，需要一个数据库来存储创建的播放列表的信息。Python 的 sqlite3 模块允许使用 SQLite 数据库。 在这种情况下，SQLite 数据库是更好的选择，因为它是基于文件的，并且比其他 SQL 数据库更容易设置。虽然 SQLite 是基于文件的，但它能比常规文件更好地保存数据。 ****2. 额外挑战****如果上面的都做到了，你还可以添加一项功能，以允许 MP3 播放器重复播放当前正在播放的文件，甚至可以实现随机播放。 还可以添加增加和降低音频文件播放速度的功能。用户会很喜欢这一功能，因为他们能够以比平时更慢或更快的速度播放音频文件。\n闹铃提醒工具 ****1. 技术细节****该项目的主要目标是在一天中的特定时间激活音频信号。因此，定时和音频信号播放是闹铃工具中最重要的部分。 闹铃工具应允许用户创建、编辑和删除闹铃。它还应该有一个能列出所有未被删除的闹铃界面。因此，它应列出活动闹铃和闲置闹铃。 由于它是一个闹铃，应用程序必须在规定的时间播放音频。用于播放音频的库有 pygame 库等。 在代码逻辑中，应用程序必须不断检查设置的闹铃时间。到达时间后，它会触发一个播放闹钟铃声的功能。 由于应用程序将检查设置的闹铃时间，这意味着应用程序必须将其保存在数据库中。数据库应存储闹铃日期、时间和音频等内容。 ****2. 额外挑战****你也可以允许用户设置定期闹铃。用户能够设置在每周的某些日子、特定时间响铃。例如，可以在每个星期一下午 2:00 设置闹铃。 还可以添加暂停功能，以便用户可以暂停闹钟而不是解除闹钟。\n文件管理器 ****1. 技术细节****文件管理器项目的主要目标是为用户提供管理文件的界面。用户需要一个易上手又实用的文件管理器。 可以使用 PySimpleGUI 库创建具有一个功能强大的由小部件组成的用户界面，该界面也无需处理大量复杂工作。 用户应该能够完成一些简单的任务，如创建新目录或空文本文件。还应该能够复制和移动文件或目录。 sys、os 和 shutil 库对此项目非常有用，它们可用于在用户点击时对后台文件执行操作。 网格视图和列表视图是目前比较受欢迎的视图，因此你可以在应用程序中实现这两种视图。用户可以选择适合他们的视图选项。 ****2. 额外挑战****要使文件管理器更高级，可以加入搜索功能。用户无需手动查找即可搜索文件和目录。 此外，还可以实现排序功能。用户根据不同的顺序对文件进行排序，例如时间、字母顺序或大小。\n记账功能 ****1. 技术细节****该项目的主要目标是跟踪用户的支出。为了向用户提供正确信息，并帮助他们优化支出，需要进行一些统计分析。 虽然跟踪费用是关键，但良好的界面也很重要。使用 PySimpleGUI，你可以创建一个独特的界面来改善用户体验。 诸如 pandas 和 matplotlib 之类的 PyData 库可以帮助设计记账工具。 pandas 库可用于数据分析，matplotlib 库可用于绘制图形。图表将为用户提供其支出的直观表示，并且可视化通常更容易理解。 应用程序将从用户那里获得数据。这里的数据是输入的支出。因此，费用需要存储在数据库中。SQLite 数据库是该项目的一个很好的选择，因为它可以快速设置。可以将 sqlite3 模块用于 SQLite 数据库。 ****2. 额外挑战****为了让用户从这个项目中受益，他们需要在应用程序中定期输入自己的支出，但人们可能经常遗忘。所以添加一个提醒功能很有效。如此一来，应用程序就会在每天或每周的特定时间发送通知，提醒用户们使用记账工具。\n命令行项目设计 通讯录 ****1. 技术细节****该项目的主要目标是保存联系方式。设置可以让用户输入联系人详细信息的命令非常重要。可以使用 argparse 或 clickcommand-line 框架。它们简化了很多复杂的东西，所以你只需要关注执行命令时要运行的逻辑即可。 此外，还有一些功能需要实现，如删除联系人、更新联系人信息和列出已保存联系人。还可以允许用户使用不同顺序列出联系人，例如字母顺序或联系人创建日期。 它是一个命令行项目，用 SQLite 数据库就可以很好地保存联系人。SQLite 的设置非常友好。你可以将联系人详细信息保存在文件中，但文件不会具有 SQLite 的优势，例如更好的性能和安全性。 要在此项目中使用 SQLite 数据库，Python sqlite3 模块将非常有用。 ****2. 额外挑战****还记得数据库是如何存储在用户的计算机上的吗？如果用户文件丢失了会怎么样？这意味着他们也会失去联系方式。 进一步的挑战是将数据库备份到在线存储平台。为此，可以按特定间隔将数据库文件上传到云。 还可以添加允许用户自己备份数据库的命令。这样，如果数据库文件丢失，用户仍然可以访问联系人。 应该注意，你可能需要某种形式的标识，这样通讯录就可以识别哪个数据库文件属于哪个用户。实现用户身份验证功能是实现此功能的一种方法。\n网站连接检查 ****1. 技术细节****该项目的主要目标是检查网站的状态。因此需要编写用于检查网站状态的代码。 你可以选择使用 TCP 或 ICMP 进行连接。socket 模块是用于检查的模块。还可以阅读 Python 指南中的 socket 编程。 无论是 docopt、click 还是 argparse 框架，都可以添加命令，从而允许用户在要检查的网站列表中添加和删除某网站。 用户还应该能够启动工具、停止工具并确定间隔。 由于必须保存要检查的文件列表，因此我们可以将其保存在文件（只是网站列表）中，也可以通过 sqlite3 模块使用 SQLite 数据库。 ****2. 额外挑战****该应用程序也可以检查站点的连接状态，并将结果显示在命令行中。但这要求用户继续检查命令行。 也可以增加通知功能。通知功能可以在站点状态发生变化时，在后台通过声音提醒用户。你需要一个数据库来存储网站的先前状态。这是该工具可以判断状态何时发生变化的唯一方式。\n批量文件重命名工具 ****1. 技术细节****这个项目的主要目标是重命名文件。因此，应用程序需要找到一种操作目标文件的方法。os、sys 和 shutil 库对这个项目很有用。 你的用户将能够使用命名约定重命名目录中的所有文件。因此，他们应该能够自主制定命名约定。如果你了解正则表达式的工作原理，那么 regex 模块能辅助匹配所需的命名模式。 用户可能希望传递命名约定（例如 myfiles）作为命令的一部分，并期望该工具能重命名所有文件，如 myfilesXYZ，其中 XYZ 是数字。他们还应该能够选择要重命名的文件所在的目录。 ****2. 额外挑战****该项目的主要挑战是重命名目录中的所有文件。但是用户可能只需要命名一定数量的文件。因此你可以实现一项功能，允许用户选择要重命名的文件数，而不是所有文件。 请注意，仅重命名一定数量的文件将需要该工具根据字母顺序、文件创建时间或文件大小对文件进行排序，具体取决于用户的要求。\n目录树生成器 ****1. 技术细节****目录树生成器的主要目标是可视化文件和目录之间的关系。os 库在列出目录和所选目录中的文件时非常有用。 诸如 docopt 或 argparse 之类的框架能简化很多内容，使你可以专注于为应用程序的逻辑编写代码。 在应用程序的逻辑中，你可以决定如何表示文件或目录。使用不同的颜色是一个很好的方法。你可以使用 colored 库以不同颜色打印文件和目录。 还应该可以设定目录树生成器的深度。例如，如果一个目录的子目录有 12 级，而你只需要用到第五级。 如果你愿意，还可以让用户自主决定目录树生成器的深度。 ****2. 额外挑战****由于生成的目录树结果将出现在命令行上，因此可以更进一步，让生成器创建目录树的图像，即实现文本转图像的操作。 pillow (https://pillow.readthedocs.io/en/stable/) 库对此非常有用。\n","id":31,"section":"posts","summary":"原文链接：https://realpython.com/intermediate-pythonproject-ideas/ Web 项目设计 内容聚合","tags":null,"title":"【转】13个好玩的Python练手项目","uri":"https://xuzhihao.top/2020/05/%E8%BD%AC13%E4%B8%AA%E5%A5%BD%E7%8E%A9%E7%9A%84python%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE/","year":"2020"},{"content":"当你运行独立的程序时，你的计算机就会生产一个简单的进程。他使用系统的资源（CPU、内存、硬盘存储）和你运行操作系统中的数据结构。\n你的计算机看起来能够多程序同时运行，其实，它是不同的程序不断运行、不断切换，看起来好像是同时运行，其实每时刻只运行一个程序。\n你可以从你的计算机中获得进程的数据。Python的标准库OS就可以提供关于系统的信息。例如这样：\n\u0026gt;\u0026gt;\u0026gt;import os\r\u0026gt;\u0026gt;\u0026gt;os.getpid() #获得进程的ID\r76051\r\u0026gt;\u0026gt;\u0026gt;os,getcwd() #现在运行的Python解释器的工作路径\r'/Users/wil'\r 通过multiprocessing创建进程 通过multiprocessing模块，可以将一些任务分配给多个进程，这样更节省时间。当然这就包括了，排队时间、使进程之间能够通信、等待所有过程完成。\n例如这样：\nimport multiprocessing\rimport os\rdef do_this(what):\rwhoami(what)\rdef whoami(what):\rprint(\u0026quot;Process %s says:%s\u0026quot;%(os.getid(),what))\rif __name__ == \u0026quot;__main__\u0026quot;:\rwhoami(\u0026quot;I am the main program\u0026quot;)\rfor n in range(4):\rp = multiprocessing.Process(target=do_this,args=(\u0026quot;I'm function %s\u0026quot;%n))\rp.start()\r 通过terminate()结束进程 如果你创建了一个或更多的进程，但是因为某些过程你想去结束这些进程，你可以用terminate()\n例如：\nimport multiprocessing\rimport os\rimport time\rdef whoami(what):\rprint(\u0026quot;I'm %s ,in process %s\u0026quot;%(what,os.getpid()))\rdef loopy(name):\rwhoami(name)\rstart = 1\rstop = 100000\rfor num in range(start,stop):\rprint(\u0026quot;\\t Number %s of %s .Hok!\u0026quot;%(num,stop))\rtime.sleep(1)\rif __name__ == \u0026quot;__main__\u0026quot;:\rwhoami(\u0026quot;main\u0026quot;)\rp = multiprocessing.Process(target=loopy,args=(\u0026quot;loopy\u0026quot;,))\rp.start()\rtime.sleep(5)\rp.terminate()\r ","id":32,"section":"posts","summary":"当你运行独立的程序时，你的计算机就会生产一个简单的进程。他使用系统的资源（CPU、内存、硬盘存储）和你运行操作系统中的数据结构。 你的计算机看","tags":[""],"title":"Python中的进程(1)","uri":"https://xuzhihao.top/2020/05/python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B/","year":"2020"},{"content":"使用pyautogui模块。\n 在Windows上，不需要安装其他模块。 在OS X上，运行sudo pip3 install pyobjc-framework-Quartz，sudo pip3 install pyobjc-core，然后sudo pip3 install pyobjc。 在Linux上，运行sudo pip3 install python3-xlib，sudo apt-get install scrot，sudo apt-get install python3-tk，以及sudo apt-get install python3-dev（Scrot是PyAutoGUI使用的屏幕快照程序）。  在这些依赖安装后，运行pip install pyautogui（或在OS X和Linux上运行pip3），安装pyautogui。\n首先 首先，需要知道计算机屏幕的坐标系统。分辨率是屏幕的宽高有多少像素。如果屏幕的分辨率设置为1920×1080，那么左上角的坐标是(0,0)，右下角的坐标是(1919,1079)\npyautogui.size()返回两个整数元组，包含屏幕的宽和高的像素数。\n移动鼠标 pyautogui.moveTo() 将鼠标立即移动到屏幕的指定位置。\n表示x、y坐标的整数值分别构成了函数的第一个和第二个参数。可选的duration整数或浮点数关键字参数，指定了将鼠标移到目的位置所需的秒数。如果不指定，默认值是零，表示立即移动（在PyAutoGUI函数中，所有的duration关键字参数都是可选的）。在交互式环境中输入以下内容：\n\u0026gt;\u0026gt;\u0026gt; import pyautogui\r\u0026gt;\u0026gt;\u0026gt; for i in range(10):\rpyautogui.moveTo(100, 100, duration=0.25)\rpyautogui.moveTo(200, 100, duration=0.25)`\r pyautogui.moveRel() 相当于当前位置移动鼠标。\npyautogui.moveRel() 也接受3个参数：向右水平移动多少个像素，向下垂直移动多少个像素，以及（可选的）花多少时间完成移动。为第一第二个参数提供负整数，鼠标将向左或向上移动。\npyautogui.moveRel(0, -100, duration=0.25)\r 获取鼠标位置pyautogui.position() import pyautogui.position()\r 可以确定鼠标当前的位置。它将返回函数调用时，鼠标x、y坐标的元组。\n控制鼠标交互 点击鼠标 要向计算机发送虚拟的鼠标点击，就调用pyautogui.click() 方法。默认情况下，点击将使用鼠标左键，点击发生在鼠标当前所在位置。如果希望点击在鼠标当前位置以外的地方发生，可以传入x、y坐标作为可选的第一第二参数。\n指定鼠标按键 通过加入button关键字参数，值分别为\u0026rsquo;left\u0026rsquo;、\u0026lsquo;middle'或\u0026rsquo;right\u0026rsquo;。\n例如：\npyautogui.click(100,150,button='left')\r 双击鼠标：pyautogui.doubleClick()执行双击鼠标左键，pyautogui.rightClick()执行双击鼠标右键，pyautogui.middleClick()执行双击中键。\n拖动鼠标 这是移动鼠标，同时按住一个键不放。\n有pyautogui.dragTo()将鼠标拖到一个新位置和pyautogui.dragRel()拖动鼠标移动到相对当前位置的位置。\n参数：x坐标/水平移动，y坐标/垂直移动和可选的时间间隔\n滚动鼠标 使用scoll()，它需要一个整数参数，说明向上或向下滚动多少单位。传递正整数表示向上滚动，传递负整数表示向下滚动。\n处理屏幕 pyautogui拥有屏幕快照的功能，可以根据当前屏幕的内容创建图形文件。这些函数也可以返回一个Pillow的Image对象，包含当前屏幕的内容。这可能需要事先安装pillow模块\n获取屏幕快照 pyautogui.sceenshot()\n\u0026gt;\u0026gt;\u0026gt;import pyautogui\r\u0026gt;\u0026gt;\u0026gt;im = pyautogui.screenshot()\r im变量将包含一个屏幕快照的Image对象。现在可以调用im变量中Image对象的方法，就像所有其他Image对象一样。在交互式环境中输入以下内容：\n\u0026gt;\u0026gt;\u0026gt;im.getpixel((50,200))\r(130,135,144)\r 向getpixel()函数传入坐标元组，如（50,200）它将告诉你图像中这些坐标处的像素颜色。gitpixel()函数的返回值是一个RGB元组，包含3个整数，表示像素的红绿蓝值（没有第四个值表示alpha，因为屏幕快照是完全不透明的）。这就是你的程序“看到”当前屏幕上内容的方法。\n分析屏幕快照 假设你的GUI自动化程序中，有一步是点击灰色按钮。在调用click() 方法之前，你可以获取屏幕快照，查看脚本要点击处的像素。如果它的颜色和灰色按钮不一样，那么程序就知道出问题了。也许窗口发生了意外的移动，或者弹出式对话框挡住了该按钮。这时，不应该继续（可能会点击到错误的东西，造成严重破坏），程序可以“看到”它没有点击在正确的东西上，并自行停止。\n如果屏幕上指定的 x、y 坐标处的像素与指定的颜色匹配，PyAutoGUI 的pixelMatchesColor() 函数将返回True。第一和第二个参数是整数，对应x和y坐标。第三个参数是一个元组，包含3个整数，是屏幕像素必须匹配的RGB颜色。在交互式环境中输入以下内容：\n\u0026gt;\u0026gt;\u0026gt;import pyautogui\r\u0026gt;\u0026gt;\u0026gt;im = pyautogui.screenshot()\r\u0026gt;\u0026gt;\u0026gt;im.getpixel((50,200))\r\u0026gt;\u0026gt;\u0026gt; pyautogui.pixelMatchesColor(50, 200, (130, 135, 144))\rTrue\r\u0026gt;\u0026gt;\u0026gt; pyautogui.pixelMatchesColor(50, 200, (255, 135, 144))\rFalse\r 在获取屏幕快照，并用getpixel() 函数取得特定坐标处像素颜色的RGB元组之后，将同样的坐标和RGB元组传递给pixelMatchesColor() ，这应该返回True。然后改变RBG元组中的一个值，用同样的坐标再次调用pixelMatches Color() ，这应该返回False。你的GUI自动化程序要调用click() 之前，这种方法应该有用。\n请注意，给定坐标处的颜色应该“完全”匹配。即使只是稍有差异（例如，是（255，255，254）而不是（255，255，255）），那么函数也会返回False。\n图像识别 向PyAutoGUI提供希望点击的图像，让它去弄清楚坐标。\n可以使用locateOnScreen()返回图像所在处的坐标。它需要的参数，是你要想操作的位置的图片。\n例如这样：\n\u0026gt;\u0026gt;\u0026gt;import pyautogui\r\u0026gt;\u0026gt;\u0026gt;pyautogui.locateOnSreen('submit.png')\r(673, 745, 70, 29)\r locateOnScreen()函数返回4个整数的元组，是屏幕上首次发现该图像时左边的x坐标、顶边的y坐标、宽度以及高度。\n如果屏幕上找不到这个图像，locateOnScreen()会返回None。\n注意要成功识别，屏幕上的图像必须与提供的图像完全匹配。即使只差一个像素，locateOn Screen() 函数也会返回None。\n如果该图像在屏幕上能够找到多处，locateAllOnScreen() 函数将返回一个Generator对象。可以将它传递给list() ，返回一个4整数元组的列表。\n像这样：\n[(643, 790, 70, 29), (1007, 801, 70, 29)]\r 得到这个4整数元组，你就可以点击这个图像的中心了。\n\u0026gt;\u0026gt;\u0026gt; pyautogui.center((643, 745, 70, 29))\r(678, 759)\r\u0026gt;\u0026gt;\u0026gt; pyautogui.click((678, 759))\r 控制键盘 通过键盘发送一个字符串 pyautogui.typewrite()向计算机发送虚拟按键。这些按键产生什么效果，取决于当前获得焦点的窗口和文本输入框。\n向文本框输入时，你的用鼠标点击，确保它获得焦点。\n\u0026gt;\u0026gt;\u0026gt; pyautogui.click(10, 100); pyautogui.typewrite('Hello world!')\r 它其实还有一个参数，默认情况下，typewrite() 函数将立即打印出完整字符串。但是，你可以传入可选的第二参数，在每个字符之间添加短时间暂停。例如，pyautogui.typewrite（'Helloworld!'，0.25）将在打出H后等待1/4秒。打出e以后再等待1/4秒，如此等等\n键名 不是所有的键都很容易用单个文本字符来表示。例如，如何把Shift键或左箭头键表示为单个字符？在PyAutoGUI中，这些键表示为短的字符串值：\u0026lsquo;esc\u0026rsquo; 表示Esc键，\u0026lsquo;enter\u0026rsquo; 表示Enter。\n除了单个字符串参数，还可以向typewrite() 函数传递这些键字符串的列表。例如，以下的调用表示按a键，然后是b键，然后是左箭头两次，最后是X和Y键：\n\u0026gt;\u0026gt;\u0026gt; pyautogui.typewrite(['a', 'b', 'left', 'left', 'X', 'Y'])\r 下面是pyautogui接受的所有可能的键字符串：\n   键盘键字符串 含义     \u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026lsquo;A\u0026rsquo;, \u0026lsquo;B\u0026rsquo;, \u0026lsquo;C\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;!', \u0026lsquo;@', \u0026lsquo;#'，等等 单个字符的键   \u0026lsquo;enter\u0026rsquo;（or \u0026lsquo;return\u0026rsquo; or \u0026lsquo;\\n\u0026rsquo;） 回车键   \u0026lsquo;esc\u0026rsquo; Esc键   \u0026lsquo;shiftleft\u0026rsquo;, \u0026lsquo;shiftright\u0026rsquo; 左右Shift键   \u0026lsquo;altleft\u0026rsquo;, \u0026lsquo;altright\u0026rsquo; 左右Alt键   \u0026lsquo;ctrlleft\u0026rsquo;, \u0026lsquo;ctrlright\u0026rsquo; 左右Ctrl键   \u0026lsquo;tab\u0026rsquo;（or \u0026lsquo;\\t\u0026rsquo;） Tab键   \u0026lsquo;backspace\u0026rsquo;, \u0026lsquo;delete\u0026rsquo; Backspace和Delete键   \u0026lsquo;pageup\u0026rsquo;, \u0026lsquo;pagedown\u0026rsquo; Page Up和Page Down键   \u0026lsquo;home\u0026rsquo;, \u0026lsquo;end\u0026rsquo; Home和End键   \u0026lsquo;up\u0026rsquo;, \u0026lsquo;down\u0026rsquo;, \u0026lsquo;left\u0026rsquo;, \u0026lsquo;right\u0026rsquo; 上下左右箭头键   \u0026lsquo;f1\u0026rsquo;, \u0026lsquo;f2\u0026rsquo;, \u0026lsquo;f3\u0026rsquo;，等等 F1至F12键   \u0026lsquo;volumemute\u0026rsquo;, \u0026lsquo;volumedown\u0026rsquo;, \u0026lsquo;volumeup\u0026rsquo; 静音、减小音量、放大音量键（有些键盘没有这些键，但你的操作系统仍能理解这些模拟的按键）   \u0026lsquo;pause\u0026rsquo; Pause键   \u0026lsquo;capslock\u0026rsquo;, \u0026lsquo;numlock\u0026rsquo;, \u0026lsquo;scrolllock\u0026rsquo; Caps Lock，Num Lock和Scroll Lock键   \u0026lsquo;insert\u0026rsquo; Ins或Insert键   \u0026lsquo;printscreen\u0026rsquo; Prtsc或Print Screen键   \u0026lsquo;winleft\u0026rsquo;, \u0026lsquo;winright\u0026rsquo; 左右Win键（在Windows上）   \u0026lsquo;command\u0026rsquo; Command键（在OS X上）   \u0026lsquo;option\u0026rsquo; Option键（在OS X上）    按下和释放键盘 pyautogui.keyDown()向计算机发送虚拟按键。\npyautogui.keyUp()向计算机发送虚拟按键释放。\n当然，有pyautogui.press(),它调用这两个函数，模拟完整的击键。\n例如，打出@字符\n\u0026gt;\u0026gt;\u0026gt;pyautogui.keyDown('shift');pyautogui.press('4');pyautogui.keyUp('shift')\r 热键组合 热键”或“快捷键”是一种按键组合，它调用某种应用功能。拷贝选择内容的常用热键是Ctrl-C（在Windows和Linux上）或⌘-C（在OS X上）。用户按住Ctrl键，然后按C键，然后释放C和Ctrl键。要用pyautogui的keyDown() 和keyUp() 函数来做到这一点，就比较麻烦了，好在还有别的方法。\npyautogui.hotkey()接受多个键字符串参数，按顺序按下，再按相反的顺序释放。例如对于Ctrl-C，代码就像下面这样：\npyautogui.hotkey('ctrl','c')\r [refer to]http://pyautogui.readthedocs.org/\nhttp://pyautogui.readthedocs.org/\n","id":33,"section":"posts","summary":"使用pyautogui模块。 在Windows上，不需要安装其他模块。 在OS X上，运行sudo pip3 install pyobjc-framework-Quart","tags":["办公自动化"],"title":"Python控制键盘和鼠标","uri":"https://xuzhihao.top/2020/05/python%E6%8E%A7%E5%88%B6%E9%94%AE%E7%9B%98%E5%92%8C%E9%BC%A0%E6%A0%87/","year":"2020"},{"content":"shutil函数可以让你能够复制、移动、改名和删除文件。\n复制文件和文件夹 shutil.copy(source,destination),这个以将路径source处的文件复制到路径destination处的文件夹（参数都要是字符串格式）。如果destination是一个文件名，它将作为被复制文件的新名字。\n这个方法会返回被复制文件的路径。\nshutil.tree(source,destination)是将路径source处的文件夹，包括它所有文件和子文件夹，复制到路径destination处的文件。（source和destination都要是字符串）\n该方法会返回一个字符串，是新复制的文件夹的路径。\n文件和文件夹的移动和改名 shutil.move(source,destination)，将路径source处文件移动到路径destination，并返回新位置的绝对路径的字符串。\n注意：如果destiantion中有和source名称一样的文件，那么该文件将被重写。\ndestination路径也可以是一个文件名。这样的结果就是source文件被移动并改名。\n注意：\n\u0026gt;\u0026gt;\u0026gt;import shutil\r\u0026gt;\u0026gt;\u0026gt;shutil.move('c:\\\\1.txt','D:\\\\2')\r 这样会1.txt将会被命名为2（没有txt文件扩展名的文本文件）。\n文件夹的移动也是如此：\n\u0026gt;\u0026gt;\u0026gt;import shutil\r\u0026gt;\u0026gt;\u0026gt;shutil.move('c:\\\\1','D:\\\\2')\r 永久删除文件和文件夹 利用os模块。可以删除一个文件或一个空文件。但利用shutil模块，可以删除一个文件夹及其所有的内容。\n 用os.unlink(path)将删除path处的文件。 调用os.rmdir(path)将删除path处的文件夹。该文件夹必须为空，其中没有任何文件和文件夹。 调用shutil.rmtree(path)将删除path处的文件夹，它包含的所有文件和文件夹都会被删除。  注意：这是永久删除。\nsend2trash安全删除 这需要第三方库。\npip install send2trash\r 使用方法如下：\nimport send2trash\rsend2trash.sendtrash('trash.txt')\r 虽然它将文件发送到垃圾箱，让你稍后能够恢复它们，但是这不像永久删除文件，不会释放磁盘空间。如果你希望程序释放磁盘空间，就要用os和shutil来删除文件和文件夹。\n请注意，send2trash()函数只能将文件送到垃圾箱，不能从中恢复文件。\n遍历目录树 os.walk()函数被传入以个字符串值，即一个文件夹的路径。你可以在一个for循环中使用os.wakl()，遍历目录树。\nos.walk()在循环的每次迭代中，返回三个值：\n 当前文件夹名称的字符串 当前文件夹中的子文件夹的字符串列表 当前文件夹中的文件的字符串的列表  import os\rfor folderName,subfolders,filenames in os.walk(\u0026quot;D:\\\\歌曲\u0026quot;):\rprint('The current folder'+folderName)\rfor subfolder in subfolders:\rprint(\u0026quot;Subfolder of \u0026quot;+folderName+'\\\\'+subfolder)\rfor filename in filenames:\rprint('File inside '+folderName+'\\\\'+filename)\r ","id":34,"section":"posts","summary":"shutil函数可以让你能够复制、移动、改名和删除文件。 复制文件和文件夹 shutil.copy(source,destination),这个","tags":["办公自动化"],"title":"Python组织文件","uri":"https://xuzhihao.top/2020/05/python%E7%BB%84%E7%BB%87%E6%96%87%E4%BB%B6/","year":"2020"},{"content":"ASCII Table \u0026ndash; Nonprintable Characters    Control Character Python \u0026amp; Java Hexadecimal Decimal Description     ^@ \\0 00 0 Null character   ^A \\1 01 1 Start of heading   ^B \\2 02 2 Start of text   ^C \\3 03 3 End of text   ^D \\4 04 4 End of transmission   ^E \\5 05 5 Enquiry   ^F \\6 06 6 Acknowledge   ^G \\a 07 7 Audible bell   ^H \\b 08 8 Backspace   ^I \\t 09 9 Horizontal tab   ^J \\n 0a 10 Line feed   ^K \\v 0b 11 Vertical tab   ^L \\f 0c 12 Form feed   ^M \\r 0d 13 Carriage return   ^N \\x0e 0e 14 Shift out   ^O \\x0f 0f 15 Shift in   ^P \\x10 10 16 Data link escape   ^Q \\x11 11 17 Device control 1   ^R \\x12 12 18 Device control 2   ^S \\x13 13 19 Device control 3   ^T \\x14 14 20 Device control 4   ^U \\x15 15 21 Negative Acknowledge   ^V \\x16 16 22 Synchronous idle   ^W \\x17 17 23 End of transmission block   ^X \\x18 18 24 Cancel   ^Y \\x19 19 25 End of medium   ^Z \\x1a 1a 26 Substitute   ^[ \\x1b 1b 27 Escape   *^* \\x1c 1c 28 File separator   ^] \\x1d 1d 29 Group separator   ^^ \\x1e 1e 30 Record separator   ^- \\x1f 1f 31 Unit separator    ","id":35,"section":"posts","summary":"ASCII Table \u0026ndash; Nonprintable Characters Control Character Python \u0026amp; Java Hexadecimal Decimal Description ^@ \\0 00 0 Null character ^A \\1 01 1 Start of heading ^B \\2 02 2 Start of text ^C \\3 03 3 End of text ^D \\4 04 4 End of transmission ^E \\5 05 5 Enquiry ^F \\6 06 6 Acknowledge ^G \\a 07 7 Audible bell ^H \\b 08 8 Backspace ^I \\t","tags":null,"title":"ASCII表-Nonprintable Characters","uri":"https://xuzhihao.top/2020/05/ascii%E8%A1%A8-nonprintable-characters/","year":"2020"},{"content":"OpenPrinter 打开打印机\nwin32print.OpenPrinter(string,Defaults)\r string就是打印机的名字，当为空的时候打开本地打印机\nStartDocPrinter StartDocPrinter(hprinter, level , tuple )\r level=1\ntuple:对应于level参数的元组\n​\t[0]:字符串：docName:指定文档名称\n​\t[1]:字符串：outputFile：指定输出文件的名称。要打印到打印机，请将其设置为“无”。\n​\t[2]字符串：dataType。标识用于记录文档的数据类型，例如“原始”或“emf”，用于记录打印作业。这个成员可以是None。如果不是None, StartDoc函数将其传递给打印机驱动程序。请注意，打印机驱动程序可能会忽略所请求的数据类型。\nStartPagePrinter(hprinter) 通知打印后台处理程序要在指定打印机上打印页面。\nWritePrinter win32print.WritePrinter(hprinter,buf)\r 参数：\nhprinter：OpenPrinter返回的打印机\nbuf：字符串\n**返回值：**返回写入打印机的字节数。\nEndPagePrinter(hprinter) 结束打印作业中的页面。\nEndDocPriner(hprinter) EndDocPrinter函数结束指定打印机的打印作业。在使用WritePrinter之后使用。\nClosePrinter 关闭打印机\nwin32print.ClosePrinter(hPrinter)\r hPrinter是OpenPrinter创建的对象。\n实例 def output(self):\rhPrinter = win32print.OpenPrinter(self.PRINTER_NAME)\rtry:\rwin32print.StartDocPrinter(hPrinter, 1, (\u0026quot;Notification\u0026quot;, None, \u0026quot;RAW\u0026quot;))\rtry:\rwin32print.StartPagePrinter(hPrinter)\rwin32print.WritePrinter(hPrinter, \u0026quot;\\n\u0026quot;.join(self.lines).encode(\u0026quot;GBK\u0026quot;))\rwin32print.EndPagePrinter(hPrinter)\rfinally:\rwin32print.EndDocPrinter(hPrinter)\rfinally:\rwin32print.ClosePrinter(hPrinter)\rself.lines = []\r 注意：为了避免汉字乱码，用GKB编码。\nrefer to http://docs.activestate.com/activepython/2.5/pywin32/win32print.html\n","id":36,"section":"posts","summary":"OpenPrinter 打开打印机 win32print.OpenPrinter(string,Defaults) string就是打印机的名字，当为空的时候打开本地打印机 StartDocPrinter StartDocPrinter(hprinter, level , tuple ) level=1 tuple:对应于level参数的元组 ​ [0]:字符串：","tags":null,"title":"Python中win32print","uri":"https://xuzhihao.top/2020/05/python%E4%B8%ADwin32print/","year":"2020"},{"content":"enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中\n写法\nenumerate(sequence,[start=0])\r 参数\n sequence——一个可迭代对象 start——下标起始位置  返回值\n返回enumerate（枚举）对象\n实例\n\u0026gt;\u0026gt;\u0026gt;seq = ['one', 'two', 'three']\r\u0026gt;\u0026gt;\u0026gt; for i, element in enumerate(seq):\r... print i, element\r... 0 one\r1 two\r2 three\r \u0026gt;\u0026gt;\u0026gt;seasons = ['Spring', 'Summer', 'Fall', 'Winter']\r\u0026gt;\u0026gt;\u0026gt; list(enumerate(seasons))\r[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]\r\u0026gt;\u0026gt;\u0026gt; list(enumerate(seasons, start=1)) # 下标从 1 开始\r[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]\r ","id":37,"section":"posts","summary":"enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中 写法 enumerate(sequence,[start=0]) 参数 sequen","tags":["Python内建函数"],"title":"Python中的enumerate()","uri":"https://xuzhihao.top/2020/05/python%E4%B8%AD%E7%9A%84enumerate/","year":"2020"},{"content":"用于对文本字符串进行自动换行或填充。\ntextwrap.wrap(text,width=70,**kwargs) ​\t对text中的单独段落自动换行以使每行长度最多为width个字符。返回输出行组成的列表，行尾不带换行符。如果自动换行输出结果没有任何内容，则返回空列表。\ntextwrap.fill(text,width=70,**kwargs) ​\t对text中单独段落自动换行，并返回一个包含被自动换行段落的单独字符串。相当于：\u0026quot;\\n\u0026quot;.join(wrap(text,...))\ntextwrap.shorten(text, width, **kwargs） 折叠并截断文本以适合的宽度。\n文本中的空格被折叠（搜用空格均由单个空格代替）。如果结果适合width，啧将其返回。否则，将从末尾丢弃足够的单词，以使其余单词加上占位符（placeholder)带到width的长度。\n\u0026gt;\u0026gt;\u0026gt; textwrap.shorten(\u0026quot;Hello world!\u0026quot;, width=12)\r'Hello world!'\r\u0026gt;\u0026gt;\u0026gt; textwrap.shorten(\u0026quot;Hello world!\u0026quot;, width=11)\r'Hello [...]'\r\u0026gt;\u0026gt;\u0026gt; textwrap.shorten(\u0026quot;Hello world\u0026quot;, width=10, placeholder=\u0026quot;...\u0026quot;)\r'Hello...'\r textwrap.indent（text，prefix，predicate = None ） 将前缀添加到文本中所选行的开头。\n通过调用来分隔行text.splitlines(True)。\n默认情况下，将前缀添加到并非仅由空格组成的所有行（包括任何行尾）。\n\u0026gt;\u0026gt;\u0026gt; indent(s, ' ')\r' hello\\n\\n \\n world'\r 可选的谓词参数可用于控制缩进的行。例如，很容易将前缀添加到空行和仅空白行：\n\u0026gt;\u0026gt;\u0026gt; print(indent(s, '+ ', lambda line: True))\r+ hello\r+\r+\r+ world\r ","id":38,"section":"posts","summary":"用于对文本字符串进行自动换行或填充。 textwrap.wrap(text,width=70,**kwargs) ​ 对text中的单独段落自动换行以使每行长度最多为width个字符。返回输出行组成的列表，行尾不带换行","tags":["Python标准库"],"title":"Python中的textwrap","uri":"https://xuzhihao.top/2020/05/python%E4%B8%AD%E7%9A%84textwrap/","year":"2020"},{"content":"捕捉异常 使用try/except语句实现。\nexcept() except语句可以使用不止一次：\ntry:\rxxx\rexcept ZeroDivisionError:\rprint()\rexcept TypeError:\rprint()\r 或者像这样\ntry:\rXXX\rexcept (ZeroDivisionError,TypeError):\rprint()\r 如果你想记录原因的话，可以这样：\ntry:\rXXX\rexcept (ZeroDivisionError,TypeError) as e:\rprint(e)\rpass\r try/except\u0026hellip;else try:\rprint('A simple task')\rexcept:\rprint('There is Error)\relse:\rprint('It went as planned)\r finally 用于出发异常后的处理。\ntry:\r1/0\rexcept:\rprint('There is Error')\relse:\rprint('OK')\rfinally:\rprint('Clean up')\r 触发异常 使用raise语句。\n\u0026gt;\u0026gt;\u0026gt;raise Exception('hyperdrive overload')\r 异常类    类名 描述     Exception 所有异常的基类   AttributeError 特性引用或赋值失败时引发   IOError 试图打开不存在的文件（包括其他情况）时引发   IndexError 使用索引中不存在的索引引发   KeyError 使用映射中不存在的键引发   NameError 找不到变量时引发   SyntaxError 代码为错误形式引发   TypeError 内建操作或函数应用于错误类型的对象时引发   ValueError 内建操作或函数应用于正确对象，但是该对象使用不合理的值引发   ZeroDivisionError 除法或取模时 第二个参数为0    ","id":39,"section":"posts","summary":"捕捉异常 使用try/except语句实现。 except() except语句可以使用不止一次： try: xxx except ZeroDivisionError: print() except TypeError: print() 或者像这样 try: XXX except (ZeroDivisionError,TypeError): print() 如果你想记录原因的话，可以","tags":null,"title":"Python中的异常处理","uri":"https://xuzhihao.top/2020/05/python%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","year":"2020"},{"content":"允许向用户显示基于Web的文档。在大多数情况下，只需要调用open()函数就可以。\n脚本 webbrowser 可以用作模块的命令行界面。它接受一个 URL 作为参数。还接受以下可选参数：-n 如果可能，在新的浏览器窗口中打开 URL ； -t 在新的浏览器页面（“标签”）中打开 URL。这些选择当然是相互排斥的。用法示例:\npython -m webbrowser -t \u0026quot;http://www.python.org\u0026quot;\r 常用方法： webbrowser.open(url, new=0, autoraise=True) ​\t使用默认浏览器显示 url。 如果 new 为 0，则尽可能在同一浏览器窗口中打开 url。 如果 new 为 1，则尽可能打开新的浏览器窗口。 如果 new 为 2，则尽可能打开新的浏览器页面（“标签”）。 如果 autoraise 为 “True”，则会尽可能置前窗口（请注意，在许多窗口管理器下，无论此变量的设置如何，都会置前窗口）。\nwebbrowser.open_new(url) 如果可能，在默认浏览器的新窗口中打开 url，否则，在唯一的浏览器窗口中打开 url。\nwebbrowser.open_new_tab(url) 如果可能，在默认浏览器的新页面（“标签”）中打开 url，否则等效于 open_new()。\nwebbrowser.get(using=None) 返回浏览器类型为 using 指定的控制器对象。 如果 using 为 None，则返回适用于调用者环境的默认浏览器的控制器。\nwebbrowser.register(name, constructor, instance=None, *, preferred=False) 注册 name 浏览器类型。 注册浏览器类型后， get()函数可以返回该浏览器类型的控制器。 如果没有提供 instance，或者为 None，constructor 将在没有参数的情况下被调用，以在需要时创建实例。 如果提供了 instance，则永远不会调用 constructor，并且可能是 None。将 preferred 设置为 True 使得这个浏览器成为 get() 不带参数调用的首选结果。 否则，只有在您计划设置 BROWSER 变量，或使用与您声明的处理程序的名称相匹配的非空参数调用 get() 时，此入口点才有用。\n","id":40,"section":"posts","summary":"允许向用户显示基于Web的文档。在大多数情况下，只需要调用open()函数就可以。 脚本 webbrowser 可以用作模块的命令行界面。它接受一个 URL 作为参数。还接","tags":["Python标准库"],"title":"Python的webbrowser","uri":"https://xuzhihao.top/2020/05/python%E7%9A%84webbrowser/","year":"2020"},{"content":"新建一个数据库文件 使用cd命令进入到数据库文件的目录下，用sqlite3命令创建数据库文件。\nsqlite3 DatabaseName.db\r 查看已建立的数据库文件 使用database命令检查是否在数据库列表中。\n打开已建立的数据库文件 在用cd命令，进入到要打开的数据库文件所在的目录下，使用sqlite3打开数据库文件。例如：\nsqlite3 test.db\r 查看帮助信息 在SQLite命令行模式下，输入.help命令可以查看SQLite的帮助信息。\n创建表 在SQLite命令行模式下，输入像下列的命令：\ncreate table people(id integer pri,ary key,name text)\r 添加数据 sqlite﹥insert into people( id, name) values( 1,' zhangsan');\r 查询表中的记录 sqlite ﹥ select * from people;  适用于SQLite的数据库管理西欧通 推荐 SQLiteStudio 软件，其官方下载地址为 https:// sqlitestudio.pl/index.rvt。 这款软件是绿色的免安装的，解压缩后直接运行就可以了。\n","id":41,"section":"posts","summary":"新建一个数据库文件 使用cd命令进入到数据库文件的目录下，用sqlite3命令创建数据库文件。 sqlite3 DatabaseName.db 查看已建立的数据库文件 使用database命","tags":null,"title":"SQLite常用操作","uri":"https://xuzhihao.top/2020/05/sqlite%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","year":"2020"},{"content":" 新建工程 建立分部分项（编制清单、描述项目特征、套定额） 建立单价措施项目（编制清单、描述项目特套定额等） 建立总价措施项目（取费） 建立其他项目费用（暂列金额、暂估价等） 建立规费项目（取费） 建立税金（取费） 调整人工费及材料费 自检、他检 打印表格  ","id":42,"section":"posts","summary":"新建工程 建立分部分项（编制清单、描述项目特征、套定额） 建立单价措施项目（编制清单、描述项目特套定额等） 建立总价措施项目（取费） 建立其他项目费","tags":["工程造价"],"title":"GCCP5.0使用流程","uri":"https://xuzhihao.top/2020/04/gccp5.0%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/","year":"2020"},{"content":"安装python-pdfkit：\npip install pdfkit\r 安装wkhtmlopdf\n https://wkhtmltopdf.org/downloads.html下载安装包 配置好环境变量  使用 一个简单的梨子：\nimport pdfkit\rpdfkit.from_string('hello,python','out.pdf')\rpdfkit.from_url('http://baidu.com','out.pdf')\rpdfkit.from_file('test.html', 'out.pdf')\r ","id":43,"section":"posts","summary":"安装python-pdfkit： pip install pdfkit 安装wkhtmlopdf https://wkhtmltopdf.org/downloads.html下","tags":null,"title":"html转为图片","uri":"https://xuzhihao.top/2020/04/html%E8%BD%AC%E4%B8%BA%E5%9B%BE%E7%89%87/","year":"2020"},{"content":"使用日志模块要启用logging模块，\n开始 在程序运行时将日志信息显示在屏幕上，请将下面的代码复制到程序顶部（但在Python的#!行之下）\nimport logging\rlogging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s\r- %(message)s')\r 你不需要过于担心它的工作原理，但基本上，当 Python 记录一个事件的日志时，它会创建一个LogRecord对象，保存关于该事件的信息。logging模块的函数让你指定想看到的这个LogRecord对象的细节，以及希望的细节展示方式。\n这里，我们在想打印日志信息时，使用logging.debug() 函数。这个debug() 函数将调用basicConfig()，打印一行信息。这行信息的格式是我们在 basicConfig()函数中指定的，并且包括我们传递给 debug() 的消息。\n输出\n2020-04-30 12:20:12,664 - DEBUG - Start of program\r 这样子的信息。\n日志消息的好处在于，你可以随心所欲地在程序中想加多少就加多少，稍后只要加入一次logging.disable(logging.CRITICAL)调用，就可以禁止日志。\n不像print()，logging模块使得显示和隐藏日志信息之间的切换变得很容易。\n日志级别    级别 日志函数 描述     DEBUG logging.debug() 最低级别。用于小细节。通常只有在诊断问题时，你才会关心这些消息   INFO logging.info() 用于记录程序中一般事件的信息，或确认一切工作正常   WARNING logging.warning() 用于表示可能的问题，它不会阻止程序的工作，但将来可能会   ERROR logging.error() 用于记录错误，它导致程序做某事失败   CRITICAL logging.critical() 最高级别。用于表示致命的错误，它导致或将要导致程序完全停止工作    日志级别的好处在于，你可以改变想看到的日志消息的优先级。向basicConfig()函数传入logging.DEBUG作为level关键字参数，这将显示所有日志级别的消息（DEBUG是最低的级别）。\n在开发了更多的程序后，你可能只对错误感兴趣。在这种情况下，可以将basicConfig() 的level参数设置为logging.ERROR，这将只显示ERROR和CRITICAL消息，跳过DEBUG、INFO和WARNING消息。\n禁用日志 在调试完程序后，你可能不希望所有这些日志消息出现在屏幕上。logging. disable() 函数禁用了这些消息，这样就不必进入到程序中，手工删除所有的日志调用。只要向logging.disable() 传入一个日志级别，它就会禁止该级别和更低级别的所有日志消息。所以，如果想要禁用所有日志，只要在程序中添加logging. disable(logging.CRITICAL)\nlogging.critical('Critical error! Critical error!')\r 将日志记录到文件 除了将日志消息显示在屏幕上，还可以将它们写入文本文件。logging.basic Config() 函数接受filename关键字参数.\nlogging.basicConfig(filename='myProgramLog.txt', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')\r ","id":44,"section":"posts","summary":"使用日志模块要启用logging模块， 开始 在程序运行时将日志信息显示在屏幕上，请将下面的代码复制到程序顶部（但在Python的#!行之下） import","tags":["Python标准库"],"title":"Python中的logging模块","uri":"https://xuzhihao.top/2020/04/python%E4%B8%AD%E7%9A%84logging%E6%A8%A1%E5%9D%97/","year":"2020"},{"content":"使用ShellExecute方法，可以打印Microsoft Office文档，PDF文件，文本文件以及几乎搜友主要应用程序。\nimport tempfile\rimport win32api\rimport win32print\rfilename = tempfile.mktemp (\u0026quot;.txt\u0026quot;)\ropen (filename, \u0026quot;w\u0026quot;).write (\u0026quot;This is a test\u0026quot;)\rwin32api.ShellExecute (\r0,\r\u0026quot;print\u0026quot;,\rfilename,\rNone,\r\u0026quot;.\u0026quot;,\r0\r)\r 将filename改为PDF文件的路径，就可以打印PDF了。\n注意：当出现了Python win32 ShellExecute错误31：“连接到系统的设备无法运行。”时，你可能计算机没有安装pdf阅读器，并且导致了该错误（要打印的文件是pdf）。\n在那台计算机上安装福昕阅读器可以解决该问题。\n不过，这个很难控制输出。\n","id":45,"section":"posts","summary":"使用ShellExecute方法，可以打印Microsoft Office文档，PDF文件，文本文件以及几乎搜友主要应用程序。 import tempfile import win32api import win32print filename =","tags":null,"title":"ShellExecute简单控制打印机","uri":"https://xuzhihao.top/2020/04/shellexecute%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E6%9C%BA/","year":"2020"},{"content":"SQLite官方安装地址：http://www.sqlite.org/download.html\n我下载了压缩包sqlite-tools-win32-x86-3310100.zip，下载后直接解压到磁盘上，可以看到解压后有sqlite.exe文件。\n接下来需要将SQLite路径加入到Path环境变量中。右键单击“ 我的电脑”，从弹出 的快捷菜单中选择“ 属性” →“ 高级系统设置” →“ 环境变量”，在系统变量中 找到 Path,将解压缩后的SQLite 路径加入到变量值中。\n打开命令行窗口，输入 sqlite3，显示SQLite Version就说明安装成功了。\n","id":46,"section":"posts","summary":"SQLite官方安装地址：http://www.sqlite.org/download.html 我下载了压缩包sqlite-tools-wi","tags":["SQLite"],"title":"Window下安装SQLite","uri":"https://xuzhihao.top/2020/04/%E5%AE%89%E8%A3%85sqlite/","year":"2020"},{"content":"plt.plot()函数参数详解 plt.plot(x,y,linestyle,\rlinewidth,color,marker,\rmarkersize,markeredgecolor,\rmarkerfactcolor,label,alpha)\r x：指定折现图的x轴数据\ny：指定折线图的y轴数据\nlinestyle：指定折线类型，可以是实线、虚线、点虚线、点点线等，默认实线\nlinewidth：指定折线的宽度\nmarker：可以为折线图添加点，该参数是设置点的形状；\nmarkersize：设置点的大小；\nmarkeredgecolor：设置点的边框色；\nmarkerfactcolor：设置点的填充色；\nlabel：为折线图添加标签，类似于图例的作用；\n实例(一元折现图) import matplotlib.pyplot as plt\rimport matplotlib as mpl\rimport pandas as pd\r#设置中文编码\rplt.rcParams['font.sans-serif'] = ['SimHei']\r#设置时间戳作为横轴刻度\rdate = pd.date_range('3/5/2018',periods=17,freq='2D')\ry1=[79,122,387,112,82,87,122,144,309,117,132,80,66,55,110,58,198] #设置绘图框的大小\rfig = plt.figure(figsize=(10,6))\r#添加标题和坐标轴标签\rplt.title('每日文章阅读量折线图') plt.xlabel('文章推送日期') plt.ylabel('文章阅读量')\r#绘图\rplt.plot(date, y1,'b',linestyle='-',linewidth=2,marker='o',markersize=6,markeredgecolor='black',markerfacecolor='steelblue',label='阅读量')\r#获取图的坐标信息\rax = plt.gca()\r# 设置日期的显示格式 date_format = mpl.dates.DateFormatter(\u0026quot;%Y-%m-%d\u0026quot;) ax.xaxis.set_major_formatter(date_format)\r#设置x轴每个刻度的间隔天数\rxlocator = mpl.ticker.MultipleLocator(2)\rax.xaxis.set_major_locator(xlocator)\r#设置图例显示 plt.legend(bbox_to_anchor=[1,1]) # 为了避免x轴日期刻度标签的重叠，设置x轴刻度自动展现，并且60度倾斜\rfig.autofmt_xdate(rotation=60)\r#显示图形\rplt.show()\r 实例（二元折线图） import matplotlib.pyplot as plt\rimport matplotlib as mpl\rimport pandas as pd\r#设置中文编码\rplt.rcParams['font.sans-serif'] = ['SimHei']\r#设置时间戳作为横轴刻度\rdate = pd.date_range('3/5/2018',periods=17,freq='2D')\r#推送文章阅读量\ry1 = [79,122,387,112,82,87,122,144,309,117,132,80,66,55,110,58,198] #推送文章图文阅读人数\ry2 = [42,113,171,91,62,66,94,95,186,100,114,68,58,55,122,60,192]\r#设置绘图框的大小\rfig = plt.figure(figsize=(10,6))\r#添加标题和坐标轴标签\rplt.title('每日文章阅读量及阅读人数折线图') plt.xlabel('文章推送日期') plt.ylabel('文章阅读量')\r#绘图1\rplt.plot(date, y1,'b',linestyle='-',linewidth=2,marker='o',markersize=6,markeredgecolor='black',markerfacecolor='steelblue',label='阅读量')\r#绘图2\rplt.plot(date, y2,'r',linestyle='-',linewidth=2,marker='o',markersize=6,markeredgecolor='black',markerfacecolor='steelblue',label='阅读人数')\r#获取图的坐标信息\rax = plt.gca()\r# 设置日期的显示格式 date_format = mpl.dates.DateFormatter(\u0026quot;%Y-%m-%d\u0026quot;) ax.xaxis.set_major_formatter(date_format)\r#设置x轴每个刻度的间隔天数\rxlocator = mpl.ticker.MultipleLocator(2)\rax.xaxis.set_major_locator(xlocator)\r#设置图例显示 plt.legend(bbox_to_anchor=[1,1]) # 为了避免x轴日期刻度标签的重叠，设置x轴刻度自动展现，并且45度倾斜\rfig.autofmt_xdate(rotation=60)\r#显示图形\rplt.show()\r ","id":47,"section":"posts","summary":"plt.plot()函数参数详解 plt.plot(x,y,linestyle, linewidth,color,marker, markersize,markeredgecolor, markerfactcolor,label,alpha) x：指定折现图的x轴数据 y：指定折线图的y轴数据 linestyle：指定折线类型，可以是实线、虚线、","tags":["数据可视化"],"title":"用Matplotlib画折线图","uri":"https://xuzhihao.top/2020/04/%E7%94%A8matplotlib%E7%94%BB%E6%8A%98%E7%BA%BF%E5%9B%BE/","year":"2020"},{"content":"安装时，换个源 pip install -i http://pypi.tuna.tsinghua.edu.cn/simple XXX\r https://pypi.douban.com/simple 豆瓣的源\n显示版本和路径 pip --version\r 升级pip pip install -U pip\r 安装包 pip install SomePackage #这是下载最新版本\rpip install SomePackage==1.0.4 #指定版本\rpip install SomePackafe\u0026gt;=1.0.4 #最小版本\r 升级包 pip install --upgrade SomePackage\r 卸载包 pip uninstall SomePackage\r 显示安装包信息 pip show\r 查看指定包的详细信息 pip show -f SomePackage\r 列出可升级的包 pip list\r 当同时有Python2和Python3时 Python2:\npython -m pip install XXX\r Python3:\npython -m pip install XXX\r ","id":48,"section":"posts","summary":"安装时，换个源 pip install -i http://pypi.tuna.tsinghua.edu.cn/simple XXX https://pypi.douban.com/simple 豆瓣的源 显示版本和路径 pip --version 升级pip pip install -U pip 安装包 pip install SomePackage #这是下载最新版本 pip install SomePackage==1.0.4 #指定版本 pip install SomePackafe\u0026gt;=1.0.4 #最小版本 升级包 pip","tags":null,"title":"pip使用指南","uri":"https://xuzhihao.top/2020/04/pip%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","year":"2020"},{"content":"1、进入某个盘 D: #进入D盘\r 2、查看目录文件 dir\r 3、创建目录和删除目录 md 目录名 //创建目录\rrd 目录名 //删除目录\r 4、查看本机ip ipconfig\r 5、清楚屏幕 cls\r 6、复制文件 copy 路径\\文件名 路径\\文件名 //把一个文件拷贝到另一个地方。\r 7、移动文件 move 路径\\文件名 路径\\文件名\r 8、删除文件 del 文件名\r 这个只能删除文件，不能删除文件夹\n9、Ping ping ip\r ","id":49,"section":"posts","summary":"1、进入某个盘 D: #进入D盘 2、查看目录文件 dir 3、创建目录和删除目录 md 目录名 //创建目录 rd 目录名 //删除目录 4、查看本机ip ipconfig 5、清楚屏幕 cls 6","tags":null,"title":"Windows下CMD常用命令","uri":"https://xuzhihao.top/2020/04/windows%E4%B8%8Bcmd%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","year":"2020"},{"content":"我在使用pip 安装Tendorflow时，出现了错误。\n我查阅了好多博客，发现他们大多都是一个版本的\u0026hellip;..\nTensorflow能在3.6（64bits）下安装，而3.6（32bits）安装就会出错。\n我下载了Python3.6.6（64bits）后，重新pip 就没有问题了\n","id":50,"section":"posts","summary":"我在使用pip 安装Tendorflow时，出现了错误。 我查阅了好多博客，发现他们大多都是一个版本的\u0026hellip;.. Tensorflow能","tags":["错误记录"],"title":"【Tensorflow安装问题】总是无法安装tensorflow：Could not find a version that satisfies the requirement tensorflow","uri":"https://xuzhihao.top/2020/04/tensorflow%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E6%80%BB%E6%98%AF%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85tensorflowcould-not-find-a-version-that-satisfies-the-requirement-tensorflow/","year":"2020"},{"content":"CSV表示\u0026quot;Comma-Sparated Values（逗号分隔的值）\u0026quot;,CSV文件是简化的电子表格，保存为纯文本文件。\n不过，CSV是简单的，但也缺少了Excel电子表格的许多功能\n 值没有类型，所有东西都是字符串； 没有字体大小或颜色的设置； 没有多个工作表 不能指定单元格的宽度和高度； 不能合并单元格； 不能嵌入图像或图表。  使用CSV模块 CSV是python自带的标准库,用于读写CSV文件。\nReader对象 用csv从csv文件读取数据，需要创建一个Reader对象。\nimport csv\rexample = open('example.csv')\rReader = csv.reader(example)\rfor row in Reader:\rprint(str(row))\r 注意：Reader有属性.line_num表示这是行数。\nWrite对象 Write对象让你的数据写入到CSV文件。要创建一个Write对象，就使用csv.write()函数。\nimport csv\routputFile = open('output.csv','w',newline='')\routputWrite = csv.write(outputFile)\routputWrite.writerow(['apple','orange','egg'])\routputFile.close()\r delimiter和lineterminator关键字参数 import csv\rcsvFile = open('example.csv','w',newline='')\rcsvWirte = csv.write(scvFile,delimiter='\\t',lineterminator='\\n\\n')\rcsvWriter.writerow(['egg','bacon','ham'])\rscvWriter.writerow(['fly','swim','play'])\rcsvFile.close()\r 改变了文件中的分隔符和行终止字符。分隔符是一行中单元格之间出现的字符。默认情况下，CSV文件的分隔符是逗号。行终止字符是出现在行末的字符。默认情况下，行终止字符是换行符。你可以利用csv.writer()的delimiter和lineterminator关键字参数，将这些字符改成不同的值。传入delimeter=\u0026rsquo;\\t'和lineterminator=\u0026rsquo;\\n\\n\u0026rsquo;，这将单元格之间的字符改变为制表符，将行之间的字符改变为两个换行符。然后我们调用writerow()三次，得到3行。\n那么，example.csv文件包含以下内容：\negg\tbacom\tham\rfly\tswim\tplay\r 既然单元格是由制表符分隔的，我们就使用文件扩展名.tsv，表示制表符分隔的值。\n","id":51,"section":"posts","summary":"CSV表示\u0026quot;Comma-Sparated Values（逗号分隔的值）\u0026quot;,CSV文件是简化的电子表格，保存为纯文本文件。 不","tags":["办公自动化","Python标准库"],"title":"操作CSV表格","uri":"https://xuzhihao.top/2020/04/%E4%BD%BF%E7%94%A8csv%E6%A8%A1%E5%9D%97/","year":"2020"},{"content":"打标签 打标签就是用于给历史中的某一个提交打上标签。\n列出标签 在Git中列出已有的标签是非常直观的。只需要输入git tag。\n当然，你可以使用特定的模式，查看标签。例如，Git自身的源代码仓库包含标签超过500个。如果只对1.8.5系列感兴趣，可以运行：\ngit tag -l 'v1.8.5*'\r 创建标签 Git使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。\n一个轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。\n然而。附注标签是存储在Git数据库中的一个完整对象。它们是可以被校验的；其中包含打标签的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用GNU Privacy Guard（GPG）签名与验证。\n建议：创建附注标签，你可以拥有上述的所有信息；如果，你住需要说和临时标签。那么就使用轻量标签。\n附注标签 创建的方法就是，在运行tag命令时指定-a选项：\ngit tag -a v1.4 -m \u0026quot;my version 1.4\u0026quot;\r -m选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git会运行编辑器要求你输入信息。\n通过使用git show命令可以看到标签信息与对应的提交信息：\n$ git show v1.4\rtag v1.4\rTagger: Ben Straub \u0026lt;ben@straub.cc\u0026gt;\rDate: Sat May 3 20:19:12 2014 -0700\rmy version 1.4\rcommit ca82a6dff817ec66f44342007202690a93763949\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Mon Mar 17 21:52:11 2008 -0700\rchanged the version number\r 输出显示了打标签者的消息、打标签的日期时间、附注信息。然后显示具体的提交信息。\n轻量标签 本质上是将提交校验和存储到一个文件中——没有保存其他信息、创建轻量级标签，不需要其他的选项，只需要提供标签名字：\ngit tag v1.4\r 这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：\n$ git show v1.4-lw\rcommit ca82a6dff817ec66f44342007202690a93763949\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Mon Mar 17 21:52:11 2008 -0700\rchanged the version number\r 后期打标签 你可以对过去的提交打标签。\n比如这样：\n$ git log --pretty=oneline\r15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'\ra6b4c97498bd301d84096da251c98a07c7723e65 beginning write support\r0d52aaab4479697da7686c15f77a3d64d9165190 one more thing\r6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'\r0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function\r4682c3261057305bdd616e23b64b0857d832627b added a todo file\r166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\r9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\r964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo\r8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\r 现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要 在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：\ngit tag -a v1.2 9fceb02\r 共享标签 默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到 共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin [tagname]。\n$ git push origin v1.5\rCounting objects: 14, done.\rDelta compression using up to 8 threads.\rCompressing objects: 100% (12/12), done.\rWriting objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.\rTotal 14 (delta 3), reused 0 (delta 0)\rTo git@github.com:schacon/simplegit.git\r* [new tag] v1.5 -\u0026gt; v1.5\r 如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库 服务器上的标签全部传送到那里。\n git push origin --tags\r 删除标签 删除掉你本地仓库上的标签 可以使用命令 git tag -d 。例如，可以使用下面的命令删除掉 一个轻量级标签：\n$ git tag -d v1.4-lw\rDeleted tag 'v1.4-lw' (was e7d5add)\r 删除任何远程仓库的标签 首先，删除你本地的标签，\n然后，使用git push \u0026lt;remote\u0026gt;:refs/tags/\u0026lt;tagname\u0026gt;来更新你的远程仓库。\n$ git push origin :refs/tags/v1.4-lw\rTo /git@github.com:schacon/simplegit.git\r- [deleted] v1.4-lw\r 检出标签 如果你想查看某个标签指向的文件版本，可以使用git checkout命令。注意这样会使你的仓库处于“分离头指针（detached HEAD)”状态。\n$ git checkout 2.0.0\rNote: checking out '2.0.0'.\rYou are in 'detached HEAD' state. You can look around, make experimental\rchanges and commit them, and you can discard any commits you make in this\rstate without impacting any branches by performing another checkout.\rIf you want to create a new branch to retain commits you create, you may\rdo so (now or later) by using -b with the checkout command again. Example:\rgit checkout -b \u0026lt;new-branch\u0026gt;\rHEAD is now at 99ada87... Merge pull request #89 from schacon/appendixfinal\r$ git checkout 2.0-beta-0.1\rPrevious HEAD position was 99ada87... Merge pull request #89 from\rschacon/appendix-final\rHEAD is now at df3f601... add atlas.json and cover image\r 在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何 分支，并且将无法访问，除非确切的提交哈希。因此，如果你需要进行更改——比如说你正在修复旧版本的错 误——这通常需要创建一个新分支：\n$ git checkout -b version2 v2.0.0\rSwitched to a new branch 'version2'\r 当然，如果在这之后又进行了一次提交，version2 分支会因为这个改动向前移动，version2 分支就会和 v2.0.0 标签稍微有些不同，这时就应该当心了。\nGit别名 如果不想每次都输入完整的Git命令，可以通过git config文件来为每一个命令设置一个别名。\n比如：\n$ git config --global alias.co checkout\r$ git config --global alias.br branch\r$ git config --global alias.ci commit\r$ git config --global alias.st status\r 这意味，当要输入git commit时，只需要输入git ci。\n","id":52,"section":"posts","summary":"打标签 打标签就是用于给历史中的某一个提交打上标签。 列出标签 在Git中列出已有的标签是非常直观的。只需要输入git tag。 当然，你可以使用特定","tags":["Git"],"title":"Git基本操作(2)","uri":"https://xuzhihao.top/2020/04/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C2/","year":"2020"},{"content":"在Push文件到github时候，出现了这个问题。这个问题是本地和Github中Repository中的文件出现冲突所造成的。在提交之前你需要将远端的改变合并到本地上。\n解决方法：\n方法一：\ngit fretch [remote-name]\rgit merge [remote-name]\r 方法二：\ngit push -f\r 这样会使你的本地代码替代git仓库内的内容。\n","id":53,"section":"posts","summary":"在Push文件到github时候，出现了这个问题。这个问题是本地和Github中Repository中的文件出现冲突所造成的。在提交之前你需","tags":["Git"],"title":"Git错误non-fast-forward后的解决方案","uri":"https://xuzhihao.top/2020/04/git%E9%94%99%E8%AF%AFnon-fast-forward%E5%90%8E%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","year":"2020"},{"content":"from PyQt5 import QtWidgets\rimport sys\rif __name__ == \u0026quot;__main__\u0026quot;:\rapp = QtWidgets.QApplication(sys.argv)\rw = QtWidgets.QWidgst()\rw.resize(600,600)\rw.move(600,600)\rw.setWindowTitle(\u0026quot;第一个Qt程序\u0026quot;)\rw.show()\rsys.exit(app.exec_())\r 其中，\napp = QtWidgets.QApplication(sys.argv)\r 每一个PyQt5程序都需要一个QApplication对象，QApplication类包含在QTWidgets模块中。sys.argv是一个命令行参数列表。这个程序可以通过，双击.py文件，通过参数来选择启动脚本的方式。\nsys.exit(app.exec_())\r 这是进入该程序的主循环。\n事件处理从本行代码开始，主循环接收事件消息并将其分发给程序的各个控件。如果调用 exit()或主控件被销毁，主循环就会结束。\n使用 sys.exit()方法退出可以确保程序完整地结束，在这种情况下系统的环境变量会记录程序是如何退出的。\n如果程序运行成功，那么exec_()的返回值为0，否则为非0。\n为什么程序主函数的返回值为0？ 无论是C还是C++，从main函数返回的结果都相当于调用了exit函数，main的返回值会作为传给exit函数的参数。 exit对参数的说明如下：\n 如果参数为0或EXIT_SUCCESS，则向外部环境报告程序运行圆满结束。 如果参数为EXIT_FAILURE，则向外部环境报告程序运行以失败告终。 如果参数为其他值，则结果由实现定义。  所以，return 0是有确定语义的返回方式，而return 1则不具备可移植性。\nPyQt 5的底层使用的就是C++，所以不难理解为什么主函数执行成功后exec_()的返回值为0了。\n有关exec_()的下画线问题解释如下： QApplication类的exec_()函数来自于PyQt 4及以前版本，因为在Python 2中，exec是Python的关键字，为避免冲突，PyQt 5使用了exec_()这个名称。这个问题在Python 3中已经解决，所以如果你的代码只在Python 3下运行，那么完全可以写成： app.exec() 当然，为了保持向后兼容，带有下画线的函数还是可以使用的，在本书后面的代码中将保持这种风格。\n","id":54,"section":"posts","summary":"from PyQt5 import QtWidgets import sys if __name__ == \u0026quot;__main__\u0026quot;: app = QtWidgets.QApplication(sys.argv) w = QtWidgets.QWidgst() w.resize(600,600) w.move(600,600) w.setWindowTitle(\u0026quot;第一个Qt程序\u0026quot;) w.show() sys.exit(app.exec_()) 其中， app = QtWidgets.QApplication(sys.argv) 每一个PyQt","tags":["PyQt5"],"title":"创建你的第一个GUI","uri":"https://xuzhihao.top/2020/04/%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAgui/","year":"2020"},{"content":"使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。\n分支简介 在进行提交操作时，Git会保存一个提交对象（commit object）。知道了Git保存数据的方式，我们可以想到——该提交对象包含一个指向暂存内容快照的指针。但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。\n首次提交产生的提交对象没有父对象，普通提交操作 产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，\n为了形象地说明，我们假设有一个工作目录，里面包含了三个将要被暂存和提交的文件。暂存操作会为每一个文件计算校验和，然后会把当前版本的文件快照保存到Git仓库中，最终将校验和加入到暂存区域等待提交：\n当使用git commit进行操作时，Git会先计算每一个子目录的校验和，然后在Git仓库中这些校验和保存为树对象。随后，Git便会创建一个提交对象，它除了包含上面提到的那些信息外， 还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。\n现在，Git仓库中有五个对象：三个blob对象（保存着文件快照）、一个树对象（记录着目录结构和blob对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。\n做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次对象（父对象）的指针。\nGit分支，其实本质上仅仅是指向提交对象的可变指针。Git的默认分支名字是master。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的master分支。它会在每次的提交操作中自动的向前移动。\n分支创建 Git通过为你创建一个可以移动的新指针，来为你创建新分支。\n比如：\ngit branch testing\r 这会在当前所在的提交对象上，创建一个指针。\n那么，Git又是怎么知道当前在哪一个分支上呢？也很简单，他有一个HEAD的特殊指针。\n在Git中，HEAD是一个指针，指向当前所在本地分支。在本例中，你仍然在master分支上。因为git branch命令仅仅创建一个新分支，并不会自动切换到新分支中去。\n你可以简单地使用git log命令查看各个分支当前所指的对象。提供这一功能的参数是--decorate。\n$ git log --oneline --decorate\rf30ab (HEAD, master, testing) add feature #32 - ability to add new\r34ac2 fixed bug #1328 - stack overflow under certain conditions\r98ca9 initial commit of my project\r 正如你所见，当前“master”和“testing”分支均指向校验和以f30ab开头的提供对象。\n分支切换 要切换到一个已存在的分支，你需要使用git checkout命令。我们现在切换到新建的testing分支去：\ngit checkout testing\r 这样HEAD就指向testing分支。\n那么，这样的实现方式会给我们咋样呢？\ngit commit -a -m 'made a chage'\r \n如图所示，你的testing分支向前移动了，但是master分支却没有，它仍然指向运行git checkout时所指的对象。这就有意思了，现在我们切换回master分支看看：\ngit checkout master\r 这条命令，做了两件事。\n一是，HEAD指回master分支，\n二是，将工作目录恢复成master分支所指向的快照内容。也就是说，你现在做的修改的话，项目将始于一个较旧的版本。本质就是，忽略testing分支所做的修改，以便于向另一个方向进行开发。\n 分支切换会改变你工作目录中的文件。\n在切换分支时，一定要注意你工作目录里的文件会被改变，如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如果Git不能干净利落地完成这个任务，他将禁止切换分支。\n 这时，我们运行这个\ngit commit -a -m 'made oher changes'\r 现在，这个项目的提交历史已经产生了分叉。\n因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回master分支进行了另外一些工作。上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。而所有这些工作，你需要的命令只有branch、checkout和commit。\n咱们可以通过git log --online --decorate --graph --all,它会输出你的提交历史、各个分支指向以及项目的分支分叉情况。\n","id":55,"section":"posts","summary":"使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 分支简介 在进行提交操作时，Git会保存一个提交对象（commit obj","tags":["Git"],"title":"Git分支(1)","uri":"https://xuzhihao.top/2020/04/git%E5%88%86%E6%94%AF1/","year":"2020"},{"content":"shelve可以当做是简单的存储。\n使用方法如下：\nimport shelve\rd = shelve.open(filename) # open -- file may get suffix added by low-level\r# library\rd[key] = data # store data at key (overwrites old data if\r# using an existing key)\rdata = d[key] # retrieve a COPY of data at key (raise KeyError\r# if no such key)\rdel d[key] # delete data stored at key (raises KeyError\r# if no such key)\rflag = key in d # true if the key exists\rklist = list(d.keys()) # a list of all existing keys (slow!)\r# as d was opened WITHOUT writeback=True, beware:\rd['xx'] = [0, 1, 2] # this works as expected, but...\rd['xx'].append(3) # *this doesn't!* -- d['xx'] is STILL [0, 1, 2]!\r# having opened d without writeback=True, you need to code carefully:\rtemp = d['xx'] # extracts the copy\rtemp.append(5) # mutates the copy\rd['xx'] = temp # stores the copy right back, to persist it\r# or, d=shelve.open(filename,writeback=True) would let you just code\r# d['xx'].append(5) and have it work as expected, BUT it would also\r# consume more memory and make the d.close() operation slower.\rd.close() # close it\r **注意：**正如，上面示例所表明的。\n比如：\n\u0026gt;\u0026gt;\u0026gt;import shelve\r\u0026gt;\u0026gt;\u0026gt;a = shelve.open('test.dat')\r\u0026gt;\u0026gt;\u0026gt;a['x'] = ['a','b','c']\r\u0026gt;\u0026gt;\u0026gt;a['x'].append('d')\r\u0026gt;\u0026gt;\u0026gt;a['x']\r['a','b','c']\r 这里的\u0026rsquo;d'没有存储在\u0026rsquo;x'下面。\n你需要做得是像这样：\n\u0026gt;\u0026gt;\u0026gt;temp = a['x']\r\u0026gt;\u0026gt;\u0026gt;temp.append('d')\r\u0026gt;\u0026gt;\u0026gt;a['x'] = temp\r\u0026gt;\u0026gt;\u0026gt;a['x']\r['a','b','c','d']\r 因为Python的语法的问题，当一个易变的持久化字典条目被修改的时候，shelve不能察觉。\n但如果writeback被设定为True，所有的被访问条目也缓存在内存中，并依靠sync()和close()写回内存中。这可以让它方便,写入可变持久字典条目,但是,如果访问许多条目,它可以消耗大量的内存缓存,它可以关闭操作非常慢,因为所有访问条目都被写入(没有办法确定哪些条目是可变的,哪些是没变的)。\n注意，最后要使用close()，不让数据不会存入都内存中。像下面这样也是可以的。\nwith shelve.open('spam') as db:\rdb['eggs'] = 'eggs'\r ","id":56,"section":"posts","summary":"shelve可以当做是简单的存储。 使用方法如下： import shelve d = shelve.open(filename) # open -- file may get suffix added by low-level # library d[key] = data # store data at key (overwrites old data if # using an existing key) data = d[key] # retrieve a COPY of data at key (raise","tags":["Python标准库"],"title":"Python中的shelve","uri":"https://xuzhihao.top/2020/04/python%E4%B8%AD%E7%9A%84shelve/","year":"2020"},{"content":"PyInstaller原理 PyInstaller其实就是把Python解释器和脚本打包成一个可执行文件，和编译成真正的机器码完全是两回事。所以，千万不要指望打包成的可执行文件会提高运行效率，相反，可能会降低运行效率，但是这样做得好处是运行的机器上不用安装Python和脚本依赖的库。\n需要注意的是，使用PyInstaller打包生成的程序，只能在与生成打包的机器系统相同的环境中运行。也就是说，这个可执行文件不具备可移植性。若需要在不同的操作系统上运行，就必须在该系统环境上重新进行打包。\n安装PyInstaller pip install PyInstaller\r PyInstall安装后，我们在Python的安装目录Scripts中可以找到pyinstaller.exe应用。\n使用PyInstaller 在命令行中进入需要打包的代码所在目录下，运行\npyinstaller [opts]yourprogram.py\r 可选参数：\n -F,-onefile,打包成一个EXE文件 -D,-onedir ,创建一个目录，包含EXE文件，但会依赖很多文件 -w(小写w),-windowed,-noconsole,使用窗口，无控制台  最后在同目录下的dist子文件中生成EXE文件\n这里重复说明一下：在Windows64位上编译，也只能在64位上运行\n给程序装一个图标 我们首先去下载一个ico格式的图标文件。将这个ico文件放在项目路径下面。\n注：在Mac上打包要下载.icns格式的图标文件\n在命令行运行：\npyinstaller -F -w -i ./[your ico].ico [your programme].py\r 这里新增的-i就是给程序添加图标的命令，我们需要在该命令后添加图标的路径，这个路径可以是相对路径，也可以是绝对路径.\n打包成功后，我们就可以在dist文件夹中看到加上了自定义图标的可执行文件： **注：**图标文件已经被打包进去，所以我们可以删掉，不会有关系。\n提示：\n 不能通过修改后缀名来获得一个ico文件，这样导致出现错误 图标不出现，也有可能是由于缓存的问题。其实打包成功了，但在dist文件夹中还没有显示。读者只需要把生成的可执行文件拖到其他文件夹中就会发现图标显示正常了。  ","id":57,"section":"posts","summary":"PyInstaller原理 PyInstaller其实就是把Python解释器和脚本打包成一个可执行文件，和编译成真正的机器码完全是两回事。所","tags":null,"title":"打包Python程序","uri":"https://xuzhihao.top/2020/04/%E6%89%93%E5%8C%85python%E7%A8%8B%E5%BA%8F/","year":"2020"},{"content":"提交给Google网站站长 打开 Google网站站长，点击 “SEARCH CONSOLE ” 进入，然后添加资源。\n会要求下载一个html文件如google571325××××.html做验证，将这个文件保存到hugo站点根目录下的static子目录，更新站点内容让google search console可以访问到进行验证即可。\n进入资源页面，点”索引”下的”站点地图”，在”添加新的站点地图”处输入当前hugo站点的sitemap，这个文件hugo会默认生成，就在根路径下，如https://zhihao2020.github.io/sitemap.xml。\n百度搜索优化 打开 百度搜索资源平台 ，点击 链接提交，然后点”添加站点”。同样可以用文件验证的方式来进行网站验证。\n进入”数据引入”下的”链接提交”，再点 “自动提交” 下的 “sitemap”，在这里可以提交hugo网站的sitemap文件。\n注意百度不容许以子目录的方式提交子站点，和google不一样，只能在提交sitemap文件时，提交多个sitemap文件。这样也能勉强让百度收录。\n参考资料# 有参考以下资料，特此鸣谢：\n 搜索引擎优化（SEO）: 来自宋静超的hugo handbook Front-End-Checklist - Github SEO 查询 - 站长之家 SEO Meta Tags Meta Description 从Hexo迁移到Hugo-送漂亮的Hugo Theme主题 Hugo website SEO Hugo SEO Markup 搜索引擎优化  ","id":58,"section":"posts","summary":"提交给Google网站站长 打开 Google网站站长，点击 “SEARCH CONSOLE ” 进入，然后添加资源。 会要求下载一个html文件如google571","tags":null,"title":"让Google和百度搜索到你的Hugo博客","uri":"https://xuzhihao.top/2020/04/%E8%AE%A9google%E5%92%8C%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%88%B0%E4%BD%A0%E7%9A%84hugo%E5%8D%9A%E5%AE%A2/","year":"2020"},{"content":"调用 关于 __call__ 方法，不得不先提到一个概念，就是可调用对象（callable），我们平时自定义的函数、内置函数和类都属于可调用对象，但凡是可以把一对括号()应用到某个对象身上都可称之为可调用对象，判断对象是否为可调用对象可以用函数 __call__有无。\n如果在类中实现了 __call__ 方法，那么实例化对象也将成为一个可调用对象，\n __call__(self, [args\u0026hellip;])\n __call __ 在那些类的实例经常改变状态的时候会非常有效。调用这个实例是一种改变这个对象状态的直接和优雅的做法。用一个实例来表达最好不过了:\nclass Entity:\r'''调用实体来改变实体的位置。'''\rdef __init__(self, size, x, y):\rself.x, self.y = x, y\rself.size = size\rdef __call__(self, x, y):\r'''改变实体的位置'''\rself.x, self.y = x, y\re = Entity(1, 2, 3) // 创建实例\re(4, 5) //实例可以象函数那样执行，并传入x y值，修改对象的x y\r __call__其他作用 实例对象也可以像函数一样作为可调用对象来用，那么，这个特点在什么场景用得上呢？\n这个要结合类的特性来说，类可以记录数据（属性），而函数不行（闭包某种意义上也可行），利用这种特性可以实现基于类的装饰器，在类里面记录状态，比如，下面这个例子用于记录函数被调用的次数：\nclass Counter:\rdef __init__(self, func):\rself.func = func\rself.count = 0\rdef __call__(self, *args, **kwargs):\rself.count += 1\rreturn self.func(*args, **kwargs)\r@Counter\rdef foo():\rpass\rfor i in range(10):\rfoo()\rprint(foo.count) # 10\r ","id":59,"section":"posts","summary":"调用 关于 __call__ 方法，不得不先提到一个概念，就是可调用对象（callable），我们平时自定义的函数、内置函数和类都属于可调用对象，但凡是可以把一","tags":["Python魔法方法"],"title":"Python中的__call__方法","uri":"https://xuzhihao.top/2020/04/python%E4%B8%AD%E7%9A%84__call__/","year":"2020"},{"content":" 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法\n __new__的作用 在Python中__new__方法与__init__方法类似，但是如果两个都存在那么__new__会先执行。\n在基础类object中，__new__被定义成了一个静态方法，并且需要传递一个参数cls。Cls表示需要实例化的类，此参数在实例化时由Python解析器自动提供。\nnew()是在新式类中新出现的方法，它作用在构造方法init()建造实例之前，可以这么理解，在Python 中存在于类里面的构造方法init()负责将类的实例化，而在init()调用之前，new()决定是否要使用该init()方法，因为new()可以调用其他类的构造方法或者直接返回别的对象来作为本类 的实例。\nnew()方法的特性 new()方法是在类准备将自身实例化时调用。\nnew()方法始终都是类的静态方法，即使没有被加上静态方法装饰器。\n实例 class Person(object):\rdef __new__(cls, name, age):\rif 0 \u0026lt; age \u0026lt; 150:\rreturn object.__new__(cls)\r# return super(Person, cls).__new__(cls)\relse:\rreturn None\rdef __init__(self, name, age):\rself.name = name\rself.age = age\rdef __str__(self):\rreturn '{0}({1})'.format(self.__class__.__name__, self.__dict__)\rprint(Person('Tom', 10))\rprint(Person('Mike', 200))\r 输出：\nPerson({'age': 10, 'name': 'Tom'})\rNone\r ","id":60,"section":"posts","summary":"在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 __new__的作用 在Python中__new_","tags":["Python魔法方法"],"title":"Python中的__new__方法","uri":"https://xuzhihao.top/2020/04/python%E4%B8%AD%E7%9A%84__new__/","year":"2020"},{"content":" 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法\n class Cat:\rdef __init__(self, new_name, new_age):\r\u0026quot;\u0026quot;\u0026quot;在创建完对象之后 会自动调用, 它完成对象的初始化的功能\u0026quot;\u0026quot;\u0026quot;\rself.name = new_name\rself.age = new_age def __str__(self):\r\u0026quot;\u0026quot;\u0026quot;返回一个对象的描述信息\u0026quot;\u0026quot;\u0026quot;\rreturn \u0026quot;名字是:%s , 年龄是:%d\u0026quot; % (self.name, self.age)\rdef eat(self):\rprint(\u0026quot;%s在吃鱼....\u0026quot; % self.name)\rdef drink(self):\rprint(\u0026quot;%s在喝可乐...\u0026quot; % self.name)\r# 创建了一个对象\rtom = Cat(\u0026quot;汤姆\u0026quot;, 30)\rprint(tom)\rprint(tom.eat())\rprint(tom.drink())\r 输出\n名字是:汤姆 , 年龄是:30\r汤姆在吃鱼....\rNone\r汤姆在喝可乐...\rNone\r ","id":61,"section":"posts","summary":"在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 class Cat: def __init__(self, new_name, new_age): \u0026quot;\u0026quot;\u0026quot;","tags":["Python魔法方法"],"title":"Python中的__str__方法","uri":"https://xuzhihao.top/2020/04/python%E4%B8%AD%E7%9A%84__str__/","year":"2020"},{"content":"@classmethod 返回函数的类方法\nclassmethod修饰符对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的cls参数，可以调用类的属性，类的方法，实例化对象等。\n实例 class test(object):\rbar = 1\rdef func1(self): print ('AAA') @classmethod\rdef func2(cls):\rprint ('func2')\rprint (cls.bar)\rcls().func1() test.func2() # 不需要实例化\r 输出：\nfunc2\r1\rAAA\r @staticmethod 返回函数的静态方法\nclass test(object):\r@staticmethod\rdef fun():\rprint('hello');\rtest.fun() # 静态方法无需实例化\robj = test()\robj.fun() # 也可以实例化后调用\r 输出：\nhello\rhello\r ","id":62,"section":"posts","summary":"@classmethod 返回函数的类方法 classmethod修饰符对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的cls参数，可以调用","tags":["Python内建函数"],"title":"Python中的staticmethod和classmethod","uri":"https://xuzhihao.top/2020/04/python%E4%B8%AD%E7%9A%84staticmethod%E5%92%8Cclassmethod/","year":"2020"},{"content":"介绍 **super()**函数是用于条用父类（超类)的一个方法。\nsuper 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用等种种问题。\nspuer()的使用案例 class Parent(object):\rdef __init__(self):\rself.parent = 'I\\'m the parent.'\rprint('Parent')\rdef bar(self, message):\rprint(\u0026quot;%s from Parent\u0026quot; % message)\rclass Child(Parent):#单继承\rdef __init__(self):\r# super(Child,self) 首先找到 Child 的父类（就是类 Parent），然后把Parent中的东西继承过来了。\rsuper(Child, self).__init__()\rprint('Child')\rdef bar(self, message):\rself.bar(message)\rprint('Child bar fuction')\rprint(self.parent)\rif __name__ == '__main__':\rfooChild = Child()\rfooChild.bar('HelloWorld')\r Parent\rChild\rHelloWorld from Parent\rChild bar fuction\rI'm the parent.\r ","id":63,"section":"posts","summary":"介绍 **super()**函数是用于条用父类（超类)的一个方法。 super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，","tags":["Python内建函数"],"title":"Python中的super()函数","uri":"https://xuzhihao.top/2020/04/python%E4%B8%AD%E7%9A%84super%E5%87%BD%E6%95%B0/","year":"2020"},{"content":"函数也是对象 首先要明确一个概念，函数也是对象。\n于是，函数本身其实可以与其他的数据类型一样，作为其他函数的参数或者返回值。\ndef decorator(func):\rdef wrapper():\rprint(\u0026quot;we can do sth.Befor the func() is called...\u0026quot;)\rfunc()\rprint(\u0026quot;... and we can do sth. After it is called.. \u0026quot;)\rreturn wrapper()\rdef func()\rprint(\u0026quot;Hi, I'm func!\u0026quot;)\rfunc()\rdecorator(func)\r 输出如下：\nHi, I'm a_func!\rWe can do sth. before a func is called...\rHi, I'm a_func!\r... and we can do sth. after it is called...\r 但是，如果这样，那就不同了：\ndef decorator(func):\rdef wrapper():\rprint('We can do sth. before a func is called...')\rfunc()\rprint('... and we can do sth. after it is called...')\rreturn wrapper def func():\rprint(\u0026quot;Hi, I'm a_func!\u0026quot;)\rfunc()\rdecorator(func)\r Hi, I'm a_func!\r\u0026lt;function __main__.a_decorator.\u0026lt;locals\u0026gt;.wrapper()\u0026gt;\r 其实，这里 wrapper 是返回这个函数本身，而wrapper()则是返回这个函数的返回值。\n装饰器操作符 Python提供了一个针对函数的操作符@。\ndef decorator(func):\rdef wrapper():\rprint('We can do sth. before calling a_func...')\rfunc()\rprint('... and we can do sth. after it was called...')\rreturn wrapper\r@decorator\rdef func():\rprint(\u0026quot;Hi, I'm func!\u0026quot;)\rfunc()\r We can do sth. before calling a_func...\rHi, I'm a_func!\r... and we can do sth. after it was called...\r  注意：以上的代码中，decorator(func) 返回的是 wrapper 这个函数本身。而不是wrapper的返回值。\n 其中， 被 @ 调用的函数，叫做 “装饰器”（Decorator），比如，以上代码中的 decorator(func)。\n现在可以很简单直接地说清楚装饰器的作用了：\n@decorator\rdef func():\r...\r 等价于\ndef func():\r...\rfunc = decorator(func)\r 就是用 decorator 的调用结果替换掉原来的函数。decorator 返回值是什么，以后调用 func 时就是在调用这个返回值，而 decorator 本身此时已经执行完毕了。\n装饰器的用途 Decorator 最常用的场景是什么呢？最常用的场景就是用来改变其它函数的行为。\ndef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r The quick brown fox jumps over the lazy dog.\r def uppercase(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = original_result.upper()\rreturn modified_restult\rreturn wrapper\r@uppercase\rdef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\r 你还可以给一个函数加上一个以上的装饰器：\ndef uppercase(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = original_result.upper()\rreturn modified_restult\rreturn wrapper\rdef strong(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = '\u0026lt;strong\u0026gt;'+original_result+'\u0026lt;/strong\u0026gt;'\rreturn modified_restult\rreturn wrapper\r@uppercase\r@strong\rdef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r \u0026lt;STRONG\u0026gt;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\u0026lt;/STRONG\u0026gt;\r 你把两个装饰器的顺序调换一下写成下面这样试试：\n@uppercase\r@strong\rdef an_output():\r...\r 装饰器的执行顺序是 “自下而上” —— 其实是 “由里到外” 更为准确。体会一下。\n装饰带有参数的函数 到现在我们见到的使用装饰器的函数都是没有参数的：an_output 以及之前的 func。\n如果被装饰的函数有参数怎么办？装饰器自身内部又应该怎么写？\n这时候，Python 的 *args and **kwargs 的威力就显现出来了。\n装饰器函数本身这么写：\ndef decorator(func):\rdef wrapper(*args, **kwargs):\rreturn original_result\r# ... return wrapper\r 在这里，(*args, **kwargs) 非常强大，它可以匹配所有函数传进来的所有参数…… 准确地讲，*args 接收并处理所有传递进来的位置参数，**kwargs 接收并处理所有传递进来的关键字参数。\n假设我们有这么个函数：\ndef say_hi(greeting, name=None):\rreturn greeting + '! ' + name + '.'\rprint(say_hi('Hello', 'Jack'))\r Hello! Jack.\r 如果我们想在装饰器里对函数名、参数，都做些事情 —— 比如，我们写个 @trace 用来告诉用户调用一个函数的时候都发生了什么……\ndef trace(func):\rdef wrapper(*args, **kwargs):\rprint(f\u0026quot;Trace: You've called a function: {func.__name__}(),\u0026quot;,\rf\u0026quot;with args: {args}; kwargs: {kwargs}\u0026quot;)\roriginal_result = func(*args, **kwargs)\rprint(f\u0026quot;Trace: {func.__name__}{args} returned: {original_result}\u0026quot;)\rreturn original_result\rreturn wrapper\r@trace\rdef say_hi(greeting, name=None):\rreturn greeting + '! ' + name + '.'\rprint(say_hi('Hello', name = 'Jack'))\r Trace: You've called a function: say_hi(), with args: ('Hello',); kwargs: {'name': 'Jack'}\rTrace: say_hi('Hello',) returned: Hello! Jack.\rHello! Jack.\r ","id":64,"section":"posts","summary":"函数也是对象 首先要明确一个概念，函数也是对象。 于是，函数本身其实可以与其他的数据类型一样，作为其他函数的参数或者返回值。 def decorator(func): def wrapper(): print(\u0026quot;we can do sth.Befor the func()","tags":null,"title":"Python中的装饰器(1)","uri":"https://xuzhihao.top/2020/04/python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A81/","year":"2020"},{"content":"函数也是对象 首先要明确一个概念，函数也是对象。\n于是，函数本身其实可以与其他的数据类型一样，作为其他函数的参数或者返回值。\ndef decorator(func):\rdef wrapper():\rprint(\u0026quot;we can do sth.Befor the func() is called...\u0026quot;)\rfunc()\rprint(\u0026quot;... and we can do sth. After it is called.. \u0026quot;)\rreturn wrapper()\rdef func()\rprint(\u0026quot;Hi, I'm func!\u0026quot;)\rfunc()\rdecorator(func)\r 输出如下：\nHi, I'm a_func!\rWe can do sth. before a func is called...\rHi, I'm a_func!\r... and we can do sth. after it is called...\r 但是，如果这样，那就不同了：\ndef decorator(func):\rdef wrapper():\rprint('We can do sth. before a func is called...')\rfunc()\rprint('... and we can do sth. after it is called...')\rreturn wrapper def func():\rprint(\u0026quot;Hi, I'm a_func!\u0026quot;)\rfunc()\rdecorator(func)\r Hi, I'm a_func!\r\u0026lt;function __main__.a_decorator.\u0026lt;locals\u0026gt;.wrapper()\u0026gt;\r 其实，这里 wrapper 是返回这个函数本身，而wrapper()则是返回这个函数的返回值。\n装饰器操作符 Python提供了一个针对函数的操作符@。\ndef decorator(func):\rdef wrapper():\rprint('We can do sth. before calling a_func...')\rfunc()\rprint('... and we can do sth. after it was called...')\rreturn wrapper\r@decorator\rdef func():\rprint(\u0026quot;Hi, I'm func!\u0026quot;)\rfunc()\r We can do sth. before calling a_func...\rHi, I'm a_func!\r... and we can do sth. after it was called...\r  注意：以上的代码中，decorator(func) 返回的是 wrapper 这个函数本身。而不是wrapper的返回值。\n 其中， 被 @ 调用的函数，叫做 “装饰器”（Decorator），比如，以上代码中的 decorator(func)。\n现在可以很简单直接地说清楚装饰器的作用了：\n@decorator\rdef func():\r...\r 等价于\ndef func():\r...\rfunc = decorator(func)\r 就是用 decorator 的调用结果替换掉原来的函数。decorator 返回值是什么，以后调用 func 时就是在调用这个返回值，而 decorator 本身此时已经执行完毕了。\n装饰器的用途 Decorator 最常用的场景是什么呢？最常用的场景就是用来改变其它函数的行为。\ndef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r The quick brown fox jumps over the lazy dog.\r def uppercase(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = original_result.upper()\rreturn modified_restult\rreturn wrapper\r@uppercase\rdef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\r 你还可以给一个函数加上一个以上的装饰器：\ndef uppercase(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = original_result.upper()\rreturn modified_restult\rreturn wrapper\rdef strong(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = '\u0026lt;strong\u0026gt;'+original_result+'\u0026lt;/strong\u0026gt;'\rreturn modified_restult\rreturn wrapper\r@uppercase\r@strong\rdef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r \u0026lt;STRONG\u0026gt;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\u0026lt;/STRONG\u0026gt;\r 你把两个装饰器的顺序调换一下写成下面这样试试：\n@uppercase\r@strong\rdef an_output():\r...\r 装饰器的执行顺序是 “自下而上” —— 其实是 “由里到外” 更为准确。体会一下。\n装饰带有参数的函数 到现在我们见到的使用装饰器的函数都是没有参数的：an_output 以及之前的 func。\n如果被装饰的函数有参数怎么办？装饰器自身内部又应该怎么写？\n这时候，Python 的 *args and **kwargs 的威力就显现出来了。\n装饰器函数本身这么写：\ndef decorator(func):\rdef wrapper(*args, **kwargs):\rreturn original_result\r# ... return wrapper\r 在这里，(*args, **kwargs) 非常强大，它可以匹配所有函数传进来的所有参数…… 准确地讲，*args 接收并处理所有传递进来的位置参数，**kwargs 接收并处理所有传递进来的关键字参数。\n假设我们有这么个函数：\ndef say_hi(greeting, name=None):\rreturn greeting + '! ' + name + '.'\rprint(say_hi('Hello', 'Jack'))\r Hello! Jack.\r 如果我们想在装饰器里对函数名、参数，都做些事情 —— 比如，我们写个 @trace 用来告诉用户调用一个函数的时候都发生了什么……\ndef trace(func):\rdef wrapper(*args, **kwargs):\rprint(f\u0026quot;Trace: You've called a function: {func.__name__}(),\u0026quot;,\rf\u0026quot;with args: {args}; kwargs: {kwargs}\u0026quot;)\roriginal_result = func(*args, **kwargs)\rprint(f\u0026quot;Trace: {func.__name__}{args} returned: {original_result}\u0026quot;)\rreturn original_result\rreturn wrapper\r@trace\rdef say_hi(greeting, name=None):\rreturn greeting + '! ' + name + '.'\rprint(say_hi('Hello', name = 'Jack'))\r Trace: You've called a function: say_hi(), with args: ('Hello',); kwargs: {'name': 'Jack'}\rTrace: say_hi('Hello',) returned: Hello! Jack.\rHello! Jack.\r ","id":65,"section":"posts","summary":"函数也是对象 首先要明确一个概念，函数也是对象。 于是，函数本身其实可以与其他的数据类型一样，作为其他函数的参数或者返回值。 def decorator(func): def wrapper(): print(\u0026quot;we can do sth.Befor the func()","tags":null,"title":"Python中的装饰器(1)","uri":"https://xuzhihao.top/2020/04/python%E7%9A%84%E5%87%BD%E6%95%B0%E5%B7%A5%E5%85%B71/","year":"2020"},{"content":"配置文件： [numbers]\rpi: 3.1415926\r[messages]\rgreeting: welcome to the area calculation program!\rquestion: Please emter the radius\rresult_message: The area is\r 使用示例 from ConfigParser import ConfigParser\rCONFIGFILE = ‘XXX.ini'\rconfig = ConfigParser()\r#读取配置文件\rconfig.read(CONFIGFILE)\r#打印初始问候语\r#要查看的区段是’messages‘\rprint(config.get('messages','greeting'))\r#使用配置文件的一个问题读取半径：\rradius = input(config.get('messages','question')+' ')\r#打印配置文件中的结果信息\r#以逗号结束，以在同一行显示\rprint(config.get('messages','result_message'))\r#getfloat()将config值转换为float类型\rprint(config.getfloat('numbers','pi') * radius **2)\r 方法 写入:\nimport configparser\rconfig = configparser.ConfigParser()\rconfig['DEFAULT'] = {'ServerAliveInterval': '45',\r'Compression': 'yes',\r'CompressionLevel': '9'}\rconfig['bitbucket.org'] = {}\rconfig['bitbucket.org']['User'] = 'hg'\rconfig['topsecret.server.com'] = {}\rtopsecret = config['topsecret.server.com']\rtopsecret['Port'] = '50022' # mutates the parser\rtopsecret['ForwardX11'] = 'no' # same here\rconfig['DEFAULT']['ForwardX11'] = 'yes'\rwith open('example.ini', 'w') as configfile:\rconfig.write(configfile)\r 注意： 它不去猜测配置文件中值得数据类型，而是始终将他们内部存储为字符串。\n于是提供了getint()、getfloat和getboolean()方法。\n例如，gwtboolean()用于处理布尔值，此方法不区分大小写，并从并从'yes'/ 'no'，'on'/ 'off'， 'true'/ 'false'和'1'/ '0' 识别布尔值。\n","id":66,"section":"posts","summary":"配置文件： [numbers] pi: 3.1415926 [messages] greeting: welcome to the area calculation program! question: Please emter the radius result_message: The area is 使用示例 from ConfigParser import ConfigParser CONFIGFILE = ‘XXX.ini' config = ConfigParser() #读取配置文件 config.read(CONFIGFILE) #打印初始问候语 #要查看的区段","tags":["Python标准库"],"title":"Python的一种简单配置文件的方法","uri":"https://xuzhihao.top/2020/04/python%E7%9A%84%E4%B8%80%E7%A7%8D%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/","year":"2020"},{"content":"面向对象的三大基本特性，五大基本原则 透切理解面向对象三大基本特性是理解面向对象五大基本原则的基础.\n三大特性是：封装,继承,多态 封装 封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n继承 面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”。 被继承的类称为“基类”、“父类”或“超类”。 继承的过程，就是从一般到特殊的过程。 要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。 在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。\n继承概念的实现方式有三类：实现继承、接口继承和可视继承。\n  实现继承是指使用基类的属性和方法而无需额外编码的能力.\n  接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；\n  可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力\n  多态 一种事物的多种体现形式，函数的重写其实就是多态的一种体现\n在Python中，多态指的是父类的引用指向子类的对象\n那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。\n五大基本原则 单一职责原则SRP(Single Responsibility Principle) 是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。\n开放封闭原则OCP(Open－Close Principle) 一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能， 那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。\n替换原则(the Liskov Substitution Principle LSP) 子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工， 也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。\n依赖原则(the Dependency Inversion Principle DIP) 具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能， 这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到 了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。\n接口分离原则(the Interface Segregation Principle ISP) 模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来\n","id":67,"section":"posts","summary":"面向对象的三大基本特性，五大基本原则 透切理解面向对象三大基本特性是理解面向对象五大基本原则的基础. 三大特性是：封装,继承,多态 封装 封装最好理","tags":null,"title":"面向对象的三大特性和五大原则","uri":"https://xuzhihao.top/2020/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%92%8C%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99/","year":"2020"},{"content":"JupyterLab 有两种键盘输入模式，分别为编辑模式和命令模式。\n一、命令行模式 (按键 Esc 开启) 命令行模式：键盘输入运行程序命令；这时的单元框线是灰色。\n   快捷键 实现的功能 快捷键 实现的功能     Enter 转入编辑模式 V 粘贴到下方单元   Shift + Enter 运行本单元，选中下个单元 Z 恢复删除的最后一个单元   Ctrl + Enter 运行本单元 连按两下D 删除选中的单元   Alt + Enter 运行本单元，在其下插入新单元 Shift + M 合并选中的单元   Y 单元转入代码状态 Ctrl + S 文件存盘   M 单元转入markdown状态 S 文件存盘   R 单元转入raw状态 L 转换行号   1 设定 1 级标题 O 转换输出   2 设定 2 级标题 Shift + O 转换输出滚动   3 设定 3 级标题 Esc 关闭页面   4 设定 4 级标题 Q 关闭页面   5 设定 5 级标题 H 显示快捷键帮助   6 设定 6 级标题 I,I 中断Notebook内核   Up 选中上方单元 连按两下数字0 重启Notebook内核   Down 选中下方单元 Shift 忽略   K 选中上方单元 Shift + Space 向上滚动   J 选中下方单元 Space 向下滚动   Shift + K 扩大选中上方单元 Shift + J 扩大选中下方单元   A 在上方插入新单元 B 在下方插入新单元   X 剪切选中的单元 C 复制选中的单元   Shift + V 粘贴到上方单元      二、编辑模式 ( Enter 键启动) 编辑模式：允许你往单元中键入代码或文本；这时的单元框线是绿色的。\n   快捷键 实现的功能 快捷键 实现的功能     Tab 代码补全或缩进 Shift + Tab 提示   Ctrl + ] 缩进 Ctrl + [ 解除缩进   Ctrl + A 全选 Ctrl + Z 复原   Ctrl + Shift + Z 再做 Ctrl + Y 再做   Ctrl + Home 跳到单元开头 Ctrl + End 跳到单元末尾   Ctrl + Up 跳到单元开头 Ctrl + Down 跳到单元末尾   Ctrl + Left 跳到左边一个字首 Ctrl + Right 跳到右边一个字首   Ctrl + Backspace 删除前面一个字 Esc 进入命令模式   Ctrl + Delete 删除后面一个字 Shift + Enter 运行本单元，选中下一单元   Ctrl + M 进入命令模式 Ctrl + Enter 运行本单元   Alt + Enter 运行本单元，在下面插入一单元 Ctrl + Shift + + 分割单元   Ctrl + S 文件存盘 Ctrl + Shift + Subtract 分割单元   Up 光标上移或转入上一单元 Down 光标下移或转入下一单元   Shift 忽略      ","id":68,"section":"posts","summary":"JupyterLab 有两种键盘输入模式，分别为编辑模式和命令模式。 一、命令行模式 (按键 Esc 开启) 命令行模式：键盘输入运行程序命令；这时的单元框线是灰色。 快捷键 实","tags":["JupyterLab"],"title":"JupyterLab快捷键","uri":"https://xuzhihao.top/2020/04/jupyterlab%E5%BF%AB%E6%8D%B7%E9%94%AE/","year":"2020"},{"content":"测试驱动是先写测试代码，然后写功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码\nunittest最早由JUnit启发而来。它支持自动化测试，分享结构，关闭测试代码，将测试聚合到集合中，并使测试独立于报告框架。\n为了实现这些功能，unittest以面向对象的方式提供了一些重要的概念：\n test fixture(测试固件)  测试装置表示执行一个或多个测试所需的准备工作，以及任何相关的清理操作。例如，这可能涉及创建临时或代理数据库、目录或启动服务器进程。\n test case（测试案例）  测试用例是测试的单个单元。它检查对特定输入集的特定响应。unittest提供了一个基类TestCase，它可以用来创建新的测试用例。\n test suite（测试套件）  测试套件是测试用例、测试套件或两者的集合。它用于聚合(aggregate)应该一起执行的测试。\n test runner（测试运行器）  测试运行器是一个组件，它编排测试的执行并向用户提供结果。运行程序可以使用图形界面、文本界面或返回一个特殊值来指示执行测试的结果。\n基本实例 unittest模块提供了构造和运行测试丰富组件。\nimport unittest\rclass TestStringMethods(unittest.TestCase):\rdef test_upper(self):\rself.assertEqual('foo'.upper(), 'FOO')\rdef test_isupper(self):\rself.assertTrue('FOO'.isupper())\rself.assertFalse('Foo'.isupper())\rdef test_split(self):\rs = 'hello world'\rself.assertEqual(s.split(), ['hello', 'world'])\r# check that s.split fails when the separator is not a string\rwith self.assertRaises(TypeError):\rs.split(2)\rif __name__ == '__main__':\runittest.main()\r testcase是通过子类化unittest.TestCase来创建的。这三个单独的测试是用名称以字母test开头的方法定义的。这个命名约定通知测试运行程序哪些方法表示测试。\n每个测试的关键是调用assertEqual()来检查期望的结果；assertTrue()或assertFalse()来验证条件；或assertRaises来验证是否引发了特定的异常。这些方法替代了assert语句，因此这些测试接货可以最终生成报告。\nsetUp()和tearDown()方法允许你定义能在测试方法之前和之后执行的指令。\n最后的代码是运行这个测试的简单方法。unittest.main()t提供了测试脚本的命令行接口。当从命令行运行时，上面的脚本生成如下的输出：\n...\r------------------------------------------------------------\rRan 3 tests in 0.000s\rOK\r 将-v传输到你的测试代码将使unittest.main()开始更高级的说明。比如像下面：\ntest_isupper (__main__.TestStringMethods) ... ok\rtest_split (__main__.TestStringMethods) ... ok\rtest_upper (__main__.TestStringMethods) ... ok\r----------------------------------------------------------------------\rRan 3 tests in 0.001s\rOK\r 上面的例子展示了最常用的unittest特性，这些特性足以满足许多日常的测试需求。文档的其余部分将探索来自first principles的完整特性集。\n命令行界面 可以从命令行使用unittest模块\n比如\npython -m unittest test_module1 test_module2\rpython -m unittest test_module.TestClass\rpython -m unittest test_module.TestClass.test_method\r 测试模块也可以通过文件路径指定：\npython -m unittest tests/test_something.py\r 这使您可以使用Shell文件名补全来指定测试模块。指定的文件必须仍然可以作为模块导入。通过删除“ .py”并将路径分隔符转换为“。”，可将该路径转换为模块名称。如果要执行不可作为模块导入的测试文件，则应直接执行该文件。\n您可以通过传递-v标志来更详细（更详细）地运行测试：\npython -m unittest -v test_module\r 在不带参数的情况下执行时，将启动“ 测试发现”：\npython -m unittest\r 有关所有命令行选项的列表：\npython -m unittest -h\r 组织测试代码 单元测试的基本构建模块是测试用例 —必须设置单个场景并检查其正确性。在中unittest，测试用例由unittest.TestCase实例表示。要制作自己的测试用例，必须编写TestCase或的子类 FunctionTestCase。\nTestCase实例的测试代码应完全独立，以使它可以隔离运行，也可以与任意数量的其他测试用例任意组合运行。\n最简单的TestCase子类将简单地实现一个测试方法（即名称以开头的方法test），以执行特定的测试代码：\nimport unittest\rclass DefaultWidgetSizeTestCase(unittest.TestCase):\rdef test_default_widget_size(self):\rwidget = Widget('The widget')\rself.assertEqual(widget.size(), (50, 50))\r 请注意，为了测试某些内容，我们使用assert*() ,他TestCase基类提供的方法之一。如果测试失败，则会引发异常，并带有一条解释性消息，并将unittest 测试用例标识为失败。其他任何异常都将被视为错误。\n测试可能很多，并且它们的设置可能是重复的。幸运的是，我们可以通过实现称为的方法来分解设置代码，setUp()测试框架将针对我们运行的每个测试自动调用该方法 ：\nimport unittest\rclass WidgetTestCase(unittest.TestCase):\rdef setUp(self):\rself.widget = Widget('The widget')\rdef test_default_widget_size(self):\rself.assertEqual(self.widget.size(), (50,50),\r'incorrect default size')\rdef test_widget_resize(self):\rself.widget.resize(100,150)\rself.assertEqual(self.widget.size(), (100,150),\r'wrong size after resize')\r 注意:通过根据字符串的内置顺序对测试方法名称进行排序，可以确定各种测试的运行顺序。\n如果在setUp()测试运行时该方法引发异常，则框架将认为该测试已发生错误，并且该测试方法将不会执行。\n同样，我们可以提供一种tearDown()在测试方法运行后进行整理的方法：\nimport unittest\rclass WidgetTestCase(unittest.TestCase):\rdef setUp(self):\rself.widget = Widget('The widget')\rdef tearDown(self):\rself.widget.dispose()\r 如果setUp()成功，tearDown()将运行测试方法是否成功。\n这种用于测试代码的工作环境称为 测试夹具。创建一个新的TestCase实例作为用于执行每种单独的测试方法的唯一测试夹具。因此 setUp()，tearDown()和__init__() 将在每个测试中被调用一次。\n建议使用TestCase实现将测试根据其测试的功能分组在一起。 unittest为此提供了一种机制：test suite（测试套件)，由unittest的 TestSuite类表示。在大多数情况下，调用unittest.main()将做正确的事情，并为您收集所有模块的测试用例并执行它们。\n但是，如果您想自定义测试套件的构建，则可以自己进行：\ndef suite():\rsuite = unittest.TestSuite()\rsuite.addTest(WidgetTestCase('test_default_widget_size'))\rsuite.addTest(WidgetTestCase('test_widget_resize'))\rreturn suite\rif __name__ == '__main__':\rrunner = unittest.TextTestRunner()\rrunner.run(suite())\r 您可以将测试用例和测试套件的定义与它们要测试的代码放在相同的模块中（例如widget.py），但是将测试代码放在单独的模块中有许多优点，例如 test_widget.py：\n 可以从命令行独立运行测试模块。 测试代码可以更容易地与出厂代码分开。 在没有充分理由的情况下，很少有更改测试代码以使其适合测试代码的诱惑。 测试代码的修改频率应低于其测试的代码。 经过测试的代码可以更容易地重构。 如果测试策略发生变化，则无需更改源代码。  ","id":69,"section":"posts","summary":"测试驱动是先写测试代码，然后写功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码 unittest最早由JUnit启发","tags":["Python标准库"],"title":"Python的Unittest模块","uri":"https://xuzhihao.top/2020/04/python%E7%9A%84unittest%E6%A8%A1%E5%9D%97/","year":"2020"},{"content":"argparse可以让人编写对用户友好的命令行接口。程序定义好它需要的参数，然后argparse将从sys.argv解析出那些参数。\nargparse还会自动生成帮助和使用手册，并在用户给程序传入无效参数时报出错误信息。\n概念 创建一个解析器 parser = argparse.ArgumentParser(description='Process some integers.')\r 添加参数 添加参数是通过调用add_argument()方法完成的\npaser.add_argument('integers', metavar='N', type=int, nargs='+',help='an integer for the accumulator')\rparser.add_argument('--sum',dest='accumulate',action='store_const',const=sum,default=max,help='max,help='sum the integers (default: find the max)')\r 稍后，调用 parse_args() 将返回一个具有 integers 和 accumulate 两个属性的对象。integers 属性将是一个包含一个或多个整数的列表，而 accumulate 属性当命令行中指定了 --sum 参数时将是 sum() 函数，否则则是 max() 函数。\n解析参数 ArgumentParser 通过 parse_args() 方法解析参数。它将检查命令行，把每个参数转换为适当的类型然后调用相应的操作。在大多数情况下，这意味着一个简单的 Namespace 对象将从命令行参数中解析出的属性构建：\nparser.parse_args(['--sum', '7', '-1', '42'])\r 在脚本中，通常parse_args()会不带参数调用，而ArgumentParser将自动从sysy.argv中确定命令行参数。\n基本方法 基础 import argparse\rparser = argparse.AgumentParser()\rparser.parse_args()\r 位置参数 位置参数之所以这样命名，是因为程序应该如何处理该参数，完全取决于1它在命令行中的参数。\nimport argparse\rparser = argprase.ArgumentParser()\rparser.add_argument(\u0026quot;square\u0026quot;,help=\u0026quot;display a square of a given number\u0026quot;,type=int)\rargs = parser.parser_args()\rprint(args.square**2)\r  首先我们引入parser对象 我们增加了add_argument()方法，该方法用于指定程序能够接受哪些命令行选项。 The parse_args() method actually returns some data from the options specified, in this case, square.  注意，这里有type=int，这个是告诉argparse来吧输入当做整数，不然他就会把它当做字符串。\n可选参数 import argparse\rparser = argparse.ArgumentParser()\rparser.add_argument(\u0026quot;--verbose\u0026quot;, help=\u0026quot;increase output verbosity\u0026quot;,\raction=\u0026quot;store_true\u0026quot;)\rargs = parser.parse_args()\rif args.verbose:\rprint(\u0026quot;verbosity turned on\u0026quot;)\r 这里action赋值为\u0026quot;store_true\u0026quot;。这意味着，当一个选项存在时，为args.verbose赋值为True。没有指定时，啧隐含地赋值为False。\n短选项 parser.add_argument(\u0026quot;-v\u0026quot;, \u0026quot;--verbose\u0026quot;, help=\u0026quot;increase output verbosity\u0026quot;,\raction=\u0026quot;store_true\u0026quot;)\r ","id":70,"section":"posts","summary":"argparse可以让人编写对用户友好的命令行接口。程序定义好它需要的参数，然后argparse将从sys.argv解析出那些参数。 argp","tags":["Python标准库"],"title":"Python 参数解析 Parser 的使用方法","uri":"https://xuzhihao.top/2020/04/python-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90-parser-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","year":"2020"},{"content":"sys.argv 传递给Python脚本的命令行参数列表。\n例如\nimport sys\rprint(sys.argv[0])\rprint(sys.argv[1])\r 运行它：\npython temp.py argv1\rsys.py\rargv1\r sys.exit([arg]) 功能：执行到主程序末尾，解释器自动退出，但是如果需要中途退出程序，可以调用sys.exit函数，带有一个可选的整数参数返回给调用它的程序，表示你可以在主程序中捕获对sys.exit的调用。（0是正常退出，其他为异常）\nsys.getdefaultencoding() 获取系统当前编码，一般默认为ascii。\nsys.path 功能：获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。\n当然你可以通过这样修改\nsys.path.append(\u0026quot;自定义模块路径\u0026quot;)\r sys.platform 获取当前系统平台。\nsys.stdin,sys.stdout,sys.stderr 功能：stdin , stdout , 以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们\n——未完之后，会不断补充——\n","id":71,"section":"posts","summary":"sys.argv 传递给Python脚本的命令行参数列表。 例如 import sys print(sys.argv[0]) print(sys.argv[1]) 运行它： python temp.py argv1 sys.py argv1 sys.exit([arg]) 功能：执行到主程序末尾，解释器自动退出，但是如果需要中途退出程序，","tags":["Python标准库"],"title":"Python中的sys","uri":"https://xuzhihao.top/2020/04/python%E4%B8%AD%E7%9A%84sys/","year":"2020"},{"content":"放置\nck = QCheckBox()\rnewItem = XX.setCellWidget(1,0,ck)\r 检查是否被选\nlines = []\rsum = 0\ri = 0\rif (i \u0026lt; self.name.rowCount()):\rlines.append([self.tableWidget.cellWidget(i, 0), self.tableWidget.item(i, 1), self.tableWidget.item(i, 2),\rself.tableWidget.cellWidget(i, 5)])\ri += 1\rfor line in lines:\rif line[0].checkState()==Qt.Checked:\rpass\r ","id":72,"section":"posts","summary":"放置 ck = QCheckBox() newItem = XX.setCellWidget(1,0,ck) 检查是否被选 lines = [] sum = 0 i = 0 if (i \u0026lt; self.name.rowCount()): lines.append([self.tableWidget.cellWidget(i, 0), self.tableWidget.item(i, 1), self.tableWidget.item(i, 2), self.tableWidget.cellWidget(i, 5)]) i += 1 for line in lines: if line[0].checkState()==Qt.Checked: pass","tags":["PyQt5"],"title":"在单元格里放置复选框","uri":"https://xuzhihao.top/2020/04/%E5%9C%A8%E5%8D%95%E5%85%83%E6%A0%BC%E9%87%8C%E6%94%BE%E7%BD%AE%E5%A4%8D%E9%80%89%E6%A1%86/","year":"2020"},{"content":"这个项目会创建一个N×N的细胞网格，随时间推移，模拟Conway生命游戏。\n在这个游戏中，细胞处于ON或OFF状态。游戏从一个初始状态开始，每个细胞分配一个状态，刷滕州而决定如何随时间而改变。\n这个游戏规则很简单，但是它表明，复杂的结构可以根据简单的规则演进，不必遵循任何一个预设的模式。\n工作原理 Conway生命游戏有4个规则：\n 1、如果一个细胞为ON，邻居中少于两个为ON，他变为OFF。 2、如果一个细胞为ON，邻居中有两个或3个为ON，他保持为ON。 3、如果一个细胞为ON，邻居超过三个为ON，他变为OFF。 4、如果一个细胞为OFF，邻居中恰好有三个为ON，他变为ON.  对于边界采用环形边界条件\n表示网格 表示网格上的细胞死活，采用255和0作为ON和OFF的数值。我们将采用matplotlib的imshow()方法，来显示网格当前的状态，将一个数字矩阵表示为一张图像。\n例如：\nx = np.array([[0,0,255],[255,255,0],[0,255,0]])\rplt.imshow(x,interpolation='nearest')\rplt.show\r 初始条件 开始模拟，先为二维网格的每个细胞初始状态。可以使用随机分布，或者特定的图案。\n这里我使用了随机分布。\n例如：\nnp.random.choice([0,255],4*4,p=[0.1,0.9]).reshape(4,4)\r 下面为输出：\narray([[255, 255, 255, 255],\r[255, 255, 0, 255],\r[0, 255, 255, 255],\r[255, 255, 255, 0]])\r 边界条件 这里除了边缘其他位置都好处理，因为边缘采用了环形边界。\n这里我使用了取模。\nright = gird[i][(j+1)%N]\rleft = grid[i][(j-1)%N]\rtop = grid[(i-1)%N][j]\rdown = grid[(i+1)%N][j]\r 实现规则 生命游戏的规则基于相邻细胞的ON或OFF数目。为了简化这些规则的应用，可以计算出处于ON状态的相邻细胞总数。因为ON状态的值为255，所以可以对所有相邻细胞的值求和，再除以255，来获得ON细胞的数量。下面是相关的代码：\nif grid[i,j] == ON:\rif (total \u0026lt; 2) or (total \u0026gt;3 ):\rnewGrid[i,j] = OFF\relse:\rif total == 3:\rnewGrid[i,j] = ON\r 初始化模拟 # set grid size\rN = 100\rif args.N and int(args.N) \u0026gt; 8:\rN = int(args.N)\r# set animation update interval\rupdateInterval = 50\rif args.interval:\rupdateInterval = int(args.interval)\r# populate grid with random on/off - more off than on\rgrid = randomGrid(N)\r 设置动画，\nfig,ax = plt.subplots()\rimg = ax.imshow(grid,interpolation = 'nearest')\rani = animation.FuncAnimation(fig,update,fargs=\t(img.grid,N,),frames=10,interval=updateInterval,save_count=50)\rif args.movfile:\rani.save(args.movfile, fps=30, extra_args=['-vcodec', 'libx264'])\rplt.show()\r 最后的结果：\n\n完整代码：\nimport sys, argparse\rimport numpy as np\rimport matplotlib.pyplot as plt\rimport matplotlib.animation as animation\rON = 255\rOFF = 0\rvals = [ON, OFF]\rdef randomGrid(N):\r\u0026quot;\u0026quot;\u0026quot;returns a grid of NxN random values\u0026quot;\u0026quot;\u0026quot;\rreturn np.random.choice(vals, N * N, p=[0.2, 0.8]).reshape(N, N)\rdef update(frameNum, img, grid, N):\r# copy grid since we require 8 neighbors for calculation\r# and we go line by line\rnewGrid = grid.copy()\rfor i in range(N):\rfor j in range(N):\r# compute 8-neghbor sum\r# using toroidal boundary conditions - x and y wrap around\r# so that the simulaton takes place on a toroidal surface.\rtotal = int((grid[i, (j - 1) % N] + grid[i, (j + 1) % N] +\rgrid[(i - 1) % N, j] + grid[(i + 1) % N, j] +\rgrid[(i - 1) % N, (j - 1) % N] + grid[(i - 1) % N, (j + 1) % N] +\rgrid[(i + 1) % N, (j - 1) % N] + grid[(i + 1) % N, (j + 1) % N]) / 255)\r# apply Conway's rules\rif grid[i, j] == ON:\rif (total \u0026lt; 2) or (total \u0026gt; 3):\rnewGrid[i, j] = OFF\relse:\rif total == 3:\rnewGrid[i, j] = ON\r# update data\rimg.set_data(newGrid)\rgrid[:] = newGrid[:]\rreturn img,\r# main() function\rdef main():\r# Command line args are in sys.argv[1], sys.argv[2] ..\r# sys.argv[0] is the script name itself and can be ignored\r# parse arguments\rparser = argparse.ArgumentParser(description=\u0026quot;Runs Conway's Game of Life simulation.\u0026quot;)\r# add arguments\rparser.add_argument('--grid-size', dest='N', required=False)\rparser.add_argument('--mov-file', dest='movfile', required=False)\rparser.add_argument('--interval', dest='interval', required=False)\rargs = parser.parse_args()\r# set grid size\rN = 100\rif args.N and int(args.N) \u0026gt; 8:\rN = int(args.N)\r# set animation update interval\rupdateInterval = 50\rif args.interval:\rupdateInterval = int(args.interval)\r# declare grid\rgrid = np.array([])\r# populate grid with random on/off - more off than on\rgrid = randomGrid(N)\r# set up animation\rfig, ax = plt.subplots()\rimg = ax.imshow(grid, interpolation='nearest')\rani = animation.FuncAnimation(fig, update, fargs=(img, grid, N,),\rframes=10,\rinterval=updateInterval,\rsave_count=50)\rif args.movfile:\rani.save(args.movfile, fps=30, extra_args=['-vcodec', 'libx264'])\rplt.show()\r# call main\rif __name__ == '__main__':\rmain()\r ","id":73,"section":"posts","summary":"这个项目会创建一个N×N的细胞网格，随时间推移，模拟Conway生命游戏。 在这个游戏中，细胞处于ON或OFF状态。游戏从一个初始状态开始，每","tags":null,"title":"用Python模拟生命","uri":"https://xuzhihao.top/2020/04/python%E6%A8%A1%E6%8B%9F%E7%94%9F%E5%91%BD/","year":"2020"},{"content":"#!/usr/bin/env python3\r\u0026quot;\u0026quot;\u0026quot;\rA Python version of the classic \u0026quot;bottles of beer on the wall\u0026quot; programming\rexample.\rBy Guido van Rossum, demystified after a version by Fredrik Lundh.\r\u0026quot;\u0026quot;\u0026quot;\rimport sys\rn = 100\rif sys.argv[1:]:\rn = int(sys.argv[1])\rdef bottle(n):\rif n == 0: return \u0026quot;no more bottles of beer\u0026quot;\rif n == 1: return \u0026quot;one bottle of beer\u0026quot;\rreturn str(n) + \u0026quot; bottles of beer\u0026quot;\rfor i in range(n, 0, -1):\rprint(bottle(i), \u0026quot;on the wall,\u0026quot;)\rprint(bottle(i) + \u0026quot;.\u0026quot;)\rprint(\u0026quot;Take one down, pass it around,\u0026quot;)\rprint(bottle(i-1), \u0026quot;on the wall.\u0026quot;)\r 这里值得学习：\nn = 100\rif sys.argv[1:]:\rn = int(sys.argv[1])\r 这样保证了n有默认值，用户也可以自己修改。\n今天这个真水，就算一个平缓的起步吧~\n","id":74,"section":"posts","summary":"#!/usr/bin/env python3 \u0026quot;\u0026quot;\u0026quot; A Python version of the classic \u0026quot;bottles of beer on the wall\u0026quot; programming example. By Guido van Rossum, demystified after a version by Fredrik Lundh. \u0026quot;\u0026quot;\u0026quot; import sys n = 100 if sys.argv[1:]: n = int(sys.argv[1]) def bottle(n): if n == 0: return \u0026quot;no more bottles of beer\u0026quot; if n == 1: return \u0026quot;one bottle of beer\u0026quot; return str(n) + \u0026quot; bottles of beer\u0026quot; for i in","tags":["Python代码学习"],"title":"精读代码(1)","uri":"https://xuzhihao.top/2020/04/%E7%B2%BE%E8%AF%BB%E4%BB%A3%E7%A0%811/","year":"2020"},{"content":"配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit）更改。配置Git来忽略制定文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。\n获取Git仓库 有两种获取Git项目仓库的方式。第一种是将已有项目或目录导入为Git仓库；第二种是从其他服务器克隆一个已存在的Git仓库。\n在已存在目录中初始化仓库 如果你打算使用Git来对已有项目进行跟踪，你需要进入项目目录并输入：\ngit init\r 该命令将创建一个名为**.git**的子目录，这个子目录含有你初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。\n如果在一个已存在的文件夹（而非空文件夹）中进行版本控制。你应该开始追踪这些文件并进行初始提交。可以通过git add 命令来指定所需的文件来进行追踪，然后执行git commit：\ngit add .\rgit add LICENSE\rgit commit -m 'initial project version'\r 现在你已经得到了一个存在于被追踪文件与初始提交的Git仓库。\n克隆现有的仓库 如果你想获得一份已经存在了的Git仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这是就要用到git clone命令。Git克隆的是该Git仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。\n当你执行git clone命令时，默认的配置下远程Git胀库的每一个文件的没一个版本都将被拉下来。\ngit clone [url]\r 这会在当前目录下创建一个XX的目录，并在这个目录下初始化一个**.git**文件，从远程仓库拉取下所有数据放入**.git**文件夹，然后从中读取最新版本文件的拷贝。如果你想在克隆远程仓库的时候，自定义本地仓的名字 你可以用这个命令：\ngit clone [url] myStore\r Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用SSH 传输协议，比如 user@server:path/to/repo.git 。\n记录每次更新到仓库 现在我们手上有了一个真实的Git仓库，并从这个仓库中取出所有文件的拷贝。接下来，对这些文件做些修改，在完成一个阶段的目标之后，提交本次更新到仓库。\n记住：你工作目录下的每一个文件都不外乎两种状态：已跟踪或未跟踪。\n已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在国祚一定时间后，它们的状态可能是未修改，已修改或已放入暂存区。\n工作目录中除已跟踪文件以外的所有其他文件都属于未跟踪文件，它们即不存在于上次快照的记录中，也没有被放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。\n检查当前文件状态 可以用git status命令查看哪些文件处于什么状态。如果在克隆仓库后立即使用此命令，会看到类似这样输出：\ngit status\rOn branch master\rnothing to commit,working dirdctory clean\r 这说明你现在的工作目录相当干净，换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有任何处于未跟踪状态的新文件，否则Git会在这里列出来。最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。现在，分支名是“master”，这是默认的分支名。\nGit不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件“。这样的处理让你不必担心将生成的二进制文件或其他不想被跟踪的文件夹包含进来。\n跟踪新文件 使用git add开始跟踪一个文件。所以，比如跟踪README文件，运行：\ngit add README\r 此时再运行git status命令，会看到README文件已被跟踪，并处于暂存状态：\n$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\r 只要在Changes to be committed 这行下面，就说明已暂存状态。如果此时提交，那么该文件在你运行git add时的版本将留在历史记录中。你可能会想起之前我们使用git init后运行了**git add(files)**命令，开始跟踪当前目录下的文件。git add 命令使用文件或牡蛎的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。\n暂存已修改文件 现在我们来修改一个已被跟踪的文件。如果你修改了一个名为CONTRIBUTING。md的已被跟踪的文件，然后运行git status命令，会看到下面内容\n$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 文件CONTRIBURING。md出现在Changes not staged for commit这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行git add命令。\ngit add这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。\n将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行git add 将\u0026quot;CONTRIBUTING.md\u0026quot;放到暂存区，然后再看看 git status 的输出：\n$ git add CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\rmodified: CONTRIBUTING.md\r 现在两个文件都已暂存，下次提交就会一并记录到仓库。假设此时，你想要的在CONTRIBUTING.md里再加条注释。重新编辑存盘后，准备好提交。不过且慢，再运行git status看看：\n$ vim CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\rmodified: CONTRIBUTING.md\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 怎么回事？现在CONTRIBUTING.md文件同时出现在暂存区和非暂存区。实际上，Git只不过暂存了你运行git add命令时的版本。如果你现在提交，CONTRIBUTING.md版本是你最后一次运行git add命令时的那个版本，而不是你运行git commit是，在工作目录中的当前版本。所以，运行了git add之后又做了修订的文件，需要重新运行git add把最新版本重新暂存起来：\n$ git add CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\rmodified: CONTRIBUTING.md\r 状态简览 git status命令输出十分详细，但其用语有些繁琐。Git有一个选项可以帮助你缩短状态命令的输出，这样可以以简洁的方式查看更改。如果你使用git status -s命令或git status —short命令，你将得到一种格式更为紧凑的输出。\n$ git status -s\rM README\rMM Rakefile\rA lib/git.rb\rM lib/simplegit.rb\r?? LICENSE.txt\r 新添加的未跟踪文件前面有**？？**标记，\n新添加都暂存区中的文件前面有A标记，\n修改过的文件前面有M标记。\n注意：M有两个可以出现的位置，出现在右边的M表示该文件被修改了但是还没被放入暂存区。出现在靠左边的M表示该文件被修改了并被放入了暂存区。\n 例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,lib/simplegit.rb 文件被修改了并已将修改后的文件放入了暂存区。 而 Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。\r 忽略文件 一般我们总会有些文件无需纳入Git的管理，也不希望它们总出现在未被跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件。在这种情况下，我们可以创建一个名为**.gitignore**的文件，列出要忽略的文件模式。来看一个实际的**.gitignore**例子\n$ cat .gitignore\r*.[oa]\r*~\r 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。\n第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。\n此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好**.gitignore** 文件的习惯，以免将来误提交这类无用的文件。\n文件.gitignore的格式规范如下：\n 所有空行或者以#开头的行都会被Git忽略。 可以使用标准的glob模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（！）取反。  所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z , a/b/z 或 a/b/c/z 等。 我们再看一个 .gitignore 文件的例子：\n# no .a files\r*.a\r# but do track lib.a, even though you're ignoring .a files above\r!lib.a\r# only ignore the TODO file in the current directory, not subdir/TODO\r/TODO\r# ignore all files in the build/ directory\rbuild/\r# ignore doc/notes.txt, but not doc/server/arch.txt\rdoc/*.txt\r# ignore all .pdf files in the doc/ directory\rdoc/**/*.pdf\r GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在https://github.com/github/gitignore 找到它。\n查看已暂存和未暂存的修改 如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。稍后我们会详细介绍 git diff，你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？ 有哪些更新已经暂存起来准备好下次提交？ 虽然 git status 已经通过在相应栏下列出文件名的方式回答了这个问 题，但 git diff 将通过文件补丁的格式更加具体地显示哪些行发生了改变。 假如再次修改 README 文件后暂存，然后编辑 CONTRIBUTING.md 文件后先不暂存， 运行 status 命令将会看到：\n$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rmodified: README\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 要看尚未暂存的文件更新了哪些部分，不加参数直接输入git diff：\n$ git diff\rdiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\rindex 8ebb991..643e24f 100644\r--- a/CONTRIBUTING.md\r+++ b/CONTRIBUTING.md\r@@ -65,7 +65,8 @@ branch directly, things can get messy.\rPlease include a nice description of your changes when you submit your\rPR;\rif we have to read the whole diff to figure out why you're contributing\rin the first place, you're less likely to get feedback and have your\rchange\r-merged in.\r+merged in. Also, split your changes into comprehensive chunks if your\rpatch is\r+longer than a dozen lines.\rIf you are starting to work on a particular area, feel free to submit a\rPR\rthat highlights your work in progress (and note in the PR title that it's\r 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。 若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff \u0026ndash;staged 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异:\n$ git diff --staged\rdiff --git a/README b/README\rnew file mode 100644\rindex 0000000..03902a1\r--- /dev/null\r+++ b/README\r@@ -0,0 +1 @@\r+My Project\r 请注意，git diff本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。 像之前说的，暂存 CONTRIBUTING.md 后再编辑，可以使用 git status 查看已被暂存的修改或未被暂存的修改。 如果我们的环境（终端输出）看起来如下：\n$ git add CONTRIBUTING.md\r$ echo '# test line' \u0026gt;\u0026gt; CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rmodified: CONTRIBUTING.md\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 现在运行git diff看暂存前后变化：\n$ git diff\rdiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\rindex 643e24f..87f08c8 100644\r--- a/CONTRIBUTING.md\r+++ b/CONTRIBUTING.md\r@@ -119,3 +119,4 @@ at the\r## Starter Projects\rSee our [projects\rlist](\u0026lt;https://github.com/libgit2/libgit2/blob/development/PROJECTS.md\u0026gt;).\r+# test line\r 然后用git diff —cached查看已经暂存起来的变化：（\u0026ndash;staged 和 \u0026ndash;cached 是同义词）\n提交更新 现在暂存区域已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有git add 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过但没有暂存的文件只保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 git commit：\ngit commit\r 这种方式会启动文本编辑器以便输入本次提交的说明。 （默认会启用 shell 的环境变量 $EDITOR 所指定的软件，一般都是 vim 或 emacs。当然也可以按照 起步 介绍的方式，使用 git config \u0026ndash;globalcore.editor 命令设定你喜欢的编辑软件。） 编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：\n# Please enter the commit message for your changes. Lines starting\r# with '#' will be ignored, and an empty message aborts the commit.\r# On branch master\r# Changes to be committed:\r# new file: README\r# modified: CONTRIBUTING.md\r#\r~\r~\r~\r\u0026quot;.git/COMMIT_EDITMSG\u0026quot; 9L, 283C\r 可以看到，默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。 （如果想要更详细的对修改了哪些内容的提示，可以用 -v 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。） 退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。 另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示：\n$ git commit -m \u0026quot;Story 182: Fix benchmarks for speed\u0026quot;\r[master 463dc4f] Story 182: Fix benchmarks for speed\r2 files changed, 2 insertions(+)\rcreate mode 100644 README\r 好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本 次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改 过。 请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。\n跳过使用暂存区 尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存 起来一并提交，从而跳过 git add 步骤：\n$ git status\rOn branch master\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\rno changes added to commit (use \u0026quot;git add\u0026quot; and/or \u0026quot;git commit -a\u0026quot;)\r$ git commit -a -m 'added new benchmarks'\r[master 83e38c7] added new benchmarks\r1 file changed, 5 insertions(+), 0 deletions(-)\r 看到了吗？提交之前不再需要 git add 文件“CONTRIBUTING.md”了。 这是因为 -a 选项使本次提交包含了所有修改过的文件。 这很方便，但是要小心；有时这个选项会将不需要的文件添加到提交中。\n移除文件 **要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。**可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。\n如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到：\n$ rm PROJECTS.md\r$ git status\rOn branch master\rYour branch is up-to-date with 'origin/master'.\rChanges not staged for commit:\r(use \u0026quot;git add/rm \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rdeleted: PROJECTS.md\rno changes added to commit (use \u0026quot;git add\u0026quot; and/or \u0026quot;git commit -a\u0026quot;)\r 然后再运行git rm 记录此次移除文件的操作：\n$ git rm PROJECTS.md\rrm 'PROJECTS.md'\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rdeleted: PROJECTS.md\r 下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。\n另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 \u0026ndash;cached 选项：\ngit rm --cache README\r git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。 比方说：\ngit rm log/\\\\*.log\r 注意到星号 * 之前的反斜杠 \\， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。此命令删除 log/ 目录下扩展名为 .log 的所有文件。 类似的比如：\ngit rm \\\\*~\r 该命令为删除以 ~ 结尾的所有文件。\n移动文件 Git不会显式跟踪文件移动操作。\n要在Git中对文件改名：\ngit mv file_from file_to\r 实际上，运行git mv就相当于运行下面三条命令：\n$ mv README.md README\r$ git rm README.md\r$ git add README\r 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。\n查看提交历史 在提交了若干个更新，又或者克隆了某个项目之后，你想回顾一下提交历史。完成这个任务最简单而有效的工具是git log命令\n不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 git log 有许多选项可以帮助你搜寻你所要找的提交， 下面我们会介绍几个最常用的选项。 其中一个比较有用的选项是 -p，它会显示每次提交所引入的差异。 与此同时，你也可以使用 -2 选项来仅显示最近的两次提交：\n撤销操作 在任何一个阶段，你都有可能想要撤销某些操作。这里，我们将会学习几个撤销你所做修改的基本工具。注意，有些撤销操作是不可逆的。这是在使用Git的过程中，会因为操作失误而导致之前工作丢失的少有的几个地方之一。\n有时候，我们提交完发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有 —amend 选项的提交命令尝试重新提交。\ngit commit --amend\r 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。 例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\n$ git commit -m 'initial commit'\r$ git add forgotten_file\r$ git commit --amend\r 最终你只会有一个提交——第二次提交将代替第一次提交的结果。\n取消暂存的文件 接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。\n例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如何只取消暂存两个中的一个呢？ git status 命令提示了你：\n$ git add *\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rrenamed: README.md -\u0026gt; README\rmodified: CONTRIBUTING.md\r 在 “Changes to be committed” 文字正下方，提示使用 git reset HEAD \u0026hellip; 来取消暂存。 所以，我们可以这样来取消暂存 CONTRIBUTING.md 文件\n$ git reset HEAD CONTRIBUTING.md\rUnstaged changes after reset:\rM CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rrenamed: README.md -\u0026gt; README\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 这样CONTRIBUTING.md 文件已经是修改未暂存的状态了。\n虽然在调用时加上 \u0026ndash;hard 选项可以令 git reset 成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！），但本例中工作目录内的文件并不会被修改。 不加选项地调用git reset 并不危险 — 它只会修改暂存区域。\n撤销对文件的修改 如果你并不想保留对 CONTRIBUTING.md 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，git status 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样\nChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r$ git checkout -- CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rrenamed: README.md -\u0026gt; README\r 可以看到那些修改已经被撤销了。\n你需要知道 git checkout \u0026ndash; [file] 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失——你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。\n如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 Git 分支 介绍保存进度与分支；这些通常是更好的做法。 记住，在 Git 中任何 已提交的 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 \u0026ndash;amend 选项覆盖的提交也可以恢复（阅读 数据恢复 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。\n远程仓库的使用 为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 在本节中，我们将介绍一部分远程管理的技能。\n查看远程仓库 如果想查看你已经配置好的远程仓库服务器，可以运行git remote命令。他会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该看到origin——这是Git给你克隆的仓库服务意识的默认名字。\n$ git clone \u0026lt;https://github.com/schacon/ticgit\u0026gt;\rCloning into 'ticgit'...\rremote: Reusing existing pack: 1857, done.\rremote: Total 1857 (delta 0), reused 0 (delta 0)\rReceiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.\rResolving deltas: 100% (772/772), done.\rChecking connectivity... done.\r$ cd ticgit\r$ git remote\rorigin\r 你也可以指定选项**-v**，会显示读写远程仓库使用的Git保存的简写与其对应的URL。\n$ git remote -v\rorigin \u0026lt;https://github.com/schacon/ticgit\u0026gt; (fetch)\rorigin \u0026lt;https://github.com/schacon/ticgit\u0026gt; (push)\r 添加远程仓库 我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。 运行 **git remote add ** 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简 写：\n$ git remote\rorigin\r$ git remote add pb \u0026lt;https://github.com/paulboone/ticgit\u0026gt;\r$ git remote -v\rorigin \u0026lt;https://github.com/schacon/ticgit\u0026gt; (fetch)\rorigin \u0026lt;https://github.com/schacon/ticgit\u0026gt; (push)\rpb \u0026lt;https://github.com/paulboone/ticgit\u0026gt; (fetch)\rpb \u0026lt;https://github.com/paulboone/ticgit\u0026gt; (push)\r 现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch pb：\n$ git fetch pb\rremote: Counting objects: 43, done.\rremote: Compressing objects: 100% (36/36), done.\rremote: Total 43 (delta 10), reused 31 (delta 5)\rUnpacking objects: 100% (43/43), done.\rFrom \u0026lt;https://github.com/paulboone/ticgit\u0026gt;\r* [new branch] master -\u0026gt; pb/master\r* [new branch] ticgit -\u0026gt; pb/ticgit\r 现在 Paul 的 master 分支可以在本地通过 pb/master 访问到——你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 Git 分支 中详细介绍什么是分支以及如何使用分支。）\n从远程仓库中抓取与拉取 从远程仓库获得数据，可以执行：\ngit fetch [remote-name]\r 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工 作。 如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 Git 分支 了解更多信息），可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\n推送到远程仓库 当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：git push [remote-name] [branchname]。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：\ngit push origin master\r 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 阅读 Git 分支 了解如何推送到远程仓库服务器的详细信息。\n查看某个远程仓库 如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：\n$ git remote show origin\r* remote origin\rFetch URL: \u0026lt;https://github.com/schacon/ticgit\u0026gt;\rPush URL: \u0026lt;https://github.com/schacon/ticgit\u0026gt;\rHEAD branch: master\rRemote branches:\rmaster tracked\rdev-branch tracked\rLocal branch configured for 'git pull':\rmaster merges with remote master\rLocal ref configured for 'git push':\rmaster pushes to master (up to date)\r 它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。 这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 git remote show 看到更多的信息。\n$ git remote show origin\r* remote origin\rURL: \u0026lt;https://github.com/my-org/complex-project\u0026gt;\rFetch URL: \u0026lt;https://github.com/my-org/complex-project\u0026gt;\rPush URL: \u0026lt;https://github.com/my-org/complex-project\u0026gt;\rHEAD branch: master\rRemote branches:\rmaster tracked\rdev-branch tracked\rmarkdown-strip tracked\rissue-43 new (next fetch will store in\rremotes/origin)\rissue-45 new (next fetch will store in\rremotes/origin)\rrefs/remotes/origin/issue-11 stale (use 'git remote prune' to\rremove)\rLocal branches configured for 'git pull':\rdev-branch merges with remote dev-branch\rmaster merges with remote master\rLocal refs configured for 'git push':\rdev-branch pushes to dev-branch\r(up to date)\rmarkdown-strip pushes to markdown-strip\r(up to date)\rmaster pushes to master\r(up to date)\r 这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 git pull 时哪些分支会自动合并。\n远程仓库的移除与重命名 如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 例如，想要将 pb重命名为 paul，可以用 git remote rename 这样做：\n$ git remote rename pb paul\r$ git remote\rorigin\rpaul\r 值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 pb/master 的现在会引用 paul/master。\n如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用 git remote rm ：\n$ git remote rm paul\r$ git remote\rorigin\r ","id":75,"section":"posts","summary":"配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit）更改。配置Git来忽","tags":["Git"],"title":"Git基本操作(1)","uri":"https://xuzhihao.top/2020/04/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C1/","year":"2020"},{"content":"行内与独行  行内公式：将公式插入到本行内，符号：$公式内容$，如：$xyz$ 独行公式：将公式插入到新的一行内，并且居中，符号：$$公式内容$$，如：$$xyz$$  上标、下标与组合  上标符号，符号：^，如：$x^4$ 下标符号，符号：_，如：$x_1$ 组合符号，符号：{}，如：${16}{8}O{2+}{2}$  汉字、字体与格式  汉字形式，符号：\\mbox{}，如：$V_{\\mbox{初始}}$ 字体控制，符号：\\displaystyle，如：$\\displaystyle \\frac{x+y}{y+z}$ 下划线符号，符号：\\underline，如：$\\underline{x+y}$ 标签，符号\\tag{数字}，如：$\\tag{11}$ 上大括号，符号：\\overbrace{算式}，如：$\\overbrace{a+b+c+d}^{2.0}$ 下大括号，符号：\\underbrace{算式}，如：$a+\\underbrace{b+c}_{1.0}+d$ 上位符号，符号：\\stacrel{上位符号}{基位符号}，如：$\\vec{x}\\stackrel{\\mathrm{def}}{=}{x_1,\\dots,x_n}$  占位符  两个quad空格，符号：\\qquad，如：$x \\qquad y$ quad空格，符号：\\quad，如：$x \\quad y$ 大空格，符号\\，如：$x \\ y$ 中空格，符号\\:，如：$x : y$ 小空格，符号\\,，如：$x , y$ 没有空格，符号``，如：$xy$ 紧贴，符号\\!，如：$x ! y$  定界符与组合  括号，符号：（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)，如：$（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)$ 中括号，符号：[]，如：$[x+y]$ 大括号，符号：\\{ \\}，如：${x+y}$ 自适应括号，符号：\\left \\right，如：$\\left(x\\right)$，$\\left(x{yz}\\right)$ 组合公式，符号：{上位公式 \\choose 下位公式}，如：${n+1 \\choose k}={n \\choose k}+{n \\choose k-1}$ 组合公式，符号：{上位公式 \\atop 下位公式}，如：$\\sum_{k_0,k_1,\\ldots\u0026gt;0 \\atop k_0+k_1+\\cdots=n}A_{k_0}A_{k_1}\\cdots$  四则运算  加法运算，符号：+，如：$x+y=z$ 减法运算，符号：-，如：$x-y=z$ 加减运算，符号：\\pm，如：$x \\pm y=z$ 减甲运算，符号：\\mp，如：$x \\mp y=z$ 乘法运算，符号：\\times，如：$x \\times y=z$ 点乘运算，符号：\\cdot，如：$x \\cdot y=z$ 星乘运算，符号：\\ast，如：$x \\ast y=z$ 除法运算，符号：\\div，如：$x \\div y=z$ 斜法运算，符号：/，如：$x/y=z$ 分式表示，符号：\\frac{分子}{分母}，如：$\\frac{x+y}{y+z}$ 分式表示，符号：{分子} \\voer {分母}，如：${x+y} \\over {y+z}$ 绝对值表示，符号：||，如：$|x+y|$  高级运算  平均数运算，符号：\\overline{算式}，如：$\\overline{xyz}$ 开二次方运算，符号：\\sqrt，如：$\\sqrt x$ 开方运算，符号：\\sqrt[开方数]{被开方数}，如：$\\sqrt[3]{x+y}$ 对数运算，符号：\\log，如：$\\log(x)$ 极限运算，符号：\\lim，如：$\\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 极限运算，符号：\\displaystyle \\lim，如：$\\displaystyle \\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 求和运算，符号：\\sum，如：$\\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 求和运算，符号：\\displaystyle \\sum，如：$\\displaystyle \\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 积分运算，符号：\\int，如：$\\int^{\\infty}_{0}{xdx}$ 积分运算，符号：\\displaystyle \\int，如：$\\displaystyle \\int^{\\infty}_{0}{xdx}$ 微分运算，符号：\\partial，如：$\\frac{\\partial x}{\\partial y}$ 矩阵表示，符号：\\begin{matrix} \\end{matrix}，如：$\\left[ \\begin{matrix} 1 \u0026amp;2 \u0026amp;\\cdots \u0026amp;4\\5 \u0026amp;6 \u0026amp;\\cdots \u0026amp;8\\vdots \u0026amp;\\vdots \u0026amp;\\ddots \u0026amp;\\vdots\\13 \u0026amp;14 \u0026amp;\\cdots \u0026amp;16\\end{matrix} \\right]$  逻辑运算  等于运算，符号：=，如：$x+y=z$ 大于运算，符号：\u0026gt;，如：$x+y\u0026gt;z$ 小于运算，符号：\u0026lt;，如：$x+y\u0026lt;z$ 大于等于运算，符号：\\geq，如：$x+y \\geq z$ 小于等于运算，符号：\\leq，如：$x+y \\leq z$ 不等于运算，符号：\\neq，如：$x+y \\neq z$ 不大于等于运算，符号：\\ngeq，如：$x+y \\ngeq z$ 不大于等于运算，符号：\\not\\geq，如：$x+y \\not\\geq z$ 不小于等于运算，符号：\\nleq，如：$x+y \\nleq z$ 不小于等于运算，符号：\\not\\leq，如：$x+y \\not\\leq z$ 约等于运算，符号：\\approx，如：$x+y \\approx z$ 恒定等于运算，符号：\\equiv，如：$x+y \\equiv z$  集合运算  属于运算，符号：\\in，如：$x \\in y$ 不属于运算，符号：\\notin，如：$x \\notin y$ 不属于运算，符号：\\not\\in，如：$x \\not\\in y$ 子集运算，符号：\\subset，如：$x \\subset y$ 子集运算，符号：\\supset，如：$x \\supset y$ 真子集运算，符号：\\subseteq，如：$x \\subseteq y$ 非真子集运算，符号：\\subsetneq，如：$x \\subsetneq y$ 真子集运算，符号：\\supseteq，如：$x \\supseteq y$ 非真子集运算，符号：\\supsetneq，如：$x \\supsetneq y$ 非子集运算，符号：\\not\\subset，如：$x \\not\\subset y$ 非子集运算，符号：\\not\\supset，如：$x \\not\\supset y$ 并集运算，符号：\\cup，如：$x \\cup y$ 交集运算，符号：\\cap，如：$x \\cap y$ 差集运算，符号：\\setminus，如：$x \\setminus y$ 同或运算，符号：\\bigodot，如：$x \\bigodot y$ 同与运算，符号：\\bigotimes，如：$x \\bigotimes y$ 实数集合，符号：\\mathbb{R}，如：\\mathbb{R} 自然数集合，符号：\\mathbb{Z}，如：\\mathbb{Z} 空集，符号：\\emptyset，如：$\\emptyset$  数学符号  无穷，符号：\\infty，如：$\\infty$ 虚数，符号：\\imath，如：$\\imath$ 虚数，符号：\\jmath，如：$\\jmath$ 数学符号，符号\\hat{a}，如：$\\hat{a}$ 数学符号，符号\\check{a}，如：$\\check{a}$ 数学符号，符号\\breve{a}，如：$\\breve{a}$ 数学符号，符号\\tilde{a}，如：$\\tilde{a}$ 数学符号，符号\\bar{a}，如：$\\bar{a}$ 矢量符号，符号\\vec{a}，如：$\\vec{a}$ 数学符号，符号\\acute{a}，如：$\\acute{a}$ 数学符号，符号\\grave{a}，如：$\\grave{a}$ 数学符号，符号\\mathring{a}，如：$\\mathring{a}$ 一阶导数符号，符号\\dot{a}，如：$\\dot{a}$ 二阶导数符号，符号\\ddot{a}，如：$\\ddot{a}$ 上箭头，符号：\\uparrow，如：$\\uparrow$ 上箭头，符号：\\Uparrow，如：$\\Uparrow$ 下箭头，符号：\\downarrow，如：$\\downarrow$ 下箭头，符号：\\Downarrow，如：$\\Downarrow$ 左箭头，符号：\\leftarrow，如：$\\leftarrow$ 左箭头，符号：\\Leftarrow，如：$\\Leftarrow$ 右箭头，符号：\\rightarrow，如：$\\rightarrow$ 右箭头，符号：\\Rightarrow，如：$\\Rightarrow$ 底端对齐的省略号，符号：\\ldots，如：$1,2,\\ldots,n$ 中线对齐的省略号，符号：\\cdots，如：$x_1^2 + x_2^2 + \\cdots + x_n^2$ 竖直对齐的省略号，符号：\\vdots，如：$\\vdots$ 斜对齐的省略号，符号：\\ddots，如：$\\ddots$  希腊字母    字母 实现 字母 实现     A A α \\alhpa   B B β \\beta   Γ \\Gamma γ \\gamma   Δ \\Delta δ \\delta   E E ϵ \\epsilon   Z Z ζ \\zeta   H H η \\eta   Θ \\Theta θ \\theta   I I ι \\iota   K K κ \\kappa   Λ \\Lambda λ \\lambda   M M μ \\mu   N N ν \\nu   Ξ \\Xi ξ \\xi   O O ο \\omicron   Π \\Pi π \\pi   P P ρ \\rho   Σ \\Sigma σ \\sigma   T T τ \\tau   Υ \\Upsilon υ \\upsilon   Φ \\Phi ϕ \\phi   X X χ \\chi   Ψ \\Psi ψ \\psi   Ω \\v ω \\omega    这篇文章是我转自别人的，放到我的库里面，方便以后即使查阅。\n作者：DanielGavin 来源：简书 链接：https://www.jianshu.com/p/e74eb43960a1\n","id":76,"section":"posts","summary":"行内与独行 行内公式：将公式插入到本行内，符号：$公式内容$，如：$xyz$ 独行公式：将公式插入到新的一行内，并且居中，符号：$$公式内容$$","tags":["Markown"],"title":"Mrakdown中插入数学公式","uri":"https://xuzhihao.top/2020/04/markdown%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","year":"2020"},{"content":"常量通常定义在代码前面，并且全都大写，分割的时候用_（下划线）分割。比如想，MAX_OVERFLOW和TOTAL这样。\n Constants are usually defined on a module level and written in all capital letters with underscores separating words. Examples include MAX_OVERFLOW and TOTAL.\n 始终决定是否一个类的方法和实例变量（通常也叫“属性”）应该是公开还是不公开。如果不确定的话，选择非公共，之后让他公开会 比 让公共的属性非公开，要简单。\n Always decide whether a class\u0026rsquo;s methods and instance variables (collectively: \u0026ldquo;attributes\u0026rdquo;) should be public or non-public. If in doubt, choose non-public; it\u0026rsquo;s easier to make it public later than to make a public attribute non-public.\n 公共属性是那些 与你认为与你使用的类不相关的客户端，并且你承诺避免向后不兼容的更改。不公共的属性 是那些打算被第三方使用的属性；你不保证非公共属性不能更改或者被移除。\n Public attributes are those that you expect unrelated clients of your class to use, with your commitment to avoid backwards incompatible changes. Non-public attributes are those that are not intended to be used by third parties; you make no guarantees that non-public attributes won\u0026rsquo;t change or even be removed.\n 我们在这里不使用“私密”这个术语。因为在Python中没有属性是真正的私密（通常没有必要的工作量）。\n We don\u0026rsquo;t use the term \u0026ldquo;private\u0026rdquo; here, since no attribute is really private in Python (without a generally unnecessary amount of work).\n 另一类属性的种类是“子类API”的一部分。（在其它的语言中，经常被叫做“被保护”）。一些类被设计为从类继承，以扩展或者修改类行为的某些方面。在设计这样一个类时，要注意明确地决定哪些属性是公共的，哪些属性是子类API的一部分，哪些属性实际上只由基类使用。\n Another category of attributes are those that are part of the \u0026ldquo;subclass API\u0026rdquo; (often called \u0026ldquo;protected\u0026rdquo; in other languages). Some classes are designed to be inherited from, either to extend or modify aspects of the class\u0026rsquo;s behavior. When designing such a class, take care to make explicit decisions about which attributes are public, which are part of the subclass API, and which are truly only to be used by your base class.\n 基于这样的考虑，这里有Pyhton的建议：\n With this in mind, here are the Pythonic guidelines:\n  公共属性，前面没有下划线。   Public attributes should have no leading underscores.\n   如果你的公共属性与保留关键字冲突，在你的属性名后面加上一个_(下划线).这比缩写或者拼写错误更好。（但是，尽管有这个规定，对于已知是类的任何变量或参数，特别是类方法的第一个参数，“cls”是首选拼写。）\nNote1：有关类方法，请参阅上面的参数名称建议。\n   If your public attribute name collides with a reserved keyword, append a single trailing underscore to your attribute name. This is preferable to an abbreviation or corrupted spelling. (However, notwithstanding this rule, \u0026lsquo;cls\u0026rsquo; is the preferred spelling for any variable or argument which is known to be a class, especially the first argument to a class method.)\nNote 1: See the argument name recommendation above for class methods.\n   对于简单的公共数据变量，最好公开属性名，不用复杂的accessor/mutator方法。请记住，Python提供了一个通往未来增强的简单路径，如果你发现了一个简单的数据属性需要增长功能行为。在这种情况下，使用属性将功能实现隐藏在简单的数据属性访问语法之后。\nNote1:特性(Properties)只工作在新式类中。\nNote2：尽量使函数行为无副作用，尽管像缓存这样的副作用通常是好的\nNote3：避免使用属性进行计算开销大的操作;属性表示法使调用者相信访问是(相对)便宜的。\n   For simple public data attributes, it is best to expose just the attribute name, without complicated accessor/mutator methods. Keep in mind that Python provides an easy path to future enhancement, should you find that a simple data attribute needs to grow functional behavior. In that case, use properties to hide functional implementation behind simple data attribute access syntax.\nNote 1: Properties only work on new-style classes.\nNote 2: Try to keep the functional behavior side-effect free, although side-effects such as caching are generally fine.\nNote 3: Avoid using properties for computationally expensive operations; the attribute notation makes the caller believe that access is (relatively) cheap.\n   如果你的类被打算子类化，并且如果您不希望使用子类的属性，可以考虑使用__(双前导下划线)和无后导下划线来命名它们。这将调用Python的名称转换算法，其中类的名称将转换为属性名。这有助于避免在子类无意中包含具有相同名称的属性时发生属性名称冲突。\nNote1：注意，在混乱的名称中只使用简单的类名，因此，如果子类同时选择相同的类名和属性名，仍然会发生名称冲突。\nNote2：名称篡改可以使某些用途变得不那么方便，比如调试和getattr()。但是，名称篡改(mangling)算法有很好的文档记录，并且很容易手工执行。\nNote3：不是每个人都喜欢乱改名字。尽量平衡避免意外名称冲突与高级调用者可能使用的名称冲突的需要。\n   If your class is intended to be subclassed, and you have attributes that you do not want subclasses to use, consider naming them with double leading underscores and no trailing underscores. This invokes Python\u0026rsquo;s name mangling algorithm, where the name of the class is mangled into the attribute name. This helps avoid attribute name collisions should subclasses inadvertently contain attributes with the same name.\nNote 1: Note that only the simple class name is used in the mangled name, so if a subclass chooses both the same class name and attribute name, you can still get name collisions.\nNote 2: Name mangling can make certain uses, such as debugging and getattr(), less convenient. However the name mangling algorithm is well documented and easy to perform manually.\nNote 3: Not everyone likes name mangling. Try to balance the need to avoid accidental name clashes with potential use by advanced callers.\n 任何向后兼容性保证都只适用于公共接口。因此，用户能够清楚地区分公共接口和内部接口是很重要的。\n Any backwards compatibility guarantees apply only to public interfaces. Accordingly, it is important that users be able to clearly distinguish between public and internal interfaces.\n 文档化的接口被认为是公共的，除非文档明确声明它们是临时的或内部接口，不受通常的向后兼容性保证的约束。所有未文档化的接口都应该被认为是内部的。\n Documented interfaces are considered public, unless the documentation explicitly declares them to be provisional or internal interfaces exempt from the usual backwards compatibility guarantees. All undocumented interfaces should be assumed to be internal.\n 为了更好地支持自省，模块应该使用all属性显式地在其公共API中声明名称。将all设置为空列表表示该模块没有公共API。\n To better support introspection, modules should explicitly declare the names in their public API using the all attribute. Setting all to an empty list indicates that the module has no public API.\n 即使all进行了适当的设置，内部接口(包、模块、类、函数、属性或其他名称)仍然应该以单个前导下划线作为前缀。\n Even with all set appropriately, internal interfaces (packages, modules, classes, functions, attributes or other names) should still be prefixed with a single leading underscore.\n 如果任何包含名称空间(包、模块或类)被认为是内部的，那么接口也被认为是内部的。\n An interface is also considered internal if any containing namespace (package, module or class) is considered internal.\n 导入的名称应该始终被视为实现细节。其他模块不能依赖于对这些导入名称的间接访问，除非它们是包含模块的API(如os)的显式文档部分。从子模块公开功能的路径或包的init模块。\n Imported names should always be considered an implementation detail. Other modules must not rely on indirect access to such imported names unless they are an explicitly documented part of the containing module\u0026rsquo;s API, such as os.path or a package\u0026rsquo;s init module that exposes functionality from submodules.\n   编写代码的方式不应该损害Python的其他实现(PyPy、Jython、IronPython、Cython、Psyco等)。\n例如，对于形式为a += b或a = a + b的语句，不要依赖于CPython的就地字符串连接的高效实现。这种优化是脆弱的甚至在CPython的(只适用于某些类型)和不存在在不使用refcounting实现。在库的性能敏感部分，应该使用“.join()”形式。这将确保在不同实现之间以线性时间进行连接。\n Code should be written in a way that does not disadvantage other implementations of Python (PyPy, Jython, IronPython, Cython, Psyco, and such).\nFor example, do not rely on CPython\u0026rsquo;s efficient implementation of in-place string concatenation for statements in the form a += b or a = a + b. This optimization is fragile even in CPython (it only works for some types) and isn\u0026rsquo;t present at all in implementations that don\u0026rsquo;t use refcounting. In performance sensitive parts of the library, the \u0026lsquo;'.join() form should be used instead. This will ensure that concatenation occurs in linear time across various implementations.\n   像None这样的比较应该始终使用is或is not，而不是相等运算符。\n另外，当你真正的意思是x不是None时，要注意不要写if x。例如，当测试一个默认为None的变量或参数是否被设置为其他值时。另一个值可能具有在布尔上下文中为false的类型(例如容器)!\n Comparisons to singletons like None should always be done with is or is not, never the equality operators.\nAlso, beware of writing if x when you really mean if x is not None \u0026ndash; e.g. when testing whether a variable or argument that defaults to None was set to some other value. The other value might have a type (such as a container) that could be false in a boolean context!\n   Use is not operator rather than not \u0026hellip; is. While both expressions are functionally identical, the former is more readable and preferred.\nYes:\n if foo is not None:\r No:\n if not foo is None:\r   When implementing ordering operations with rich comparisons, it is best to implement all six operations (eq, ne, lt, le, gt, ge) rather than relying on other code to only exercise a particular comparison.\nTo minimize the effort involved, the functools.total_ordering() decorator provides a tool to generate missing comparison methods.\nPEP 207 indicates that reflexivity rules are assumed by Python. Thus, the interpreter may swap y \u0026gt; x with x \u0026lt; y, y \u0026gt;= x with x \u0026lt;= y, and may swap the arguments of x == y and x != y. The sort() and min() operations are guaranteed to use the \u0026lt; operator and the max() function uses the \u0026gt; operator. However, it is best to implement all six operations so that confusion doesn\u0026rsquo;t arise in other contexts.\n  Always use a def statement instead of an assignment statement that binds a lambda expression directly to an identifier.\nYes:\n def f(x): return 2*x\r No:\n f = lambda x: 2*x\r The first form means that the name of the resulting function object is specifically \u0026lsquo;f\u0026rsquo; instead of the generic \u0026lsquo;\u0026rsquo;. This is more useful for tracebacks and string representations in general. The use of the assignment statement eliminates the sole benefit a lambda expression can offer over an explicit def statement (i.e. that it can be embedded inside a larger expression)\n  Derive exceptions from Exception rather than BaseException. Direct inheritance from BaseException is reserved for exceptions where catching them is almost always the wrong thing to do.\nDesign exception hierarchies based on the distinctions that code catching the exceptions is likely to need, rather than the locations where the exceptions are raised. Aim to answer the question \u0026ldquo;What went wrong?\u0026rdquo; programmatically, rather than only stating that \u0026ldquo;A problem occurred\u0026rdquo; (see PEP 3151 for an example of this lesson being learned for the builtin exception hierarchy)\nClass naming conventions apply here, although you should add the suffix \u0026ldquo;Error\u0026rdquo; to your exception classes if the exception is an error. Non-error exceptions that are used for non-local flow control or other forms of signaling need no special suffix.\n  Use exception chaining appropriately. In Python 3, \u0026ldquo;raise X from Y\u0026rdquo; should be used to indicate explicit replacement without losing the original traceback.\nWhen deliberately replacing an inner exception (using \u0026ldquo;raise X\u0026rdquo; in Python 2 or \u0026ldquo;raise X from None\u0026rdquo; in Python 3.3+), ensure that relevant details are transferred to the new exception (such as preserving the attribute name when converting KeyError to AttributeError, or embedding the text of the original exception in the new exception message).\n  When raising an exception in Python 2, use raise ValueError(\u0026lsquo;message\u0026rsquo;) instead of the older form raise ValueError, \u0026lsquo;message\u0026rsquo;.\nThe latter form is not legal Python 3 syntax.\nThe paren-using form also means that when the exception arguments are long or include string formatting, you don\u0026rsquo;t need to use line continuation characters thanks to the containing parentheses.\n  When catching exceptions, mention specific exceptions whenever possible instead of using a bare except: clause:\n try:\rimport platform_specific_module\rexcept ImportError:\rplatform_specific_module = None\r A bare except: clause will catch SystemExit and KeyboardInterrupt exceptions, making it harder to interrupt a program with Control-C, and can disguise other problems. If you want to catch all exceptions that signal program errors, use except Exception: (bare except is equivalent to except BaseException:).\nA good rule of thumb is to limit use of bare \u0026lsquo;except\u0026rsquo; clauses to two cases:\n If the exception handler will be printing out or logging the traceback; at least the user will be aware that an error has occurred. If the code needs to do some cleanup work, but then lets the exception propagate upwards with raise. try\u0026hellip;finally can be a better way to handle this case.    When binding caught exceptions to a name, prefer the explicit name binding syntax added in Python 2.6:\n try:\rprocess_data()\rexcept Exception as exc:\rraise DataProcessingFailedError(str(exc))\r This is the only syntax supported in Python 3, and avoids the ambiguity problems associated with the older comma-based syntax.\n  When catching operating system errors, prefer the explicit exception hierarchy introduced in Python 3.3 over introspection of errno values.\n  Additionally, for all try/except clauses, limit the try clause to the absolute minimum amount of code necessary. Again, this avoids masking bugs.\nYes:\n try:\rvalue = collection[key]\rexcept KeyError:\rreturn key_not_found(key)\relse:\rreturn handle_value(value)\r No:\n try:\r# Too broad!\rreturn handle_value(collection[key])\rexcept KeyError:\r# Will also catch KeyError raised by handle_value()\rreturn key_not_found(key)\r   When a resource is local to a particular section of code, use a with statement to ensure it is cleaned up promptly and reliably after use. A try/finally statement is also acceptable.\n  Context managers should be invoked through separate functions or methods whenever they do something other than acquire and release resources.\nYes:\nwith conn.begin_transaction():\rdo_stuff_in_transaction(conn)\r No:\nwith conn:\rdo_stuff_in_transaction(conn)\r The latter example doesn\u0026rsquo;t provide any information to indicate that the enter and exit methods are doing something other than closing the connection after a transaction. Being explicit is important in this case.\n  Be consistent in return statements. Either all return statements in a function should return an expression, or none of them should. If any return statement returns an expression, any return statements where no value is returned should explicitly state this as return None, and an explicit return statement should be present at the end of the function (if reachable).\nYes:\n def foo(x):\rif x \u0026gt;= 0:\rreturn math.sqrt(x)\relse:\rreturn None\rdef bar(x):\rif x \u0026lt; 0:\rreturn None\rreturn math.sqrt(x)\r No:\n def foo(x):\rif x \u0026gt;= 0:\rreturn math.sqrt(x)\rdef bar(x):\rif x \u0026lt; 0:\rreturn\rreturn math.sqrt(x)\r   Use string methods instead of the string module.\nString methods are always much faster and share the same API with unicode strings. Override this rule if backwards compatibility with Pythons older than 2.0 is required.\n  Use \u0026lsquo;'.startswith() and \u0026lsquo;'.endswith() instead of string slicing to check for prefixes or suffixes.\nstartswith() and endswith() are cleaner and less error prone:\n Yes: if foo.startswith('bar'):\rNo: if foo[:3] == 'bar':\r   Object type comparisons should always use isinstance() instead of comparing types directly.\n Yes: if isinstance(obj, int):\rNo: if type(obj) is type(1):\r When checking if an object is a string, keep in mind that it might be a unicode string too! In Python 2, str and unicode have a common base class, basestring, so you can do:\n if isinstance(obj, basestring):\r Note that in Python 3, unicode and basestring no longer exist (there is only str) and a bytes object is no longer a kind of string (it is a sequence of integers instead).\n  For sequences, (strings, lists, tuples), use the fact that empty sequences are false.\n Yes: if not seq:\rif seq:\rNo: if len(seq):\rif not len(seq):\r   Don\u0026rsquo;t write string literals that rely on significant trailing whitespace. Such trailing whitespace is visually indistinguishable and some editors (or more recently, reindent.py) will trim them.\n  Don\u0026rsquo;t compare boolean values to True or False using ==.\n Yes: if greeting:\rNo: if greeting == True:\rWorse: if greeting is True:\r   Use of the flow control statements return/break/continue within the finally suite of a try\u0026hellip;finally, where the flow control statement would jump outside the finally suite, is discouraged. This is because such statements will implicitly cancel any active exception that is propagating through the finally suite.\nNo:\n def foo():\rtry:\r1 / 0\rfinally:\rreturn 42\r   With the acceptance of PEP 484, the style rules for function annotations are changing.\n  In order to be forward compatible, function annotations in Python 3 code should preferably use PEP 484 syntax. (There are some formatting recommendations for annotations in the previous section.)\n  The experimentation with annotation styles that was recommended previously in this PEP is no longer encouraged.\n  However, outside the stdlib, experiments within the rules of PEP 484 are now encouraged. For example, marking up a large third party library or application with PEP 484 style type annotations, reviewing how easy it was to add those annotations, and observing whether their presence increases code understandability.\n  The Python standard library should be conservative in adopting such annotations, but their use is allowed for new code and for big refactorings.\n  For code that wants to make a different use of function annotations it is recommended to put a comment of the form:\nnear the top of the file; this tells type checker to ignore all annotations. (More fine-grained ways of disabling complaints from type checkers can be found in PEP 484.)\n  Like linters, type checkers are optional, separate tools. Python interpreters by default should not issue any messages due to type checking and should not alter their behavior based on annotations.\n  Users who don\u0026rsquo;t want to use type checkers are free to ignore them. However, it is expected that users of third party library packages may want to run type checkers over those packages. For this purpose PEP 484 recommends the use of stub files: .pyi files that are read by the type checker in preference of the corresponding .py files. Stub files can be distributed with a library, or separately (with the library author\u0026rsquo;s permission) through the typeshed repo [5].\n  For code that needs to be backwards compatible, type annotations can be added in the form of comments. See the relevant section of PEP 484 [6].\n  PEP 526 introduced variable annotations. The style recommendations for them are similar to those on function annotations described above:\n  Annotations for module level variables, class and instance variables, and local variables should have a single space after the colon.\n  There should be no space before the colon.\n  If an assignment has a right hand side, then the equality sign should have exactly one space on both sides.\n  Yes:\n code: int\rclass Point:\rcoords: Tuple[int, int]\rlabel: str = '\u0026lt;unknown\u0026gt;'\r   No:\ncode:int # No space after colon\rcode : int # Space before colon\rclass Test:\rresult: int=0 # No spaces around equality sign\r   Although the PEP 526 is accepted for Python 3.6, the variable annotation syntax is the preferred syntax for stub files on all versions of Python (see PEP 484 for details).\n  ","id":77,"section":"posts","summary":"常量通常定义在代码前面，并且全都大写，分割的时候用_（下划线）分割。比如想，MAX_OVERFLOW和TOTAL这样。 Constants are usually defined on a module level and written in","tags":null,"title":"PEP-8——Python代码的风格指导","uri":"https://xuzhihao.top/2020/04/pep-8python%E4%BB%A3%E7%A0%81%E7%9A%84%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%AF%BC/","year":"2020"},{"content":"定额计价法　 定额计价法的概念 定额计价是根据招标文件，按照各国家建设行政主管部门发布的建设工程预算定额的“工程量计算规则”，同时参照省级建设主管部门发布的人工工日单价、机械台班单价、材料以及设备价格信息及同期市场价格，直接计算直接工程费，再按规定的计算计算方法计算间接费、利润、税金，汇总确定建筑安装工程造价。\n定额计价法的特点 定额计价法是我们使用了几十年的一种计价模式，其基本特征就是价格=定额+费用+文件规定，并作为法定性的依据强制执行，不论是工程招标编制标底还是投标报价均以此为唯一的依据，承发包双方共用一本定额和费用标准确定标底价和投标报价，一旦定额价与市场价脱节就会影响计价的准确性。\n定额计价是建立在以政府定价为主导的计划经济管理基础上的价格管理模式，它所体现的是政府对工程价格的直接管理和调控。\n工程量清单计价 这种计价方式，是时代的趋势，是市场经济的要求。\n工程量清单计价概念 工程量清单计价是指 投标人完成由 招标人提供的 工程量清单所需的全部费用，包括分部分项工程费、措施项目费、其他项目费、规费和税金\n工程量清单计价方式，是在建设工程招投标中，招标人自行或委托具有资质的中介机构编制反映工程实体消耗和措施性消耗的工程量清单，并作为招标文件的一部分提供给投标人，由投标人依据工程量清单自主报价的计价方式。在工程招标中采用工程量清单计价是国际上较为通行的做法。\n工程量清单计价的特点 1、工程量清单均采用了综合单价形式，综合单价中包含了工程直接费、间接费、管理费、风险费、利润、国家规定的各种规费等，一目了然，更适合工程招投标。\n2、工程量清单报价要求投标单位根据市场行情，自身实力报价，这就要求投标人注重工程单价的分析，在报价中反映本投标单位的实际能力。\n3、工程量清单报价具有合同化的法定性，本质上是单价合同的计价模式，中标后的单价一经合同确认，在竣工结算时不能调整，即量变价不变。\n4、工程量报价有利于加强合同的管理，明确承发包双方的责任，实现风险的合理分担，工程量的误差由发包方承担，工程报价的风险由投标方承担。\n5、工程量清单报价将推动计价依据的改革发展，推动企业编制自己的企业定额，提高自己的工程技术水平和经营管理能力。\n6、工程量清单计价是国际通行的计价办法，在我国实行工程量清单计价，有利于提高国内建设各方主体参与国际化竞争的能力。\n工程量清单计价与传统的定额计价的区别 抽象意义上的不同 1、工程量清单计价与定额计价不仅仅是在表现形式、计价方法上发生了变化，而是从定额管理方式和计价模式上发生了变化。首先，从思想观念上对定额管理工作有了新的认识和定位。 由于工程量清单计价提供的是计价规则、计价办法以及定额消耗量，摆脱了定额标准价格的概念，真正实现了量价分离、企业自主报价、市场有序竞争形式价格。工程量清单报价按相同的工程量和统一的计量规则，由企业根据自身情况报出综合单价，价格高低完全由企业自己确定，充分体现了企业的实力，同时也真正体现出公开、公平、公正。　采用行业统一定额计价，投标企业没有定价的发言权，只能被动接受。而工程量清单投标报价，可以充分发挥企业的能动性，企业利用自身的特点，使企业在投标中处于优势的位置。同时工程量清单报价体现了企业技术管理水平等综合实力，也促进企业在施工中加强管理、鼓励创新、从技术中要效率、从管理中要利润，在激烈的市场竞争中不断发展和壮大，企业的经营管理水平高，可以降低管理费，自有的机械设备齐全，可减少报价中的机械租赁费用，对未来要素价格发展趋势预测准确，就可以减少承包风险，增强竞争力，其结果促进了优质企业做大做强，使无资金、无技术，无管理的小企业、包工头退出市场，实现了优胜劣汰，从而形成管理规范、竞争有序的建设市场秩序。\n2、工程量清单计价是属于全面成本管理的范畴，其思路是“统一计算规则，有效控制水量，彻底放开价格，正确引导企业自主报价、市场有序竞争形成价格”。跳出传统的定额计价模式，建立一种全新的计价模式，依靠市场和企业的实力通过竞争形成价格，使业主通过企业报价可直观的了解项目造价。 具体表现的不同 1、编制对象与综合内容不同 工程量清单项目的工程内容是 以最终产品为对象，按实际完成一个综合实体项目所需工程内容列项。其工程量计算规则 是根据主体工程项目设置的，综合了清单项目的全部工程内容。\n基础定额项目主要 是以施工过程为对象划分的，工程量计算规则仅是单一的工程内容。\n2、计算口径不同 工程量清单项目工程量计算规则是 按工程实体尺寸的净量计算，不考虑施工方法和加工余量。\n基础定额则考虑了不同施工方法和加工余量的施工过程的实际数量。\n例如：土石方工程中的“挖基坑土方”，\n 按计算规范规定，工程量清单项目计算是按图示尺寸数量计算的净量（基础垫层底面积×挖土深度），不包括放坡及工作面等的开挖量。 基础定额项目计算则按实际开挖量计算，包括放坡及工作面等的开挖量，即包含了为满足施工工艺要求而增加的加工余量。  在工程量清单项目计算规范中，挖基坑土方的工程内容综合了排地表水、土方开挖、围护（挡土板）及支拆、基坑钎探、运输等内容。而在基础定额中则将上述的工程内容都作为单独的定额子目处理。\n3、计量单位不同 工程量清单项目的计量单位一般采用基本的物理计量单位或自然单位，如m^2,m^3基础定额中的计量单位 还包括扩大的物理计量单位，如100m^2，1000m^3,100m等。\n那么它们都什么时候用呢？  看合同约定，一般招投标都是清单计价 政府项目必须用清单计价，地产公司项目或私人项目可以采用 定额招标方式。  ","id":78,"section":"posts","summary":"定额计价法 定额计价法的概念 定额计价是根据招标文件，按照各国家建设行政主管部门发布的建设工程预算定额的“工程量计算规则”，同时参照省级建设主管","tags":["工程造价"],"title":"定额计价与清单计价","uri":"https://xuzhihao.top/2020/04/%E5%AE%9A%E9%A2%9D%E8%AE%A1%E4%BB%B7%E4%B8%8E%E6%B8%85%E5%8D%95%E8%AE%A1%E4%BB%B7/","year":"2020"},{"content":"对于爬虫来说，知道了网站的数据自增ID，那么就能将整个站点爬取下来。不过，那些大站，比如油管之类的，他们绝不会把业务的自增ID暴露出来，而是用一种可逆的字符串替代。\n一般有这么几种方法:\n 使用Hashids，Hashids是一个小型的开放源代码库，可从数字生成短的，唯一的，非顺序的ID。 Base64编码，这个方法最直接，大多数语言也具有这个功能。不过没有Hashids的花哨功能。 根据timestamp生成ID，使用计数器（如果有的话）+时间戳+一些系统值+一个随机整数。许多公司都采用这种方法，因为它在分布式系统中效果很好。这些id是彼此独立生成的，发生碰撞的风险非常小，可以忽略不计。 如果ID仅包含数字，可以使用Optimus，它基于Knuth的整数哈希方法，并产生混淆的整数ID。只有PHP和Go实现。 Nano ID，一个很小的，安全的，URL友好的，唯一的JavaScript字符串ID生成器。它也可用于多种语言。 其他的方法  使用hashids 安装\npip install hashids\r 使用\n首先初始化一个hashids示例\nfrom hashids import Hashids\r 编码（加密）\nid = hashids.encode(2)\r 生成的字符ID长度和数值大小有关。\n解码（解密）\nnum = hashids.decode('j0gW')\r 解码后返回时一个元组。如果你解码一个随机的字符串ID，不一定能恢复成数字，此时会返回空元组。\n不过，因为hashids可逆，所以拿到ID后可以反向推测出原始数字ID。我们在编码的时候可以指定盐值。理论上，盐值不泄露，就很难破解。\n指定盐值\nhashids = Hashids(salt=\u0026quot;aaa\u0026quot;)\rhashids.encode(123)\r 同样的数字使用不同的盐值编码得到的字符串是不同的，别人就无法猜出原始ID是多少了。\n限制hash长度\n默认情况下，数字越小，编码生成的字符串也比较断，为了讲不通大小的数值转化为统一长度的字符串，在初始化hashids时，可以指定hash的最小长度。\nhashids = Hashids(salt=\u0026quot;aaa\u0026quot;,min_length=10)\rhashids.encode(123)\r 限制hash的字符种类\n如果你不希望hash中有大写字母，那么可以在初始化的时候，指定hash字符串的范围，例如我们可以指定为所有的小写字母\nhashids = Hashids(alphabet=\u0026quot;abcdefghigklmopkrst\u0026quot;)\rhashids.encode(123)\r 需要注意的时候，alphabet至少要指定16个以上的不同字符。\nBase64 Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于\n$$ \\log_264=6 $$ 所以每6个比特为一个单元，可以对应某个打印字符。\n其它的方法之后会再写 ","id":79,"section":"posts","summary":"对于爬虫来说，知道了网站的数据自增ID，那么就能将整个站点爬取下来。不过，那些大站，比如油管之类的，他们绝不会把业务的自增ID暴露出来，而是","tags":["爬虫"],"title":"得到真正的业务ID","uri":"https://xuzhihao.top/2020/04/%E5%8F%8D%E6%89%92id%E4%B9%8Bhashids/","year":"2020"},{"content":"Git介绍 Git其实就是一个版本控制系统。它记录着文件内容的变化，你可以查阅每次修改的情况。\n其实很多人就一直在使用版本控制系统，许多人习惯把整个项目文件放到一个特定的文件夹中，并注明备份的时间以示区分。这是一个不错的整理自己文件的习惯，不过它虽然简单，但如果有时候一不小心混淆了所在的工作目录，或者写错文件，或者意外的覆盖了文件，那么就很难再将它们找回来了。\n其实除了Git，人们很早也开发了许多本地版本控制系统，早期的系统大多就是采用某种简单的数据库来记录文件历次更新的差异。但它们都是基于本地的系统。\n再后来，人们慢慢想到要让不同的开发者协同工作，这时候，就有了新的系统。它们都有单一的集中管理的服务器，服务器里保存着所有文件的修订版本。\n嗯，这样有了很大的进步。不过，把所有的鸡蛋都放在同一个菜篮子里，总是有那么些不安全。这样一来，分布式版本控制系统（DVCS)诞生了。在这个系统里，客户端是把代码仓库完整的拷贝下来，而不是像以前那样，仅仅就是最新文件的快照。这样即使服务器宕机，那么每一个拷贝下来的仓库，都能及时进行部署。\nGit就是有这个神奇功能的软件。\nGit特点 Git的三种状态 Git中的文件有三种状态。已提交（committed）、已修改（modified）和已暂存（staged）\n 已提交：表示数据已经安全保存在本地数据库中。 已修改：表示修改文件，但还没有保存都数据库中。 已暂存：表示对一个已修改文件的当前版本做了标记，是指包含了在下一次提交的快照中。  这三种状态，对应了三个工作区的概念：Git仓库、工作目录和暂存区域\nGit仓库目录，是Git用来保存项目数据和对象数据库的地方。这是Git最重要的部分。其实从其他计算机克隆仓库时，拷贝的就是这里的数据。\n工作目录 就是对项目的某个版本独立提取出来的内容。\n暂存文件 是一个文件，保存了下一次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称为“索引”\nGt直接记录快照，而非差异比较 每次你提交更新，或在Git中保存项目状态时，他主要对当时的文件制作一个快照并保存这个快照的索引。Git对待数据更像是一个快照流。\nGit中几乎所有操作都是本地执行 在Git中绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其他计算机的信息。这意味着，你在飞机或者火车上没有网络的情况下，想做些工作，你能愉快地提交，并且直到有网络连接时再上传。\nGit保证完整性 Git中的所有数据在存储前都计算校验和，然后以校验和来引用。这样，就能确保每次传输过程中，都能保证完整；如果不完整的话，Git就会及时发现。\nGit一般只添加数据 你在执行Git操作的时候，几乎只往Git数据库中增加数据，那么就很难执行不可逆的操作。当然你得需要每次都要进行提交。\n你了解了这个，我们使用Git就会很安心了。我们知道我们尝试了多种操作，而没有把事情搞糟的危险。\n当然，你也可以去参加开源社区做出贡献了！ 下一篇，我就会写关于Git的操作了。\n","id":80,"section":"posts","summary":"Git介绍 Git其实就是一个版本控制系统。它记录着文件内容的变化，你可以查阅每次修改的情况。 其实很多人就一直在使用版本控制系统，许多人习惯把","tags":["Git"],"title":"为什么要使用Git","uri":"https://xuzhihao.top/2020/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8git/","year":"2020"},{"content":"更新文章 hugo --theme= --baseUrl=\u0026quot;\u0026quot; --buildDrafts\rgit remote add origin https://github.com/XXX/XXX.github.io.git\rcd public\rgit add .\rgit commit -m \u0026quot;XXXX/XX/XX\u0026quot;\rgit push -u origin master\r 本地运行网站 hugo start\r ","id":81,"section":"posts","summary":"更新文章 hugo --theme= --baseUrl=\u0026quot;\u0026quot; --buildDrafts git remote add origin https://github.com/XXX/XXX.github.io.git cd public git add . git commit -m \u0026quot;XXXX/XX/XX\u0026quot; git push -u origin master 本地运行网站 hugo start","tags":["Hugo","Git"],"title":"Hugo的操作","uri":"https://xuzhihao.top/2020/04/%E6%9B%B4%E6%96%B0hugo/","year":"2020"},{"content":"简单介绍一下 汉语拼音，分为声母与韵母。全拼打字的时候，是将它们都打出来，比如[双]字 就需要打出shuang，相比双拼效率就低了。\n双拼，是将声母与韵母分开，除了zh、ch、sh之外，所有的声母都是键盘上的标准键。而把韵母分配的键盘26个按键上，这么一来每一个字字需要按两个键（一个声母和一个韵母）就可以完成输入了。\n我使用的就是[小鹤双拼]\n它为了让大家记住键位，还编了首曲子哈哈哈\n我的使用心得 使用了双拼之后，将自己所有电子设备的输入法都改为了双拼，现在，你在让我使用全拼到也很不适应了。\n从使用曲子辅助记忆到已经形成肌肉记忆，我大概花了一周的时间。之后就能熟练的使用双拼，学习新东西的那个过程是曲折的，但是一旦挺过来，那么就是光明的了。\n","id":82,"section":"posts","summary":"简单介绍一下 汉语拼音，分为声母与韵母。全拼打字的时候，是将它们都打出来，比如[双]字 就需要打出shuang，相比双拼效率就低了。 双拼，是将声","tags":null,"title":"从全拼到双拼","uri":"https://xuzhihao.top/2020/04/%E4%BB%8E%E5%85%A8%E6%8B%BC%E5%88%B0%E5%8F%8C%E6%8B%BC/","year":"2020"},{"content":"def teach_yourself(anything):\rwhile not creat(something):\rlearn()\rpractice()\rreturn teach_yourself(another)\rteach_yourself(something)\r 我挺赞同这个伪代码的，自学的过程就是不断学习、不断创造的过程，并将能否进行创造作为自学成功与否的关键。\n自学是时代的要求 在大学中，自学是必备的技能。学生时期是时间最为最为充分的时期，在这个时期吸足了养分，才能在接下来的漫长岁月中，更加茁壮。\n现在，是一个信息爆炸的时代，但是知识是不会爆炸的。那些之所以称为泡沫的东西，都是缺少了价值作为基础，反之，那些真正有价值的东西，是不会爆炸的，他会随着时间不断积累，不断增值。比如，现在的人工智能，它的理论在上个世纪就已经很完善了，只是当前机器的算力越来越强，才让那些理论真正的实现。\n求人不如求己，人与人之间的交往本质上就是交换，通过不断的自学，能实现自身价值的增值。在说后的社交中，也会处于更有利的地位。\n自学也是个人的一种乐趣 你不断的学习东西，通过他们进行创造，你将不断收获惊喜。并且，也会享受到之间你掌握那些手艺带来的方便、愉快。\n 用既有政策下的结果反对改革——陆铭\n 我也想通过不句话来说明，不要以为这些知识到来不了什么，只是你从未拥有，所以你才从未感受到，于是，你甚至信以为真，真的不去再学习。\n当这成为你的一种习惯，内化的你的骨子里。那么，不学习、不进步才会让你更加难受。这时你也真正的进化了。\n","id":83,"section":"posts","summary":"def teach_yourself(anything): while not creat(something): learn() practice() return teach_yourself(another) teach_yourself(something) 我挺赞同这个伪代码的，自学的过程就是不断学习、不断创造的过程，并将能否进行创造作为自学成功与否的关键。 自学是时代的要求 在","tags":null,"title":"关于自学的感想（1）","uri":"https://xuzhihao.top/2020/04/%E5%85%B3%E4%BA%8E%E8%87%AA%E5%AD%A6%E7%9A%84%E6%84%9F%E6%83%B31/","year":"2020"},{"content":" 人生而就是不平等的，但是在时间上却是平等的\n 珍惜自己的时间，远离焦虑 这个世界上又这么一个银行，他每天给你1440的资产，让你去消费，而且过了今天就一切清零，再给你1440.资产不会积累，只能不断消耗，但是每天的供应都是一样多。它其实就叫做时间银行。\n与其因焦虑而不断浪费自己的时间，不如去好好的利用它们、好好的享受它们。那些使用这些资产去学习、提升自己的人，其实本质上是相信自己以后的时间会更值钱。\n人就是很奇怪，对有形的东西感知能力还在线，对于那一些不容易感知的就会失去感觉，不信的话，想想你自己在家的这段时间，还能记得今天是周几吗？\n","id":84,"section":"posts","summary":"人生而就是不平等的，但是在时间上却是平等的 珍惜自己的时间，远离焦虑 这个世界上又这么一个银行，他每天给你1440的资产，让你去消费，而且过了今","tags":null,"title":"爱惜自己的时间","uri":"https://xuzhihao.top/2020/04/%E7%88%B1%E6%83%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E9%97%B4/","year":"2020"},{"content":"构成：\n  筏板\n使用面式垫层\n大开挖土方\n  集水坑\n使用集水坑柱墩垫层\n基坑土方\n  ","id":85,"section":"posts","summary":"构成： 筏板 使用面式垫层 大开挖土方 集水坑 使用集水坑柱墩垫层 基坑土方","tags":["工程造价"],"title":"GTJ2018中布置筏板基础的 基础土方","uri":"https://xuzhihao.top/2020/02/gtj2018%E4%B8%AD%E5%B8%83%E7%BD%AE%E7%AD%8F%E6%9D%BF%E5%9F%BA%E7%A1%80/","year":"2020"},{"content":"GTJ2018使用步骤：\n  建工程。设置工程的计算规则，室外地坪标高\n  建楼层。楼层层高，首层底标高，每一楼层的混凝土标号\n  建轴网。上下开间和左右进深。\n  绘图输入。定义构件、修改属性、绘制构件、套做法\n  查看报表\n  其它的就是细节的问题了。\n","id":86,"section":"posts","summary":"GTJ2018使用步骤： 建工程。设置工程的计算规则，室外地坪标高 建楼层。楼层层高，首层底标高，每一楼层的混凝土标号 建轴网。上下开间和左右进深","tags":["工程造价"],"title":"GTJ2018使用流程","uri":"https://xuzhihao.top/2020/02/gtj2018%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/","year":"2020"},{"content":"","id":87,"section":"posts","summary":"","tags":null,"title":"","uri":"https://xuzhihao.top/1/01/%E6%93%8D%E4%BD%9C%E5%BE%AE%E4%BF%A1itchat/","year":"0001"},{"content":"砼构件——柱、墙、梁、板   套清单选择条目\n  定额选择，套混凝土和混凝土模板，并将混凝土模板归类到措施项目\n  门、窗  套清单 定额选择  没有完全一样的时候，选择比较接近的\n房间——地面、踢脚、墙面、天棚 按照说明中的做法进行套取，一般套的东西比较多\n也可以通过图集进行套取\n屋面——坡屋顶、平屋顶 这个还没弄懂\n基础——土方 这个还没弄懂\n​\n","id":88,"section":"posts","summary":"砼构件——柱、墙、梁、板 套清单选择条目 定额选择，套混凝土和混凝土模板，并将混凝土模板归类到措施项目 门、窗 套清单 定额选择 没有完全一样的时候，选","tags":["工程造价"],"title":"GTJ2018中构件套做法流程","uri":"https://xuzhihao.top/1/01/gtj2018%E4%B8%AD%E6%9E%84%E4%BB%B6%E5%A5%97%E5%81%9A%E6%B3%95%E6%B5%81%E7%A8%8B/","year":"0001"},{"content":"结构 柱 柱子有三种做法：\n 按柱子. 按墙. 柱/墙。嵌入墙内部分按墙，之外的按柱子  第一种做法，贵；第二种做法，便宜；第三种做法，中等。\n剪力墙  定义宽度 画钢筋  注意：内墙，外墙要分开。内外墙价格不同，有些布置会不同。\n暗柱/连梁/暗梁  属于剪力墙钢筋的加强带 砼标号相同 和剪力墙一同浇筑 不需要单独计算  框架梁  定义，原位标注、集中标注 布置  板  定义板厚 钢筋（受力筋，箍筋） 负筋  二次结构 填充墙 注意：类别\n门窗 注意：离地高度\n对数：F3功能键\n连梁下门窗  门 窗 飘窗——连梁反算。需要建筑、结构图一起看。 墙洞——立面图  过梁 智能布置/门窗洞口宽度\n构造柱 自动生成构造柱\n圈梁 智能布置/砌体墙中心线\n其它层 1）复制选定图元到其它楼层\n2）从其它楼层复制构件单元\n3）定义斜板，三点定义斜板，平齐板底。\n4）屋面，布置防水、找平、保温等\n最后要手动修改\n","id":89,"section":"posts","summary":"结构 柱 柱子有三种做法： 按柱子. 按墙. 柱/墙。嵌入墙内部分按墙，之外的按柱子 第一种做法，贵；第二种做法，便宜；第三种做法，中等。 剪力墙 定义宽度","tags":["工程造价"],"title":"GTJ2018中绘图输入","uri":"https://xuzhihao.top/1/01/gtj2018%E4%B8%AD%E7%BB%98%E5%9B%BE%E8%BE%93%E5%85%A5/","year":"0001"}],"tags":[{"title":"Git","uri":"https://xuzhihao.top/tags/git/"},{"title":"Hugo","uri":"https://xuzhihao.top/tags/hugo/"},{"title":"JupyterLab","uri":"https://xuzhihao.top/tags/jupyterlab/"},{"title":"Markown","uri":"https://xuzhihao.top/tags/markown/"},{"title":"PyQt5","uri":"https://xuzhihao.top/tags/pyqt5/"},{"title":"Python Web","uri":"https://xuzhihao.top/tags/python-web/"},{"title":"Python代码学习","uri":"https://xuzhihao.top/tags/python%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"title":"Python内建函数","uri":"https://xuzhihao.top/tags/python%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"title":"Python标准库","uri":"https://xuzhihao.top/tags/python%E6%A0%87%E5%87%86%E5%BA%93/"},{"title":"Python魔法方法","uri":"https://xuzhihao.top/tags/python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"},{"title":"SQLite","uri":"https://xuzhihao.top/tags/sqlite/"},{"title":"TensorFlow","uri":"https://xuzhihao.top/tags/tensorflow/"},{"title":"办公自动化","uri":"https://xuzhihao.top/tags/%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"title":"工程造价","uri":"https://xuzhihao.top/tags/%E5%B7%A5%E7%A8%8B%E9%80%A0%E4%BB%B7/"},{"title":"布谷鸟算法","uri":"https://xuzhihao.top/tags/%E5%B8%83%E8%B0%B7%E9%B8%9F%E7%AE%97%E6%B3%95/"},{"title":"数据分析","uri":"https://xuzhihao.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"title":"数据可视化","uri":"https://xuzhihao.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"title":"爬虫","uri":"https://xuzhihao.top/tags/%E7%88%AC%E8%99%AB/"},{"title":"粒子算法","uri":"https://xuzhihao.top/tags/%E7%B2%92%E5%AD%90%E7%AE%97%E6%B3%95/"},{"title":"错误记录","uri":"https://xuzhihao.top/tags/%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/"},{"title":"项目管理","uri":"https://xuzhihao.top/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}]}