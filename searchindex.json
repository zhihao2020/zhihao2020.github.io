{"categories":[{"title":"Python","uri":"https://zhihao2020.github.io/categories/python/"},{"title":"建筑方面","uri":"https://zhihao2020.github.io/categories/%E5%BB%BA%E7%AD%91%E6%96%B9%E9%9D%A2/"},{"title":"思考","uri":"https://zhihao2020.github.io/categories/%E6%80%9D%E8%80%83/"},{"title":"效率工具","uri":"https://zhihao2020.github.io/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"},{"title":"数据分析","uri":"https://zhihao2020.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"title":"数据库","uri":"https://zhihao2020.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"杂七杂八","uri":"https://zhihao2020.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"title":"生活","uri":"https://zhihao2020.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"title":"神经网络","uri":"https://zhihao2020.github.io/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}],"posts":[{"content":"Python中，每个类都有实例属性。默认情况下Python用一个字典来保存一个对象的实例属性。这样，它允许我们再运行时取设置任意的新属性。\n然而，对于已知属性的小类来说，他可能是个瓶颈。这个字典浪费很多内存。Python不能在对象创建时直接分配一个固定量的内存来保存所有的属性。因此如果你创建许多对象，他会消耗掉很多内存。\n__slot__可以告诉Python不要使用字典，而且只给一个固定集合属性分配空间。\n 不使用__slots__:  class MyClass(object):\rdef __init__(self,name,identifier):\rself.name = name\rself.identifier = identifier\rself.set_up()\r...\r  使用__slot__:  class MyClass(object):\r__slot__ = ['name','identifer']\rdef __init__(self,name,identifier):\rself.name = name\rself.identifier = identifier\rself.set_up()\r...\r 如果你想有一个固定集合属性分配空间，那你就需要这样做：\n__slot__ = ('x','y')\r __slots__ 设置了一个元组，来限制类能添加的属性。现在，如果我们想绑定一个新的属性，比如 z，就会出错了.\n注意：\n slots 魔法：限定允许绑定的属性. __slots__ 设置的属性仅对当前类有效，对继承的子类不起效，除非子类也定义了 slots，这样，子类允许定义的属性就是自身的 slots 加上父类的 slots。  ","id":0,"section":"posts","summary":"Python中，每个类都有实例属性。默认情况下Python用一个字典来保存一个对象的实例属性。这样，它允许我们再运行时取设置任意的新属性。 然","tags":["Python魔法方法"],"title":"Python中__slots__","uri":"https://zhihao2020.github.io/2020/05/python%E4%B8%AD__slots__/","year":"2020"},{"content":"生成器的实现需要yield。\n例如这样：\ndef counter(start,stop):\rwhile start\u0026lt;=stop:\ryield start\rstart += 1\rfor i in counter(101,105):\rprint(i)\r yield和return最明显的区别是yield之后的语句可以被执行，而return后面语句会被忽略。\n并且，生成器也是一种迭代器，但是你只能对其迭代一次。这是因为他们并没有把所有的值存在内存中，而是运行时生成值。\n生成器被next()调用后，执行yield语句并生成一个值返回（然后，继续执行next()之外的语句）。下次，再被next()调用的时候，将从上次生成返回值yield语句处继续执行。\n在yield掉所有的值后，next()触发了⼀个StopIteration的异常。 基本上这个异常告诉我们，所有的值都已经被yield完了。你也许会奇怪，为什么我们在使⽤for循环时没有这个异常呢？答案很简单。for循环会⾃动捕捉到这个异常并停⽌调⽤next()。\n","id":1,"section":"posts","summary":"生成器的实现需要yield。 例如这样： def counter(start,stop): while start\u0026lt;=stop: yield start start += 1 for i in counter(101,105): print(i) yield和return最明显的区别是yield之后的语句可以被执行，而r","tags":null,"title":"Python中的生成器","uri":"https://zhihao2020.github.io/2020/05/python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8/","year":"2020"},{"content":"使用范本： from functools import wraps\rdef decorator_name(f):\r@wraps(f)\rdef decorated(*args,**kwargs):\rif not can_run:\rreturn \u0026quot;Function will not run\u0026quot;\rreturn decorated\r@decorator_name\rdef func():\rreturn(\u0026quot;Function is running\u0026quot;)\rcan_run - True\rprint(func())\rcan_run = False\rprint(func())\r 注意：@wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。\n不然，被装饰的函数，它的函数名称已经不是原来的名称了。\n使用场景 授权 from functools import wraps\rdef requires_auth(f):\r@wraps(f)\rdef decorated(*args,**kwargs):\rauth = request.authorization\rif not auth or not check_auth(auth,username,auth.password):\rreutrn f(*args,**kwargs)\rreturn decorated\r 日志 from functools import wraps\rdef logit(logfile='out.log'):\rdef logging_decorator(func):\r@wraps(func)\rdef wrapped_function(*args,**kwargs):\rlog_string = func.__name__ + \u0026quot; was called\u0026quot;\rprint(log_string)\rwith open(logfile,'a') as opened_file:\ropened_file.write(log_string + '\\n')\rreturn func(*args,**kwargs)\rreturn wrapped_function\rreturn logging_decorator\r@logit()\rdef myfunc1():\rpass\rmyfunc1()\r# Output: myfunc1 was called\r# 现在⼀个叫做 out.log 的⽂件出现了，⾥⾯的内容就是上⾯的字符串\r 升级一下日志 from functools import wraps\rclass logit(object):\rdef __init__(self,logfile='out.log'):\rself.logfile = logfile\rdef __call__(self,func):\r@wraps(func)\rdef wrapped_function(^args,**kwargs):\rlog_string = func.__name__+\u0026quot; was called\u0026quot;\rprint(log_string)\rwith open(self,logfile,'a') as opened_file:\ropened_file.write(log_string+'\\n')\r#发送一个通知。\rself.notify()\rreturn func(*args,**kwargs)\rreturn wrapped_function\rdef notify(self):\rpass\r 如果要添加email这个功能，可以使用继承：\nclass email_logit(logit):\rdef __init__(self,email='XXX',*args,**kwargs):\rself.email = email\rsuper(logit,self).__init__(*args,**kwargs)\rdef notify(self):\r#这里发送一封email\rpass\r ","id":2,"section":"posts","summary":"使用范本： from functools import wraps def decorator_name(f): @wraps(f) def decorated(*args,**kwargs): if not can_run: return \u0026quot;Function will not run\u0026quot; return decorated @decorator_name def func(): return(\u0026quot;Function is running\u0026quot;) can_run - True print(func()) can_run = False print(func()) 注意：@wraps接受一个函数来进行装饰，并加入了复制函数名称、","tags":null,"title":"Python中的装饰器(2)","uri":"https://zhihao2020.github.io/2020/05/python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A82/","year":"2020"},{"content":"当你运行独立的程序时，你的计算机就会生产一个简单的进程。他使用系统的资源（CPU、内存、硬盘存储）和你运行操作系统中的数据结构。\n你的计算机看起来能够多程序同时运行，其实，它是不同的程序不断运行、不断切换，看起来好像是同时运行，其实每时刻只运行一个程序。\n你可以从你的计算机中获得进程的数据。Python的标准库OS就可以提供关于系统的信息。例如这样：\n\u0026gt;\u0026gt;\u0026gt;import os\r\u0026gt;\u0026gt;\u0026gt;os.getpid() #获得进程的ID\r76051\r\u0026gt;\u0026gt;\u0026gt;os,getcwd() #现在运行的Python解释器的工作路径\r'/Users/wil'\r 通过multiprocessing创建进程 通过multiprocessing模块，可以将一些任务分配给多个进程，这样更节省时间。当然这就包括了，排队时间、使进程之间能够通信、等待所有过程完成。\n例如这样：\nimport multiprocessing\rimport os\rdef do_this(what):\rwhoami(what)\rdef whoami(what):\rprint(\u0026quot;Process %s says:%s\u0026quot;%(os.getid(),what))\rif __name__ == \u0026quot;__main__\u0026quot;:\rwhoami(\u0026quot;I am the main program\u0026quot;)\rfor n in range(4):\rp = multiprocessing.Process(target=do_this,args=(\u0026quot;I'm function %s\u0026quot;%n))\rp.start()\r 通过terminate()结束进程 如果你创建了一个或更多的进程，但是因为某些过程你想去结束这些进程，你可以用terminate()\n例如：\nimport multiprocessing\rimport os\rimport time\rdef whoami(what):\rprint(\u0026quot;I'm %s ,in process %s\u0026quot;%(what,os.getpid()))\rdef loopy(name):\rwhoami(name)\rstart = 1\rstop = 100000\rfor num in range(start,stop):\rprint(\u0026quot;\\t Number %s of %s .Hok!\u0026quot;%(num,stop))\rtime.sleep(1)\rif __name__ == \u0026quot;__main__\u0026quot;:\rwhoami(\u0026quot;main\u0026quot;)\rp = multiprocessing.Process(target=loopy,args=(\u0026quot;loopy\u0026quot;,))\rp.start()\rtime.sleep(5)\rp.terminate()\r ","id":3,"section":"posts","summary":"当你运行独立的程序时，你的计算机就会生产一个简单的进程。他使用系统的资源（CPU、内存、硬盘存储）和你运行操作系统中的数据结构。 你的计算机看","tags":[""],"title":"Python中的进程(1)","uri":"https://zhihao2020.github.io/2020/05/python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B/","year":"2020"},{"content":"使用pyautogui模块。\n 在Windows上，不需要安装其他模块。 在OS X上，运行sudo pip3 install pyobjc-framework-Quartz，sudo pip3 install pyobjc-core，然后sudo pip3 install pyobjc。 在Linux上，运行sudo pip3 install python3-xlib，sudo apt-get install scrot，sudo apt-get install python3-tk，以及sudo apt-get install python3-dev（Scrot是PyAutoGUI使用的屏幕快照程序）。  在这些依赖安装后，运行pip install pyautogui（或在OS X和Linux上运行pip3），安装pyautogui。\n首先 首先，需要知道计算机屏幕的坐标系统。分辨率是屏幕的宽高有多少像素。如果屏幕的分辨率设置为1920×1080，那么左上角的坐标是(0,0)，右下角的坐标是(1919,1079)\npyautogui.size()返回两个整数元组，包含屏幕的宽和高的像素数。\n移动鼠标 pyautogui.moveTo() 将鼠标立即移动到屏幕的指定位置。\n表示x、y坐标的整数值分别构成了函数的第一个和第二个参数。可选的duration整数或浮点数关键字参数，指定了将鼠标移到目的位置所需的秒数。如果不指定，默认值是零，表示立即移动（在PyAutoGUI函数中，所有的duration关键字参数都是可选的）。在交互式环境中输入以下内容：\n\u0026gt;\u0026gt;\u0026gt; import pyautogui\r\u0026gt;\u0026gt;\u0026gt; for i in range(10):\rpyautogui.moveTo(100, 100, duration=0.25)\rpyautogui.moveTo(200, 100, duration=0.25)`\r pyautogui.moveRel() 相当于当前位置移动鼠标。\npyautogui.moveRel() 也接受3个参数：向右水平移动多少个像素，向下垂直移动多少个像素，以及（可选的）花多少时间完成移动。为第一第二个参数提供负整数，鼠标将向左或向上移动。\npyautogui.moveRel(0, -100, duration=0.25)\r 获取鼠标位置pyautogui.position() import pyautogui.position()\r 可以确定鼠标当前的位置。它将返回函数调用时，鼠标x、y坐标的元组。\n控制鼠标交互 点击鼠标 要向计算机发送虚拟的鼠标点击，就调用pyautogui.click() 方法。默认情况下，点击将使用鼠标左键，点击发生在鼠标当前所在位置。如果希望点击在鼠标当前位置以外的地方发生，可以传入x、y坐标作为可选的第一第二参数。\n指定鼠标按键 通过加入button关键字参数，值分别为\u0026rsquo;left\u0026rsquo;、\u0026lsquo;middle'或\u0026rsquo;right\u0026rsquo;。\n例如：\npyautogui.click(100,150,button='left')\r 双击鼠标：pyautogui.doubleClick()执行双击鼠标左键，pyautogui.rightClick()执行双击鼠标右键，pyautogui.middleClick()执行双击中键。\n拖动鼠标 这是移动鼠标，同时按住一个键不放。\n有pyautogui.dragTo()将鼠标拖到一个新位置和pyautogui.dragRel()拖动鼠标移动到相对当前位置的位置。\n参数：x坐标/水平移动，y坐标/垂直移动和可选的时间间隔\n滚动鼠标 使用scoll()，它需要一个整数参数，说明向上或向下滚动多少单位。传递正整数表示向上滚动，传递负整数表示向下滚动。\n处理屏幕 pyautogui拥有屏幕快照的功能，可以根据当前屏幕的内容创建图形文件。这些函数也可以返回一个Pillow的Image对象，包含当前屏幕的内容。这可能需要事先安装pillow模块\n获取屏幕快照 pyautogui.sceenshot()\n\u0026gt;\u0026gt;\u0026gt;import pyautogui\r\u0026gt;\u0026gt;\u0026gt;im = pyautogui.screenshot()\r im变量将包含一个屏幕快照的Image对象。现在可以调用im变量中Image对象的方法，就像所有其他Image对象一样。在交互式环境中输入以下内容：\n\u0026gt;\u0026gt;\u0026gt;im.getpixel((50,200))\r(130,135,144)\r 向getpixel()函数传入坐标元组，如（50,200）它将告诉你图像中这些坐标处的像素颜色。gitpixel()函数的返回值是一个RGB元组，包含3个整数，表示像素的红绿蓝值（没有第四个值表示alpha，因为屏幕快照是完全不透明的）。这就是你的程序“看到”当前屏幕上内容的方法。\n分析屏幕快照 假设你的GUI自动化程序中，有一步是点击灰色按钮。在调用click() 方法之前，你可以获取屏幕快照，查看脚本要点击处的像素。如果它的颜色和灰色按钮不一样，那么程序就知道出问题了。也许窗口发生了意外的移动，或者弹出式对话框挡住了该按钮。这时，不应该继续（可能会点击到错误的东西，造成严重破坏），程序可以“看到”它没有点击在正确的东西上，并自行停止。\n如果屏幕上指定的 x、y 坐标处的像素与指定的颜色匹配，PyAutoGUI 的pixelMatchesColor() 函数将返回True。第一和第二个参数是整数，对应x和y坐标。第三个参数是一个元组，包含3个整数，是屏幕像素必须匹配的RGB颜色。在交互式环境中输入以下内容：\n\u0026gt;\u0026gt;\u0026gt;import pyautogui\r\u0026gt;\u0026gt;\u0026gt;im = pyautogui.screenshot()\r\u0026gt;\u0026gt;\u0026gt;im.getpixel((50,200))\r\u0026gt;\u0026gt;\u0026gt; pyautogui.pixelMatchesColor(50, 200, (130, 135, 144))\rTrue\r\u0026gt;\u0026gt;\u0026gt; pyautogui.pixelMatchesColor(50, 200, (255, 135, 144))\rFalse\r 在获取屏幕快照，并用getpixel() 函数取得特定坐标处像素颜色的RGB元组之后，将同样的坐标和RGB元组传递给pixelMatchesColor() ，这应该返回True。然后改变RBG元组中的一个值，用同样的坐标再次调用pixelMatches Color() ，这应该返回False。你的GUI自动化程序要调用click() 之前，这种方法应该有用。\n请注意，给定坐标处的颜色应该“完全”匹配。即使只是稍有差异（例如，是（255，255，254）而不是（255，255，255）），那么函数也会返回False。\n图像识别 向PyAutoGUI提供希望点击的图像，让它去弄清楚坐标。\n可以使用locateOnScreen()返回图像所在处的坐标。它需要的参数，是你要想操作的位置的图片。\n例如这样：\n\u0026gt;\u0026gt;\u0026gt;import pyautogui\r\u0026gt;\u0026gt;\u0026gt;pyautogui.locateOnSreen('submit.png')\r(673, 745, 70, 29)\r locateOnScreen()函数返回4个整数的元组，是屏幕上首次发现该图像时左边的x坐标、顶边的y坐标、宽度以及高度。\n如果屏幕上找不到这个图像，locateOnScreen()会返回None。\n注意要成功识别，屏幕上的图像必须与提供的图像完全匹配。即使只差一个像素，locateOn Screen() 函数也会返回None。\n如果该图像在屏幕上能够找到多处，locateAllOnScreen() 函数将返回一个Generator对象。可以将它传递给list() ，返回一个4整数元组的列表。\n像这样：\n[(643, 790, 70, 29), (1007, 801, 70, 29)]\r 得到这个4整数元组，你就可以点击这个图像的中心了。\n\u0026gt;\u0026gt;\u0026gt; pyautogui.center((643, 745, 70, 29))\r(678, 759)\r\u0026gt;\u0026gt;\u0026gt; pyautogui.click((678, 759))\r 控制键盘 通过键盘发送一个字符串 pyautogui.typewrite()向计算机发送虚拟按键。这些按键产生什么效果，取决于当前获得焦点的窗口和文本输入框。\n向文本框输入时，你的用鼠标点击，确保它获得焦点。\n\u0026gt;\u0026gt;\u0026gt; pyautogui.click(10, 100); pyautogui.typewrite('Hello world!')\r 它其实还有一个参数，默认情况下，typewrite() 函数将立即打印出完整字符串。但是，你可以传入可选的第二参数，在每个字符之间添加短时间暂停。例如，pyautogui.typewrite（'Helloworld!'，0.25）将在打出H后等待1/4秒。打出e以后再等待1/4秒，如此等等\n键名 不是所有的键都很容易用单个文本字符来表示。例如，如何把Shift键或左箭头键表示为单个字符？在PyAutoGUI中，这些键表示为短的字符串值：\u0026lsquo;esc\u0026rsquo; 表示Esc键，\u0026lsquo;enter\u0026rsquo; 表示Enter。\n除了单个字符串参数，还可以向typewrite() 函数传递这些键字符串的列表。例如，以下的调用表示按a键，然后是b键，然后是左箭头两次，最后是X和Y键：\n\u0026gt;\u0026gt;\u0026gt; pyautogui.typewrite(['a', 'b', 'left', 'left', 'X', 'Y'])\r 下面是pyautogui接受的所有可能的键字符串：\n   键盘键字符串 含义     \u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026lsquo;A\u0026rsquo;, \u0026lsquo;B\u0026rsquo;, \u0026lsquo;C\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;!', \u0026lsquo;@', \u0026lsquo;#'，等等 单个字符的键   \u0026lsquo;enter\u0026rsquo;（or \u0026lsquo;return\u0026rsquo; or \u0026lsquo;\\n\u0026rsquo;） 回车键   \u0026lsquo;esc\u0026rsquo; Esc键   \u0026lsquo;shiftleft\u0026rsquo;, \u0026lsquo;shiftright\u0026rsquo; 左右Shift键   \u0026lsquo;altleft\u0026rsquo;, \u0026lsquo;altright\u0026rsquo; 左右Alt键   \u0026lsquo;ctrlleft\u0026rsquo;, \u0026lsquo;ctrlright\u0026rsquo; 左右Ctrl键   \u0026lsquo;tab\u0026rsquo;（or \u0026lsquo;\\t\u0026rsquo;） Tab键   \u0026lsquo;backspace\u0026rsquo;, \u0026lsquo;delete\u0026rsquo; Backspace和Delete键   \u0026lsquo;pageup\u0026rsquo;, \u0026lsquo;pagedown\u0026rsquo; Page Up和Page Down键   \u0026lsquo;home\u0026rsquo;, \u0026lsquo;end\u0026rsquo; Home和End键   \u0026lsquo;up\u0026rsquo;, \u0026lsquo;down\u0026rsquo;, \u0026lsquo;left\u0026rsquo;, \u0026lsquo;right\u0026rsquo; 上下左右箭头键   \u0026lsquo;f1\u0026rsquo;, \u0026lsquo;f2\u0026rsquo;, \u0026lsquo;f3\u0026rsquo;，等等 F1至F12键   \u0026lsquo;volumemute\u0026rsquo;, \u0026lsquo;volumedown\u0026rsquo;, \u0026lsquo;volumeup\u0026rsquo; 静音、减小音量、放大音量键（有些键盘没有这些键，但你的操作系统仍能理解这些模拟的按键）   \u0026lsquo;pause\u0026rsquo; Pause键   \u0026lsquo;capslock\u0026rsquo;, \u0026lsquo;numlock\u0026rsquo;, \u0026lsquo;scrolllock\u0026rsquo; Caps Lock，Num Lock和Scroll Lock键   \u0026lsquo;insert\u0026rsquo; Ins或Insert键   \u0026lsquo;printscreen\u0026rsquo; Prtsc或Print Screen键   \u0026lsquo;winleft\u0026rsquo;, \u0026lsquo;winright\u0026rsquo; 左右Win键（在Windows上）   \u0026lsquo;command\u0026rsquo; Command键（在OS X上）   \u0026lsquo;option\u0026rsquo; Option键（在OS X上）    按下和释放键盘 pyautogui.keyDown()向计算机发送虚拟按键。\npyautogui.keyUp()向计算机发送虚拟按键释放。\n当然，有pyautogui.press(),它调用这两个函数，模拟完整的击键。\n例如，打出@字符\n\u0026gt;\u0026gt;\u0026gt;pyautogui.keyDown('shift');pyautogui.press('4');pyautogui.keyUp('shift')\r 热键组合 热键”或“快捷键”是一种按键组合，它调用某种应用功能。拷贝选择内容的常用热键是Ctrl-C（在Windows和Linux上）或⌘-C（在OS X上）。用户按住Ctrl键，然后按C键，然后释放C和Ctrl键。要用pyautogui的keyDown() 和keyUp() 函数来做到这一点，就比较麻烦了，好在还有别的方法。\npyautogui.hotkey()接受多个键字符串参数，按顺序按下，再按相反的顺序释放。例如对于Ctrl-C，代码就像下面这样：\npyautogui.hotkey('ctrl','c')\r [refer to]http://pyautogui.readthedocs.org/\nhttp://pyautogui.readthedocs.org/\n","id":4,"section":"posts","summary":"使用pyautogui模块。 在Windows上，不需要安装其他模块。 在OS X上，运行sudo pip3 install pyobjc-framework-Quart","tags":["办公自动化"],"title":"Python控制键盘和鼠标","uri":"https://zhihao2020.github.io/2020/05/python%E6%8E%A7%E5%88%B6%E9%94%AE%E7%9B%98%E5%92%8C%E9%BC%A0%E6%A0%87/","year":"2020"},{"content":"shutil函数可以让你能够复制、移动、改名和删除文件。\n复制文件和文件夹 shutil.copy(source,destination),这个以将路径source处的文件复制到路径destination处的文件夹（参数都要是字符串格式）。如果destination是一个文件名，它将作为被复制文件的新名字。\n这个方法会返回被复制文件的路径。\nshutil.tree(source,destination)是将路径source处的文件夹，包括它所有文件和子文件夹，复制到路径destination处的文件。（source和destination都要是字符串）\n该方法会返回一个字符串，是新复制的文件夹的路径。\n文件和文件夹的移动和改名 shutil.move(source,destination)，将路径source处文件移动到路径destination，并返回新位置的绝对路径的字符串。\n注意：如果destiantion中有和source名称一样的文件，那么该文件将被重写。\ndestination路径也可以是一个文件名。这样的结果就是source文件被移动并改名。\n注意：\n\u0026gt;\u0026gt;\u0026gt;import shutil\r\u0026gt;\u0026gt;\u0026gt;shutil.move('c:\\\\1.txt','D:\\\\2')\r 这样会1.txt将会被命名为2（没有txt文件扩展名的文本文件）。\n文件夹的移动也是如此：\n\u0026gt;\u0026gt;\u0026gt;import shutil\r\u0026gt;\u0026gt;\u0026gt;shutil.move('c:\\\\1','D:\\\\2')\r 永久删除文件和文件夹 利用os模块。可以删除一个文件或一个空文件。但利用shutil模块，可以删除一个文件夹及其所有的内容。\n 用os.unlink(path)将删除path处的文件。 调用os.rmdir(path)将删除path处的文件夹。该文件夹必须为空，其中没有任何文件和文件夹。 调用shutil.rmtree(path)将删除path处的文件夹，它包含的所有文件和文件夹都会被删除。  注意：这是永久删除。\nsend2trash安全删除 这需要第三方库。\npip install send2trash\r 使用方法如下：\nimport send2trash\rsend2trash.sendtrash('trash.txt')\r 虽然它将文件发送到垃圾箱，让你稍后能够恢复它们，但是这不像永久删除文件，不会释放磁盘空间。如果你希望程序释放磁盘空间，就要用os和shutil来删除文件和文件夹。\n请注意，send2trash()函数只能将文件送到垃圾箱，不能从中恢复文件。\n遍历目录树 os.walk()函数被传入以个字符串值，即一个文件夹的路径。你可以在一个for循环中使用os.wakl()，遍历目录树。\nos.walk()在循环的每次迭代中，返回三个值：\n 当前文件夹名称的字符串 当前文件夹中的子文件夹的字符串列表 当前文件夹中的文件的字符串的列表  import os\rfor folderName,subfolders,filenames in os.walk(\u0026quot;D:\\\\歌曲\u0026quot;):\rprint('The current folder'+folderName)\rfor subfolder in subfolders:\rprint(\u0026quot;Subfolder of \u0026quot;+folderName+'\\\\'+subfolder)\rfor filename in filenames:\rprint('File inside '+folderName+'\\\\'+filename)\r ","id":5,"section":"posts","summary":"shutil函数可以让你能够复制、移动、改名和删除文件。 复制文件和文件夹 shutil.copy(source,destination),这个","tags":["办公自动化"],"title":"Python组织文件","uri":"https://zhihao2020.github.io/2020/05/python%E7%BB%84%E7%BB%87%E6%96%87%E4%BB%B6/","year":"2020"},{"content":"ASCII Table \u0026ndash; Nonprintable Characters    Control Character Python \u0026amp; Java Hexadecimal Decimal Description     ^@ \\0 00 0 Null character   ^A \\1 01 1 Start of heading   ^B \\2 02 2 Start of text   ^C \\3 03 3 End of text   ^D \\4 04 4 End of transmission   ^E \\5 05 5 Enquiry   ^F \\6 06 6 Acknowledge   ^G \\a 07 7 Audible bell   ^H \\b 08 8 Backspace   ^I \\t 09 9 Horizontal tab   ^J \\n 0a 10 Line feed   ^K \\v 0b 11 Vertical tab   ^L \\f 0c 12 Form feed   ^M \\r 0d 13 Carriage return   ^N \\x0e 0e 14 Shift out   ^O \\x0f 0f 15 Shift in   ^P \\x10 10 16 Data link escape   ^Q \\x11 11 17 Device control 1   ^R \\x12 12 18 Device control 2   ^S \\x13 13 19 Device control 3   ^T \\x14 14 20 Device control 4   ^U \\x15 15 21 Negative Acknowledge   ^V \\x16 16 22 Synchronous idle   ^W \\x17 17 23 End of transmission block   ^X \\x18 18 24 Cancel   ^Y \\x19 19 25 End of medium   ^Z \\x1a 1a 26 Substitute   ^[ \\x1b 1b 27 Escape   *^* \\x1c 1c 28 File separator   ^] \\x1d 1d 29 Group separator   ^^ \\x1e 1e 30 Record separator   ^- \\x1f 1f 31 Unit separator    ","id":6,"section":"posts","summary":"ASCII Table \u0026ndash; Nonprintable Characters Control Character Python \u0026amp; Java Hexadecimal Decimal Description ^@ \\0 00 0 Null character ^A \\1 01 1 Start of heading ^B \\2 02 2 Start of text ^C \\3 03 3 End of text ^D \\4 04 4 End of transmission ^E \\5 05 5 Enquiry ^F \\6 06 6 Acknowledge ^G \\a 07 7 Audible bell ^H \\b 08 8 Backspace ^I \\t","tags":null,"title":"ASCII表-Nonprintable Characters","uri":"https://zhihao2020.github.io/2020/05/ascii%E8%A1%A8-nonprintable-characters/","year":"2020"},{"content":"OpenPrinter 打开打印机\nwin32print.OpenPrinter(string,Defaults)\r string就是打印机的名字，当为空的时候打开本地打印机\nStartDocPrinter StartDocPrinter(hprinter, level , tuple )\r level=1\ntuple:对应于level参数的元组\n​\t[0]:字符串：docName:指定文档名称\n​\t[1]:字符串：outputFile：指定输出文件的名称。要打印到打印机，请将其设置为“无”。\n​\t[2]字符串：dataType。标识用于记录文档的数据类型，例如“原始”或“emf”，用于记录打印作业。这个成员可以是None。如果不是None, StartDoc函数将其传递给打印机驱动程序。请注意，打印机驱动程序可能会忽略所请求的数据类型。\nStartPagePrinter(hprinter) 通知打印后台处理程序要在指定打印机上打印页面。\nWritePrinter win32print.WritePrinter(hprinter,buf)\r 参数：\nhprinter：OpenPrinter返回的打印机\nbuf：字符串\n**返回值：**返回写入打印机的字节数。\nEndPagePrinter(hprinter) 结束打印作业中的页面。\nEndDocPriner(hprinter) EndDocPrinter函数结束指定打印机的打印作业。在使用WritePrinter之后使用。\nClosePrinter 关闭打印机\nwin32print.ClosePrinter(hPrinter)\r hPrinter是OpenPrinter创建的对象。\n实例 def output(self):\rhPrinter = win32print.OpenPrinter(self.PRINTER_NAME)\rtry:\rwin32print.StartDocPrinter(hPrinter, 1, (\u0026quot;Notification\u0026quot;, None, \u0026quot;RAW\u0026quot;))\rtry:\rwin32print.StartPagePrinter(hPrinter)\rwin32print.WritePrinter(hPrinter, \u0026quot;\\n\u0026quot;.join(self.lines).encode(\u0026quot;GBK\u0026quot;))\rwin32print.EndPagePrinter(hPrinter)\rfinally:\rwin32print.EndDocPrinter(hPrinter)\rfinally:\rwin32print.ClosePrinter(hPrinter)\rself.lines = []\r 注意：为了避免汉字乱码，用GKB编码。\nrefer to http://docs.activestate.com/activepython/2.5/pywin32/win32print.html\n","id":7,"section":"posts","summary":"OpenPrinter 打开打印机 win32print.OpenPrinter(string,Defaults) string就是打印机的名字，当为空的时候打开本地打印机 StartDocPrinter StartDocPrinter(hprinter, level , tuple ) level=1 tuple:对应于level参数的元组 ​ [0]:字符串：","tags":null,"title":"Python中win32print","uri":"https://zhihao2020.github.io/2020/05/python%E4%B8%ADwin32print/","year":"2020"},{"content":"enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中\n写法\nenumerate(sequence,[start=0])\r 参数\n sequence——一个可迭代对象 start——下标起始位置  返回值\n返回enumerate（枚举）对象\n实例\n\u0026gt;\u0026gt;\u0026gt;seq = ['one', 'two', 'three']\r\u0026gt;\u0026gt;\u0026gt; for i, element in enumerate(seq):\r... print i, element\r... 0 one\r1 two\r2 three\r \u0026gt;\u0026gt;\u0026gt;seasons = ['Spring', 'Summer', 'Fall', 'Winter']\r\u0026gt;\u0026gt;\u0026gt; list(enumerate(seasons))\r[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]\r\u0026gt;\u0026gt;\u0026gt; list(enumerate(seasons, start=1)) # 下标从 1 开始\r[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]\r ","id":8,"section":"posts","summary":"enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中 写法 enumerate(sequence,[start=0]) 参数 sequen","tags":["Python内建函数"],"title":"Python中的enumerate()","uri":"https://zhihao2020.github.io/2020/05/python%E4%B8%AD%E7%9A%84enumerate/","year":"2020"},{"content":"用于对文本字符串进行自动换行或填充。\ntextwrap.wrap(text,width=70,**kwargs) ​\t对text中的单独段落自动换行以使每行长度最多为width个字符。返回输出行组成的列表，行尾不带换行符。如果自动换行输出结果没有任何内容，则返回空列表。\ntextwrap.fill(text,width=70,**kwargs) ​\t对text中单独段落自动换行，并返回一个包含被自动换行段落的单独字符串。相当于：\u0026quot;\\n\u0026quot;.join(wrap(text,...))\ntextwrap.shorten(text, width, **kwargs） 折叠并截断文本以适合的宽度。\n文本中的空格被折叠（搜用空格均由单个空格代替）。如果结果适合width，啧将其返回。否则，将从末尾丢弃足够的单词，以使其余单词加上占位符（placeholder)带到width的长度。\n\u0026gt;\u0026gt;\u0026gt; textwrap.shorten(\u0026quot;Hello world!\u0026quot;, width=12)\r'Hello world!'\r\u0026gt;\u0026gt;\u0026gt; textwrap.shorten(\u0026quot;Hello world!\u0026quot;, width=11)\r'Hello [...]'\r\u0026gt;\u0026gt;\u0026gt; textwrap.shorten(\u0026quot;Hello world\u0026quot;, width=10, placeholder=\u0026quot;...\u0026quot;)\r'Hello...'\r textwrap.indent（text，prefix，predicate = None ） 将前缀添加到文本中所选行的开头。\n通过调用来分隔行text.splitlines(True)。\n默认情况下，将前缀添加到并非仅由空格组成的所有行（包括任何行尾）。\n\u0026gt;\u0026gt;\u0026gt; indent(s, ' ')\r' hello\\n\\n \\n world'\r 可选的谓词参数可用于控制缩进的行。例如，很容易将前缀添加到空行和仅空白行：\n\u0026gt;\u0026gt;\u0026gt; print(indent(s, '+ ', lambda line: True))\r+ hello\r+\r+\r+ world\r ","id":9,"section":"posts","summary":"用于对文本字符串进行自动换行或填充。 textwrap.wrap(text,width=70,**kwargs) ​ 对text中的单独段落自动换行以使每行长度最多为width个字符。返回输出行组成的列表，行尾不带换行","tags":["Python标准库"],"title":"Python中的textwrap","uri":"https://zhihao2020.github.io/2020/05/python%E4%B8%AD%E7%9A%84textwrap/","year":"2020"},{"content":"捕捉异常 使用try/except语句实现。\nexcept() except语句可以使用不止一次：\ntry:\rxxx\rexcept ZeroDivisionError:\rprint()\rexcept TypeError:\rprint()\r 或者像这样\ntry:\rXXX\rexcept (ZeroDivisionError,TypeError):\rprint()\r 如果你想记录原因的话，可以这样：\ntry:\rXXX\rexcept (ZeroDivisionError,TypeError) as e:\rprint(e)\rpass\r try/except\u0026hellip;else try:\rprint('A simple task')\rexcept:\rprint('There is Error)\relse:\rprint('It went as planned)\r finally 用于出发异常后的处理。\ntry:\r1/0\rexcept:\rprint('There is Error')\relse:\rprint('OK')\rfinally:\rprint('Clean up')\r 触发异常 使用raise语句。\n\u0026gt;\u0026gt;\u0026gt;raise Exception('hyperdrive overload')\r 异常类    类名 描述     Exception 所有异常的基类   AttributeError 特性引用或赋值失败时引发   IOError 试图打开不存在的文件（包括其他情况）时引发   IndexError 使用索引中不存在的索引引发   KeyError 使用映射中不存在的键引发   NameError 找不到变量时引发   SyntaxError 代码为错误形式引发   TypeError 内建操作或函数应用于错误类型的对象时引发   ValueError 内建操作或函数应用于正确对象，但是该对象使用不合理的值引发   ZeroDivisionError 除法或取模时 第二个参数为0    ","id":10,"section":"posts","summary":"捕捉异常 使用try/except语句实现。 except() except语句可以使用不止一次： try: xxx except ZeroDivisionError: print() except TypeError: print() 或者像这样 try: XXX except (ZeroDivisionError,TypeError): print() 如果你想记录原因的话，可以","tags":null,"title":"Python中的异常处理","uri":"https://zhihao2020.github.io/2020/05/python%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","year":"2020"},{"content":"允许向用户显示基于Web的文档。在大多数情况下，只需要调用open()函数就可以。\n脚本 webbrowser 可以用作模块的命令行界面。它接受一个 URL 作为参数。还接受以下可选参数：-n 如果可能，在新的浏览器窗口中打开 URL ； -t 在新的浏览器页面（“标签”）中打开 URL。这些选择当然是相互排斥的。用法示例:\npython -m webbrowser -t \u0026quot;http://www.python.org\u0026quot;\r 常用方法： webbrowser.open(url, new=0, autoraise=True) ​\t使用默认浏览器显示 url。 如果 new 为 0，则尽可能在同一浏览器窗口中打开 url。 如果 new 为 1，则尽可能打开新的浏览器窗口。 如果 new 为 2，则尽可能打开新的浏览器页面（“标签”）。 如果 autoraise 为 “True”，则会尽可能置前窗口（请注意，在许多窗口管理器下，无论此变量的设置如何，都会置前窗口）。\nwebbrowser.open_new(url) 如果可能，在默认浏览器的新窗口中打开 url，否则，在唯一的浏览器窗口中打开 url。\nwebbrowser.open_new_tab(url) 如果可能，在默认浏览器的新页面（“标签”）中打开 url，否则等效于 open_new()。\nwebbrowser.get(using=None) 返回浏览器类型为 using 指定的控制器对象。 如果 using 为 None，则返回适用于调用者环境的默认浏览器的控制器。\nwebbrowser.register(name, constructor, instance=None, *, preferred=False) 注册 name 浏览器类型。 注册浏览器类型后， get()函数可以返回该浏览器类型的控制器。 如果没有提供 instance，或者为 None，constructor 将在没有参数的情况下被调用，以在需要时创建实例。 如果提供了 instance，则永远不会调用 constructor，并且可能是 None。将 preferred 设置为 True 使得这个浏览器成为 get() 不带参数调用的首选结果。 否则，只有在您计划设置 BROWSER 变量，或使用与您声明的处理程序的名称相匹配的非空参数调用 get() 时，此入口点才有用。\n","id":11,"section":"posts","summary":"允许向用户显示基于Web的文档。在大多数情况下，只需要调用open()函数就可以。 脚本 webbrowser 可以用作模块的命令行界面。它接受一个 URL 作为参数。还接","tags":["Python标准库"],"title":"Python的webbrowser","uri":"https://zhihao2020.github.io/2020/05/python%E7%9A%84webbrowser/","year":"2020"},{"content":"新建一个数据库文件 使用cd命令进入到数据库文件的目录下，用sqlite3命令创建数据库文件。\nsqlite3 DatabaseName.db\r 查看已建立的数据库文件 使用database命令检查是否在数据库列表中。\n打开已建立的数据库文件 在用cd命令，进入到要打开的数据库文件所在的目录下，使用sqlite3打开数据库文件。例如：\nsqlite3 test.db\r 查看帮助信息 在SQLite命令行模式下，输入.help命令可以查看SQLite的帮助信息。\n创建表 在SQLite命令行模式下，输入像下列的命令：\ncreate table people(id integer pri,ary key,name text)\r 添加数据 sqlite﹥insert into people( id, name) values( 1,' zhangsan');\r 查询表中的记录 sqlite ﹥ select * from people;  适用于SQLite的数据库管理西欧通 推荐 SQLiteStudio 软件，其官方下载地址为 https:// sqlitestudio.pl/index.rvt。 这款软件是绿色的免安装的，解压缩后直接运行就可以了。\n","id":12,"section":"posts","summary":"新建一个数据库文件 使用cd命令进入到数据库文件的目录下，用sqlite3命令创建数据库文件。 sqlite3 DatabaseName.db 查看已建立的数据库文件 使用database命","tags":null,"title":"SQLite常用操作","uri":"https://zhihao2020.github.io/2020/05/sqlite%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","year":"2020"},{"content":"安装python-pdfkit：\npip install pdfkit\r 安装wkhtmlopdf\n https://wkhtmltopdf.org/downloads.html下载安装包 配置好环境变量  使用 一个简单的梨子：\nimport pdfkit\rpdfkit.from_string('hello,python','out.pdf')\rpdfkit.from_url('http://baidu.com','out.pdf')\rpdfkit.from_file('test.html', 'out.pdf')\r ","id":13,"section":"posts","summary":"安装python-pdfkit： pip install pdfkit 安装wkhtmlopdf https://wkhtmltopdf.org/downloads.html下","tags":null,"title":"html转为图片","uri":"https://zhihao2020.github.io/2020/04/html%E8%BD%AC%E4%B8%BA%E5%9B%BE%E7%89%87/","year":"2020"},{"content":"使用日志模块要启用logging模块，\n开始 在程序运行时将日志信息显示在屏幕上，请将下面的代码复制到程序顶部（但在Python的#!行之下）\nimport logging\rlogging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s\r- %(message)s')\r 你不需要过于担心它的工作原理，但基本上，当 Python 记录一个事件的日志时，它会创建一个LogRecord对象，保存关于该事件的信息。logging模块的函数让你指定想看到的这个LogRecord对象的细节，以及希望的细节展示方式。\n这里，我们在想打印日志信息时，使用logging.debug() 函数。这个debug() 函数将调用basicConfig()，打印一行信息。这行信息的格式是我们在 basicConfig()函数中指定的，并且包括我们传递给 debug() 的消息。\n输出\n2020-04-30 12:20:12,664 - DEBUG - Start of program\r 这样子的信息。\n日志消息的好处在于，你可以随心所欲地在程序中想加多少就加多少，稍后只要加入一次logging.disable(logging.CRITICAL)调用，就可以禁止日志。\n不像print()，logging模块使得显示和隐藏日志信息之间的切换变得很容易。\n日志级别    级别 日志函数 描述     DEBUG logging.debug() 最低级别。用于小细节。通常只有在诊断问题时，你才会关心这些消息   INFO logging.info() 用于记录程序中一般事件的信息，或确认一切工作正常   WARNING logging.warning() 用于表示可能的问题，它不会阻止程序的工作，但将来可能会   ERROR logging.error() 用于记录错误，它导致程序做某事失败   CRITICAL logging.critical() 最高级别。用于表示致命的错误，它导致或将要导致程序完全停止工作    日志级别的好处在于，你可以改变想看到的日志消息的优先级。向basicConfig()函数传入logging.DEBUG作为level关键字参数，这将显示所有日志级别的消息（DEBUG是最低的级别）。\n在开发了更多的程序后，你可能只对错误感兴趣。在这种情况下，可以将basicConfig() 的level参数设置为logging.ERROR，这将只显示ERROR和CRITICAL消息，跳过DEBUG、INFO和WARNING消息。\n禁用日志 在调试完程序后，你可能不希望所有这些日志消息出现在屏幕上。logging. disable() 函数禁用了这些消息，这样就不必进入到程序中，手工删除所有的日志调用。只要向logging.disable() 传入一个日志级别，它就会禁止该级别和更低级别的所有日志消息。所以，如果想要禁用所有日志，只要在程序中添加logging. disable(logging.CRITICAL)\nlogging.critical('Critical error! Critical error!')\r 将日志记录到文件 除了将日志消息显示在屏幕上，还可以将它们写入文本文件。logging.basic Config() 函数接受filename关键字参数.\nlogging.basicConfig(filename='myProgramLog.txt', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')\r ","id":14,"section":"posts","summary":"使用日志模块要启用logging模块， 开始 在程序运行时将日志信息显示在屏幕上，请将下面的代码复制到程序顶部（但在Python的#!行之下） import","tags":["Python标准库"],"title":"Python中的logging模块","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84logging%E6%A8%A1%E5%9D%97/","year":"2020"},{"content":"使用ShellExecute方法，可以打印Microsoft Office文档，PDF文件，文本文件以及几乎搜友主要应用程序。\nimport tempfile\rimport win32api\rimport win32print\rfilename = tempfile.mktemp (\u0026quot;.txt\u0026quot;)\ropen (filename, \u0026quot;w\u0026quot;).write (\u0026quot;This is a test\u0026quot;)\rwin32api.ShellExecute (\r0,\r\u0026quot;print\u0026quot;,\rfilename,\rNone,\r\u0026quot;.\u0026quot;,\r0\r)\r 将filename改为PDF文件的路径，就可以打印PDF了。\n注意：当出现了Python win32 ShellExecute错误31：“连接到系统的设备无法运行。”时，你可能计算机没有安装pdf阅读器，并且导致了该错误（要打印的文件是pdf）。\n在那台计算机上安装福昕阅读器可以解决该问题。\n不过，这个很难控制输出。\n","id":15,"section":"posts","summary":"使用ShellExecute方法，可以打印Microsoft Office文档，PDF文件，文本文件以及几乎搜友主要应用程序。 import tempfile import win32api import win32print filename =","tags":null,"title":"ShellExecute简单控制打印机","uri":"https://zhihao2020.github.io/2020/04/shellexecute%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E6%9C%BA/","year":"2020"},{"content":"SQLite官方安装地址：http://www.sqlite.org/download.html\n我下载了压缩包sqlite-tools-win32-x86-3310100.zip，下载后直接解压到磁盘上，可以看到解压后有sqlite.exe文件。\n接下来需要将SQLite路径加入到Path环境变量中。右键单击“ 我的电脑”，从弹出 的快捷菜单中选择“ 属性” →“ 高级系统设置” →“ 环境变量”，在系统变量中 找到 Path,将解压缩后的SQLite 路径加入到变量值中。\n打开命令行窗口，输入 sqlite3，显示SQLite Version就说明安装成功了。\n","id":16,"section":"posts","summary":"SQLite官方安装地址：http://www.sqlite.org/download.html 我下载了压缩包sqlite-tools-wi","tags":["SQLite"],"title":"Window下安装SQLite","uri":"https://zhihao2020.github.io/2020/04/%E5%AE%89%E8%A3%85sqlite/","year":"2020"},{"content":"plt.plot()函数参数详解 plt.plot(x,y,linestyle,\rlinewidth,color,marker,\rmarkersize,markeredgecolor,\rmarkerfactcolor,label,alpha)\r x：指定折现图的x轴数据\ny：指定折线图的y轴数据\nlinestyle：指定折线类型，可以是实线、虚线、点虚线、点点线等，默认实线\nlinewidth：指定折线的宽度\nmarker：可以为折线图添加点，该参数是设置点的形状；\nmarkersize：设置点的大小；\nmarkeredgecolor：设置点的边框色；\nmarkerfactcolor：设置点的填充色；\nlabel：为折线图添加标签，类似于图例的作用；\n实例(一元折现图) import matplotlib.pyplot as plt\rimport matplotlib as mpl\rimport pandas as pd\r#设置中文编码\rplt.rcParams['font.sans-serif'] = ['SimHei']\r#设置时间戳作为横轴刻度\rdate = pd.date_range('3/5/2018',periods=17,freq='2D')\ry1=[79,122,387,112,82,87,122,144,309,117,132,80,66,55,110,58,198] #设置绘图框的大小\rfig = plt.figure(figsize=(10,6))\r#添加标题和坐标轴标签\rplt.title('每日文章阅读量折线图') plt.xlabel('文章推送日期') plt.ylabel('文章阅读量')\r#绘图\rplt.plot(date, y1,'b',linestyle='-',linewidth=2,marker='o',markersize=6,markeredgecolor='black',markerfacecolor='steelblue',label='阅读量')\r#获取图的坐标信息\rax = plt.gca()\r# 设置日期的显示格式 date_format = mpl.dates.DateFormatter(\u0026quot;%Y-%m-%d\u0026quot;) ax.xaxis.set_major_formatter(date_format)\r#设置x轴每个刻度的间隔天数\rxlocator = mpl.ticker.MultipleLocator(2)\rax.xaxis.set_major_locator(xlocator)\r#设置图例显示 plt.legend(bbox_to_anchor=[1,1]) # 为了避免x轴日期刻度标签的重叠，设置x轴刻度自动展现，并且60度倾斜\rfig.autofmt_xdate(rotation=60)\r#显示图形\rplt.show()\r 实例（二元折线图） import matplotlib.pyplot as plt\rimport matplotlib as mpl\rimport pandas as pd\r#设置中文编码\rplt.rcParams['font.sans-serif'] = ['SimHei']\r#设置时间戳作为横轴刻度\rdate = pd.date_range('3/5/2018',periods=17,freq='2D')\r#推送文章阅读量\ry1 = [79,122,387,112,82,87,122,144,309,117,132,80,66,55,110,58,198] #推送文章图文阅读人数\ry2 = [42,113,171,91,62,66,94,95,186,100,114,68,58,55,122,60,192]\r#设置绘图框的大小\rfig = plt.figure(figsize=(10,6))\r#添加标题和坐标轴标签\rplt.title('每日文章阅读量及阅读人数折线图') plt.xlabel('文章推送日期') plt.ylabel('文章阅读量')\r#绘图1\rplt.plot(date, y1,'b',linestyle='-',linewidth=2,marker='o',markersize=6,markeredgecolor='black',markerfacecolor='steelblue',label='阅读量')\r#绘图2\rplt.plot(date, y2,'r',linestyle='-',linewidth=2,marker='o',markersize=6,markeredgecolor='black',markerfacecolor='steelblue',label='阅读人数')\r#获取图的坐标信息\rax = plt.gca()\r# 设置日期的显示格式 date_format = mpl.dates.DateFormatter(\u0026quot;%Y-%m-%d\u0026quot;) ax.xaxis.set_major_formatter(date_format)\r#设置x轴每个刻度的间隔天数\rxlocator = mpl.ticker.MultipleLocator(2)\rax.xaxis.set_major_locator(xlocator)\r#设置图例显示 plt.legend(bbox_to_anchor=[1,1]) # 为了避免x轴日期刻度标签的重叠，设置x轴刻度自动展现，并且45度倾斜\rfig.autofmt_xdate(rotation=60)\r#显示图形\rplt.show()\r ","id":17,"section":"posts","summary":"plt.plot()函数参数详解 plt.plot(x,y,linestyle, linewidth,color,marker, markersize,markeredgecolor, markerfactcolor,label,alpha) x：指定折现图的x轴数据 y：指定折线图的y轴数据 linestyle：指定折线类型，可以是实线、虚线、","tags":["可视化"],"title":"用Matplotlib画折线图","uri":"https://zhihao2020.github.io/2020/04/%E7%94%A8matplotlib%E7%94%BB%E6%8A%98%E7%BA%BF%E5%9B%BE/","year":"2020"},{"content":"安装时，换个源 pip install -i http://pypi.tuna.tsinghua.edu.cn/simple XXX\r https://pypi.douban.com/simple 豆瓣的源\n显示版本和路径 pip --version\r 升级pip pip install -U pip\r 安装包 pip install SomePackage #这是下载最新版本\rpip install SomePackage==1.0.4 #指定版本\rpip install SomePackafe\u0026gt;=1.0.4 #最小版本\r 升级包 pip install --upgrade SomePackage\r 卸载包 pip uninstall SomePackage\r 显示安装包信息 pip show\r 查看指定包的详细信息 pip show -f SomePackage\r 列出可升级的包 pip list\r 当同时有Python2和Python3时 Python2:\npython -m pip install XXX\r Python3:\npython -m pip install XXX\r ","id":18,"section":"posts","summary":"安装时，换个源 pip install -i http://pypi.tuna.tsinghua.edu.cn/simple XXX https://pypi.douban.com/simple 豆瓣的源 显示版本和路径 pip --version 升级pip pip install -U pip 安装包 pip install SomePackage #这是下载最新版本 pip install SomePackage==1.0.4 #指定版本 pip install SomePackafe\u0026gt;=1.0.4 #最小版本 升级包 pip","tags":null,"title":"pip使用指南","uri":"https://zhihao2020.github.io/2020/04/pip%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","year":"2020"},{"content":"1、进入某个盘 D: #进入D盘\r 2、查看目录文件 dir\r 3、创建目录和删除目录 md 目录名 //创建目录\rrd 目录名 //删除目录\r 4、查看本机ip ipconfig\r 5、清楚屏幕 cls\r 6、复制文件 copy 路径\\文件名 路径\\文件名 //把一个文件拷贝到另一个地方。\r 7、移动文件 move 路径\\文件名 路径\\文件名\r 8、删除文件 del 文件名\r 这个只能删除文件，不能删除文件夹\n9、Ping ping ip\r ","id":19,"section":"posts","summary":"1、进入某个盘 D: #进入D盘 2、查看目录文件 dir 3、创建目录和删除目录 md 目录名 //创建目录 rd 目录名 //删除目录 4、查看本机ip ipconfig 5、清楚屏幕 cls 6","tags":null,"title":"Windows下CMD常用命令","uri":"https://zhihao2020.github.io/2020/04/windows%E4%B8%8Bcmd%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","year":"2020"},{"content":"我在使用pip 安装Tendorflow时，出现了错误。\n我查阅了好多博客，发现他们大多都是一个版本的\u0026hellip;..\nTensorflow能在3.6（64bits）下安装，而3.6（32bits）安装就会出错。\n我下载了Python3.6.6（64bits）后，重新pip 就没有问题了\n","id":20,"section":"posts","summary":"我在使用pip 安装Tendorflow时，出现了错误。 我查阅了好多博客，发现他们大多都是一个版本的\u0026hellip;.. Tensorflow能","tags":["错误记录"],"title":"【Tensorflow安装问题】总是无法安装tensorflow：Could not find a version that satisfies the requirement tensorflow","uri":"https://zhihao2020.github.io/2020/04/tensorflow%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E6%80%BB%E6%98%AF%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85tensorflowcould-not-find-a-version-that-satisfies-the-requirement-tensorflow/","year":"2020"},{"content":"CSV表示\u0026quot;Comma-Sparated Values（逗号分隔的值）\u0026quot;,CSV文件是简化的电子表格，保存为纯文本文件。\n不过，CSV是简单的，但也缺少了Excel电子表格的许多功能\n 值没有类型，所有东西都是字符串； 没有字体大小或颜色的设置； 没有多个工作表 不能指定单元格的宽度和高度； 不能合并单元格； 不能嵌入图像或图表。  使用CSV模块 CSV是python自带的标准库,用于读写CSV文件。\nReader对象 用csv从csv文件读取数据，需要创建一个Reader对象。\nimport csv\rexample = open('example.csv')\rReader = csv.reader(example)\rfor row in Reader:\rprint(str(row))\r 注意：Reader有属性.line_num表示这是行数。\nWrite对象 Write对象让你的数据写入到CSV文件。要创建一个Write对象，就使用csv.write()函数。\nimport csv\routputFile = open('output.csv','w',newline='')\routputWrite = csv.write(outputFile)\routputWrite.writerow(['apple','orange','egg'])\routputFile.close()\r delimiter和lineterminator关键字参数 import csv\rcsvFile = open('example.csv','w',newline='')\rcsvWirte = csv.write(scvFile,delimiter='\\t',lineterminator='\\n\\n')\rcsvWriter.writerow(['egg','bacon','ham'])\rscvWriter.writerow(['fly','swim','play'])\rcsvFile.close()\r 改变了文件中的分隔符和行终止字符。分隔符是一行中单元格之间出现的字符。默认情况下，CSV文件的分隔符是逗号。行终止字符是出现在行末的字符。默认情况下，行终止字符是换行符。你可以利用csv.writer()的delimiter和lineterminator关键字参数，将这些字符改成不同的值。传入delimeter=\u0026rsquo;\\t'和lineterminator=\u0026rsquo;\\n\\n\u0026rsquo;，这将单元格之间的字符改变为制表符，将行之间的字符改变为两个换行符。然后我们调用writerow()三次，得到3行。\n那么，example.csv文件包含以下内容：\negg\tbacom\tham\rfly\tswim\tplay\r 既然单元格是由制表符分隔的，我们就使用文件扩展名.tsv，表示制表符分隔的值。\n","id":21,"section":"posts","summary":"CSV表示\u0026quot;Comma-Sparated Values（逗号分隔的值）\u0026quot;,CSV文件是简化的电子表格，保存为纯文本文件。 不","tags":["办公自动化","Python标准库"],"title":"操作CSV表格","uri":"https://zhihao2020.github.io/2020/04/%E4%BD%BF%E7%94%A8csv%E6%A8%A1%E5%9D%97/","year":"2020"},{"content":"打标签 打标签就是用于给历史中的某一个提交打上标签。\n列出标签 在Git中列出已有的标签是非常直观的。只需要输入git tag。\n当然，你可以使用特定的模式，查看标签。例如，Git自身的源代码仓库包含标签超过500个。如果只对1.8.5系列感兴趣，可以运行：\ngit tag -l 'v1.8.5*'\r 创建标签 Git使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。\n一个轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。\n然而。附注标签是存储在Git数据库中的一个完整对象。它们是可以被校验的；其中包含打标签的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用GNU Privacy Guard（GPG）签名与验证。\n建议：创建附注标签，你可以拥有上述的所有信息；如果，你住需要说和临时标签。那么就使用轻量标签。\n附注标签 创建的方法就是，在运行tag命令时指定-a选项：\ngit tag -a v1.4 -m \u0026quot;my version 1.4\u0026quot;\r -m选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git会运行编辑器要求你输入信息。\n通过使用git show命令可以看到标签信息与对应的提交信息：\n$ git show v1.4\rtag v1.4\rTagger: Ben Straub \u0026lt;ben@straub.cc\u0026gt;\rDate: Sat May 3 20:19:12 2014 -0700\rmy version 1.4\rcommit ca82a6dff817ec66f44342007202690a93763949\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Mon Mar 17 21:52:11 2008 -0700\rchanged the version number\r 输出显示了打标签者的消息、打标签的日期时间、附注信息。然后显示具体的提交信息。\n轻量标签 本质上是将提交校验和存储到一个文件中——没有保存其他信息、创建轻量级标签，不需要其他的选项，只需要提供标签名字：\ngit tag v1.4\r 这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：\n$ git show v1.4-lw\rcommit ca82a6dff817ec66f44342007202690a93763949\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Mon Mar 17 21:52:11 2008 -0700\rchanged the version number\r 后期打标签 你可以对过去的提交打标签。\n比如这样：\n$ git log --pretty=oneline\r15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'\ra6b4c97498bd301d84096da251c98a07c7723e65 beginning write support\r0d52aaab4479697da7686c15f77a3d64d9165190 one more thing\r6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'\r0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function\r4682c3261057305bdd616e23b64b0857d832627b added a todo file\r166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\r9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\r964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo\r8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\r 现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要 在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：\ngit tag -a v1.2 9fceb02\r 共享标签 默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到 共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin [tagname]。\n$ git push origin v1.5\rCounting objects: 14, done.\rDelta compression using up to 8 threads.\rCompressing objects: 100% (12/12), done.\rWriting objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.\rTotal 14 (delta 3), reused 0 (delta 0)\rTo git@github.com:schacon/simplegit.git\r* [new tag] v1.5 -\u0026gt; v1.5\r 如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库 服务器上的标签全部传送到那里。\n git push origin --tags\r 删除标签 删除掉你本地仓库上的标签 可以使用命令 git tag -d 。例如，可以使用下面的命令删除掉 一个轻量级标签：\n$ git tag -d v1.4-lw\rDeleted tag 'v1.4-lw' (was e7d5add)\r 删除任何远程仓库的标签 首先，删除你本地的标签，\n然后，使用git push \u0026lt;remote\u0026gt;:refs/tags/\u0026lt;tagname\u0026gt;来更新你的远程仓库。\n$ git push origin :refs/tags/v1.4-lw\rTo /git@github.com:schacon/simplegit.git\r- [deleted] v1.4-lw\r 检出标签 如果你想查看某个标签指向的文件版本，可以使用git checkout命令。注意这样会使你的仓库处于“分离头指针（detached HEAD)”状态。\n$ git checkout 2.0.0\rNote: checking out '2.0.0'.\rYou are in 'detached HEAD' state. You can look around, make experimental\rchanges and commit them, and you can discard any commits you make in this\rstate without impacting any branches by performing another checkout.\rIf you want to create a new branch to retain commits you create, you may\rdo so (now or later) by using -b with the checkout command again. Example:\rgit checkout -b \u0026lt;new-branch\u0026gt;\rHEAD is now at 99ada87... Merge pull request #89 from schacon/appendixfinal\r$ git checkout 2.0-beta-0.1\rPrevious HEAD position was 99ada87... Merge pull request #89 from\rschacon/appendix-final\rHEAD is now at df3f601... add atlas.json and cover image\r 在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何 分支，并且将无法访问，除非确切的提交哈希。因此，如果你需要进行更改——比如说你正在修复旧版本的错 误——这通常需要创建一个新分支：\n$ git checkout -b version2 v2.0.0\rSwitched to a new branch 'version2'\r 当然，如果在这之后又进行了一次提交，version2 分支会因为这个改动向前移动，version2 分支就会和 v2.0.0 标签稍微有些不同，这时就应该当心了。\nGit别名 如果不想每次都输入完整的Git命令，可以通过git config文件来为每一个命令设置一个别名。\n比如：\n$ git config --global alias.co checkout\r$ git config --global alias.br branch\r$ git config --global alias.ci commit\r$ git config --global alias.st status\r 这意味，当要输入git commit时，只需要输入git ci。\n","id":22,"section":"posts","summary":"打标签 打标签就是用于给历史中的某一个提交打上标签。 列出标签 在Git中列出已有的标签是非常直观的。只需要输入git tag。 当然，你可以使用特定","tags":["Git"],"title":"Git基本操作(2)","uri":"https://zhihao2020.github.io/2020/04/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C2/","year":"2020"},{"content":"在Push文件到github时候，出现了这个问题。这个问题是本地和Github中Repository中的文件出现冲突所造成的。在提交之前你需要将远端的改变合并到本地上。\n解决方法：\n方法一：\ngit fretch [remote-name]\rgit merge [remote-name]\r 方法二：\ngit push -f\r 这样会使你的本地代码替代git仓库内的内容。\n","id":23,"section":"posts","summary":"在Push文件到github时候，出现了这个问题。这个问题是本地和Github中Repository中的文件出现冲突所造成的。在提交之前你需","tags":["Git"],"title":"Git错误non-fast-forward后的解决方案","uri":"https://zhihao2020.github.io/2020/04/git%E9%94%99%E8%AF%AFnon-fast-forward%E5%90%8E%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","year":"2020"},{"content":"from PyQt5 import QtWidgets\rimport sys\rif __name__ == \u0026quot;__main__\u0026quot;:\rapp = QtWidgets.QApplication(sys.argv)\rw = QtWidgets.QWidgst()\rw.resize(600,600)\rw.move(600,600)\rw.setWindowTitle(\u0026quot;第一个Qt程序\u0026quot;)\rw.show()\rsys.exit(app.exec_())\r 其中，\napp = QtWidgets.QApplication(sys.argv)\r 每一个PyQt5程序都需要一个QApplication对象，QApplication类包含在QTWidgets模块中。sys.argv是一个命令行参数列表。这个程序可以通过，双击.py文件，通过参数来选择启动脚本的方式。\nsys.exit(app.exec_())\r 这是进入该程序的主循环。\n事件处理从本行代码开始，主循环接收事件消息并将其分发给程序的各个控件。如果调用 exit()或主控件被销毁，主循环就会结束。\n使用 sys.exit()方法退出可以确保程序完整地结束，在这种情况下系统的环境变量会记录程序是如何退出的。\n如果程序运行成功，那么exec_()的返回值为0，否则为非0。\n为什么程序主函数的返回值为0？ 无论是C还是C++，从main函数返回的结果都相当于调用了exit函数，main的返回值会作为传给exit函数的参数。 exit对参数的说明如下：\n 如果参数为0或EXIT_SUCCESS，则向外部环境报告程序运行圆满结束。 如果参数为EXIT_FAILURE，则向外部环境报告程序运行以失败告终。 如果参数为其他值，则结果由实现定义。  所以，return 0是有确定语义的返回方式，而return 1则不具备可移植性。\nPyQt 5的底层使用的就是C++，所以不难理解为什么主函数执行成功后exec_()的返回值为0了。\n有关exec_()的下画线问题解释如下： QApplication类的exec_()函数来自于PyQt 4及以前版本，因为在Python 2中，exec是Python的关键字，为避免冲突，PyQt 5使用了exec_()这个名称。这个问题在Python 3中已经解决，所以如果你的代码只在Python 3下运行，那么完全可以写成： app.exec() 当然，为了保持向后兼容，带有下画线的函数还是可以使用的，在本书后面的代码中将保持这种风格。\n","id":24,"section":"posts","summary":"from PyQt5 import QtWidgets import sys if __name__ == \u0026quot;__main__\u0026quot;: app = QtWidgets.QApplication(sys.argv) w = QtWidgets.QWidgst() w.resize(600,600) w.move(600,600) w.setWindowTitle(\u0026quot;第一个Qt程序\u0026quot;) w.show() sys.exit(app.exec_()) 其中， app = QtWidgets.QApplication(sys.argv) 每一个PyQt","tags":["PyQt5"],"title":"创建你的第一个GUI","uri":"https://zhihao2020.github.io/2020/04/%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAgui/","year":"2020"},{"content":"使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。\n分支简介 在进行提交操作时，Git会保存一个提交对象（commit object）。知道了Git保存数据的方式，我们可以想到——该提交对象包含一个指向暂存内容快照的指针。但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。\n首次提交产生的提交对象没有父对象，普通提交操作 产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，\n为了形象地说明，我们假设有一个工作目录，里面包含了三个将要被暂存和提交的文件。暂存操作会为每一个文件计算校验和，然后会把当前版本的文件快照保存到Git仓库中，最终将校验和加入到暂存区域等待提交：\n当使用git commit进行操作时，Git会先计算每一个子目录的校验和，然后在Git仓库中这些校验和保存为树对象。随后，Git便会创建一个提交对象，它除了包含上面提到的那些信息外， 还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。\n现在，Git仓库中有五个对象：三个blob对象（保存着文件快照）、一个树对象（记录着目录结构和blob对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。\n做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次对象（父对象）的指针。\nGit分支，其实本质上仅仅是指向提交对象的可变指针。Git的默认分支名字是master。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的master分支。它会在每次的提交操作中自动的向前移动。\n分支创建 Git通过为你创建一个可以移动的新指针，来为你创建新分支。\n比如：\ngit branch testing\r 这会在当前所在的提交对象上，创建一个指针。\n那么，Git又是怎么知道当前在哪一个分支上呢？也很简单，他有一个HEAD的特殊指针。\n在Git中，HEAD是一个指针，指向当前所在本地分支。在本例中，你仍然在master分支上。因为git branch命令仅仅创建一个新分支，并不会自动切换到新分支中去。\n你可以简单地使用git log命令查看各个分支当前所指的对象。提供这一功能的参数是--decorate。\n$ git log --oneline --decorate\rf30ab (HEAD, master, testing) add feature #32 - ability to add new\r34ac2 fixed bug #1328 - stack overflow under certain conditions\r98ca9 initial commit of my project\r 正如你所见，当前“master”和“testing”分支均指向校验和以f30ab开头的提供对象。\n分支切换 要切换到一个已存在的分支，你需要使用git checkout命令。我们现在切换到新建的testing分支去：\ngit checkout testing\r 这样HEAD就指向testing分支。\n那么，这样的实现方式会给我们咋样呢？\ngit commit -a -m 'made a chage'\r \n如图所示，你的testing分支向前移动了，但是master分支却没有，它仍然指向运行git checkout时所指的对象。这就有意思了，现在我们切换回master分支看看：\ngit checkout master\r 这条命令，做了两件事。\n一是，HEAD指回master分支，\n二是，将工作目录恢复成master分支所指向的快照内容。也就是说，你现在做的修改的话，项目将始于一个较旧的版本。本质就是，忽略testing分支所做的修改，以便于向另一个方向进行开发。\n 分支切换会改变你工作目录中的文件。\n在切换分支时，一定要注意你工作目录里的文件会被改变，如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如果Git不能干净利落地完成这个任务，他将禁止切换分支。\n 这时，我们运行这个\ngit commit -a -m 'made oher changes'\r 现在，这个项目的提交历史已经产生了分叉。\n因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回master分支进行了另外一些工作。上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。而所有这些工作，你需要的命令只有branch、checkout和commit。\n咱们可以通过git log --online --decorate --graph --all,它会输出你的提交历史、各个分支指向以及项目的分支分叉情况。\n","id":25,"section":"posts","summary":"使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 分支简介 在进行提交操作时，Git会保存一个提交对象（commit obj","tags":["Git"],"title":"Git分支(1)","uri":"https://zhihao2020.github.io/2020/04/git%E5%88%86%E6%94%AF1/","year":"2020"},{"content":"shelve可以当做是简单的存储。\n使用方法如下：\nimport shelve\rd = shelve.open(filename) # open -- file may get suffix added by low-level\r# library\rd[key] = data # store data at key (overwrites old data if\r# using an existing key)\rdata = d[key] # retrieve a COPY of data at key (raise KeyError\r# if no such key)\rdel d[key] # delete data stored at key (raises KeyError\r# if no such key)\rflag = key in d # true if the key exists\rklist = list(d.keys()) # a list of all existing keys (slow!)\r# as d was opened WITHOUT writeback=True, beware:\rd['xx'] = [0, 1, 2] # this works as expected, but...\rd['xx'].append(3) # *this doesn't!* -- d['xx'] is STILL [0, 1, 2]!\r# having opened d without writeback=True, you need to code carefully:\rtemp = d['xx'] # extracts the copy\rtemp.append(5) # mutates the copy\rd['xx'] = temp # stores the copy right back, to persist it\r# or, d=shelve.open(filename,writeback=True) would let you just code\r# d['xx'].append(5) and have it work as expected, BUT it would also\r# consume more memory and make the d.close() operation slower.\rd.close() # close it\r **注意：**正如，上面示例所表明的。\n比如：\n\u0026gt;\u0026gt;\u0026gt;import shelve\r\u0026gt;\u0026gt;\u0026gt;a = shelve.open('test.dat')\r\u0026gt;\u0026gt;\u0026gt;a['x'] = ['a','b','c']\r\u0026gt;\u0026gt;\u0026gt;a['x'].append('d')\r\u0026gt;\u0026gt;\u0026gt;a['x']\r['a','b','c']\r 这里的\u0026rsquo;d'没有存储在\u0026rsquo;x'下面。\n你需要做得是像这样：\n\u0026gt;\u0026gt;\u0026gt;temp = a['x']\r\u0026gt;\u0026gt;\u0026gt;temp.append('d')\r\u0026gt;\u0026gt;\u0026gt;a['x'] = temp\r\u0026gt;\u0026gt;\u0026gt;a['x']\r['a','b','c','d']\r 因为Python的语法的问题，当一个易变的持久化字典条目被修改的时候，shelve不能察觉。\n但如果writeback被设定为True，所有的被访问条目也缓存在内存中，并依靠sync()和close()写回内存中。这可以让它方便,写入可变持久字典条目,但是,如果访问许多条目,它可以消耗大量的内存缓存,它可以关闭操作非常慢,因为所有访问条目都被写入(没有办法确定哪些条目是可变的,哪些是没变的)。\n注意，最后要使用close()，不让数据不会存入都内存中。像下面这样也是可以的。\nwith shelve.open('spam') as db:\rdb['eggs'] = 'eggs'\r ","id":26,"section":"posts","summary":"shelve可以当做是简单的存储。 使用方法如下： import shelve d = shelve.open(filename) # open -- file may get suffix added by low-level # library d[key] = data # store data at key (overwrites old data if # using an existing key) data = d[key] # retrieve a COPY of data at key (raise","tags":["Python标准库"],"title":"Python中的shelve","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84shelve/","year":"2020"},{"content":"PyInstaller原理 PyInstaller其实就是把Python解释器和脚本打包成一个可执行文件，和编译成真正的机器码完全是两回事。所以，千万不要指望打包成的可执行文件会提高运行效率，相反，可能会降低运行效率，但是这样做得好处是运行的机器上不用安装Python和脚本依赖的库。\n需要注意的是，使用PyInstaller打包生成的程序，只能在与生成打包的机器系统相同的环境中运行。也就是说，这个可执行文件不具备可移植性。若需要在不同的操作系统上运行，就必须在该系统环境上重新进行打包。\n安装PyInstaller pip install PyInstaller\r PyInstall安装后，我们在Python的安装目录Scripts中可以找到pyinstaller.exe应用。\n使用PyInstaller 在命令行中进入需要打包的代码所在目录下，运行\npyinstaller [opts]yourprogram.py\r 可选参数：\n -F,-onefile,打包成一个EXE文件 -D,-onedir ,创建一个目录，包含EXE文件，但会依赖很多文件 -w(小写w),-windowed,-noconsole,使用窗口，无控制台  最后在同目录下的dist子文件中生成EXE文件\n这里重复说明一下：在Windows64位上编译，也只能在64位上运行\n给程序装一个图标 我们首先去下载一个ico格式的图标文件。将这个ico文件放在项目路径下面。\n注：在Mac上打包要下载.icns格式的图标文件\n在命令行运行：\npyinstaller -F -w -i ./[your ico].ico [your programme].py\r 这里新增的-i就是给程序添加图标的命令，我们需要在该命令后添加图标的路径，这个路径可以是相对路径，也可以是绝对路径.\n打包成功后，我们就可以在dist文件夹中看到加上了自定义图标的可执行文件： **注：**图标文件已经被打包进去，所以我们可以删掉，不会有关系。\n提示：\n 不能通过修改后缀名来获得一个ico文件，这样导致出现错误 图标不出现，也有可能是由于缓存的问题。其实打包成功了，但在dist文件夹中还没有显示。读者只需要把生成的可执行文件拖到其他文件夹中就会发现图标显示正常了。  ","id":27,"section":"posts","summary":"PyInstaller原理 PyInstaller其实就是把Python解释器和脚本打包成一个可执行文件，和编译成真正的机器码完全是两回事。所","tags":null,"title":"打包Python程序","uri":"https://zhihao2020.github.io/2020/04/%E6%89%93%E5%8C%85python%E7%A8%8B%E5%BA%8F/","year":"2020"},{"content":"提交给Google网站站长 打开 Google网站站长，点击 “SEARCH CONSOLE ” 进入，然后添加资源。\n会要求下载一个html文件如google571325××××.html做验证，将这个文件保存到hugo站点根目录下的static子目录，更新站点内容让google search console可以访问到进行验证即可。\n进入资源页面，点”索引”下的”站点地图”，在”添加新的站点地图”处输入当前hugo站点的sitemap，这个文件hugo会默认生成，就在根路径下，如https://zhihao2020.github.io/sitemap.xml。\n百度搜索优化 打开 百度搜索资源平台 ，点击 链接提交，然后点”添加站点”。同样可以用文件验证的方式来进行网站验证。\n进入”数据引入”下的”链接提交”，再点 “自动提交” 下的 “sitemap”，在这里可以提交hugo网站的sitemap文件。\n注意百度不容许以子目录的方式提交子站点，和google不一样，只能在提交sitemap文件时，提交多个sitemap文件。这样也能勉强让百度收录。\n参考资料# 有参考以下资料，特此鸣谢：\n 搜索引擎优化（SEO）: 来自宋静超的hugo handbook Front-End-Checklist - Github SEO 查询 - 站长之家 SEO Meta Tags Meta Description 从Hexo迁移到Hugo-送漂亮的Hugo Theme主题 Hugo website SEO Hugo SEO Markup 搜索引擎优化  ","id":28,"section":"posts","summary":"提交给Google网站站长 打开 Google网站站长，点击 “SEARCH CONSOLE ” 进入，然后添加资源。 会要求下载一个html文件如google571","tags":null,"title":"让Google和百度搜索到你的Hugo博客","uri":"https://zhihao2020.github.io/2020/04/%E8%AE%A9google%E5%92%8C%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%88%B0%E4%BD%A0%E7%9A%84hugo%E5%8D%9A%E5%AE%A2/","year":"2020"},{"content":"调用 关于 __call__ 方法，不得不先提到一个概念，就是可调用对象（callable），我们平时自定义的函数、内置函数和类都属于可调用对象，但凡是可以把一对括号()应用到某个对象身上都可称之为可调用对象，判断对象是否为可调用对象可以用函数 __call__有无。\n如果在类中实现了 __call__ 方法，那么实例化对象也将成为一个可调用对象，\n __call__(self, [args\u0026hellip;])\n __call __ 在那些类的实例经常改变状态的时候会非常有效。调用这个实例是一种改变这个对象状态的直接和优雅的做法。用一个实例来表达最好不过了:\nclass Entity:\r'''调用实体来改变实体的位置。'''\rdef __init__(self, size, x, y):\rself.x, self.y = x, y\rself.size = size\rdef __call__(self, x, y):\r'''改变实体的位置'''\rself.x, self.y = x, y\re = Entity(1, 2, 3) // 创建实例\re(4, 5) //实例可以象函数那样执行，并传入x y值，修改对象的x y\r __call__其他作用 实例对象也可以像函数一样作为可调用对象来用，那么，这个特点在什么场景用得上呢？\n这个要结合类的特性来说，类可以记录数据（属性），而函数不行（闭包某种意义上也可行），利用这种特性可以实现基于类的装饰器，在类里面记录状态，比如，下面这个例子用于记录函数被调用的次数：\nclass Counter:\rdef __init__(self, func):\rself.func = func\rself.count = 0\rdef __call__(self, *args, **kwargs):\rself.count += 1\rreturn self.func(*args, **kwargs)\r@Counter\rdef foo():\rpass\rfor i in range(10):\rfoo()\rprint(foo.count) # 10\r ","id":29,"section":"posts","summary":"调用 关于 __call__ 方法，不得不先提到一个概念，就是可调用对象（callable），我们平时自定义的函数、内置函数和类都属于可调用对象，但凡是可以把一","tags":["Python魔法方法"],"title":"Python中的__call__方法","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84__call__/","year":"2020"},{"content":" 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法\n __new__的作用 在Python中__new__方法与__init__方法类似，但是如果两个都存在那么__new__会先执行。\n在基础类object中，__new__被定义成了一个静态方法，并且需要传递一个参数cls。Cls表示需要实例化的类，此参数在实例化时由Python解析器自动提供。\nnew()是在新式类中新出现的方法，它作用在构造方法init()建造实例之前，可以这么理解，在Python 中存在于类里面的构造方法init()负责将类的实例化，而在init()调用之前，new()决定是否要使用该init()方法，因为new()可以调用其他类的构造方法或者直接返回别的对象来作为本类 的实例。\nnew()方法的特性 new()方法是在类准备将自身实例化时调用。\nnew()方法始终都是类的静态方法，即使没有被加上静态方法装饰器。\n实例 class Person(object):\rdef __new__(cls, name, age):\rif 0 \u0026lt; age \u0026lt; 150:\rreturn object.__new__(cls)\r# return super(Person, cls).__new__(cls)\relse:\rreturn None\rdef __init__(self, name, age):\rself.name = name\rself.age = age\rdef __str__(self):\rreturn '{0}({1})'.format(self.__class__.__name__, self.__dict__)\rprint(Person('Tom', 10))\rprint(Person('Mike', 200))\r 输出：\nPerson({'age': 10, 'name': 'Tom'})\rNone\r ","id":30,"section":"posts","summary":"在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 __new__的作用 在Python中__new_","tags":["Python魔法方法"],"title":"Python中的__new__方法","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84__new__/","year":"2020"},{"content":" 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法\n class Cat:\rdef __init__(self, new_name, new_age):\r\u0026quot;\u0026quot;\u0026quot;在创建完对象之后 会自动调用, 它完成对象的初始化的功能\u0026quot;\u0026quot;\u0026quot;\rself.name = new_name\rself.age = new_age def __str__(self):\r\u0026quot;\u0026quot;\u0026quot;返回一个对象的描述信息\u0026quot;\u0026quot;\u0026quot;\rreturn \u0026quot;名字是:%s , 年龄是:%d\u0026quot; % (self.name, self.age)\rdef eat(self):\rprint(\u0026quot;%s在吃鱼....\u0026quot; % self.name)\rdef drink(self):\rprint(\u0026quot;%s在喝可乐...\u0026quot; % self.name)\r# 创建了一个对象\rtom = Cat(\u0026quot;汤姆\u0026quot;, 30)\rprint(tom)\rprint(tom.eat())\rprint(tom.drink())\r 输出\n名字是:汤姆 , 年龄是:30\r汤姆在吃鱼....\rNone\r汤姆在喝可乐...\rNone\r ","id":31,"section":"posts","summary":"在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 class Cat: def __init__(self, new_name, new_age): \u0026quot;\u0026quot;\u0026quot;","tags":["Python魔法方法"],"title":"Python中的__str__方法","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84__str__/","year":"2020"},{"content":"@classmethod 返回函数的类方法\nclassmethod修饰符对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的cls参数，可以调用类的属性，类的方法，实例化对象等。\n实例 class test(object):\rbar = 1\rdef func1(self): print ('AAA') @classmethod\rdef func2(cls):\rprint ('func2')\rprint (cls.bar)\rcls().func1() test.func2() # 不需要实例化\r 输出：\nfunc2\r1\rAAA\r @staticmethod 返回函数的静态方法\nclass test(object):\r@staticmethod\rdef fun():\rprint('hello');\rtest.fun() # 静态方法无需实例化\robj = test()\robj.fun() # 也可以实例化后调用\r 输出：\nhello\rhello\r ","id":32,"section":"posts","summary":"@classmethod 返回函数的类方法 classmethod修饰符对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的cls参数，可以调用","tags":["Python内建函数"],"title":"Python中的staticmethod和classmethod","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84staticmethod%E5%92%8Cclassmethod/","year":"2020"},{"content":"介绍 **super()**函数是用于条用父类（超类)的一个方法。\nsuper 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用等种种问题。\nspuer()的使用案例 class Parent(object):\rdef __init__(self):\rself.parent = 'I\\'m the parent.'\rprint('Parent')\rdef bar(self, message):\rprint(\u0026quot;%s from Parent\u0026quot; % message)\rclass Child(Parent):#单继承\rdef __init__(self):\r# super(Child,self) 首先找到 Child 的父类（就是类 Parent），然后把Parent中的东西继承过来了。\rsuper(Child, self).__init__()\rprint('Child')\rdef bar(self, message):\rself.bar(message)\rprint('Child bar fuction')\rprint(self.parent)\rif __name__ == '__main__':\rfooChild = Child()\rfooChild.bar('HelloWorld')\r Parent\rChild\rHelloWorld from Parent\rChild bar fuction\rI'm the parent.\r ","id":33,"section":"posts","summary":"介绍 **super()**函数是用于条用父类（超类)的一个方法。 super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，","tags":["Python内建函数"],"title":"Python中的super()函数","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84super%E5%87%BD%E6%95%B0/","year":"2020"},{"content":"函数也是对象 首先要明确一个概念，函数也是对象。\n于是，函数本身其实可以与其他的数据类型一样，作为其他函数的参数或者返回值。\ndef decorator(func):\rdef wrapper():\rprint(\u0026quot;we can do sth.Befor the func() is called...\u0026quot;)\rfunc()\rprint(\u0026quot;... and we can do sth. After it is called.. \u0026quot;)\rreturn wrapper()\rdef func()\rprint(\u0026quot;Hi, I'm func!\u0026quot;)\rfunc()\rdecorator(func)\r 输出如下：\nHi, I'm a_func!\rWe can do sth. before a func is called...\rHi, I'm a_func!\r... and we can do sth. after it is called...\r 但是，如果这样，那就不同了：\ndef decorator(func):\rdef wrapper():\rprint('We can do sth. before a func is called...')\rfunc()\rprint('... and we can do sth. after it is called...')\rreturn wrapper def func():\rprint(\u0026quot;Hi, I'm a_func!\u0026quot;)\rfunc()\rdecorator(func)\r Hi, I'm a_func!\r\u0026lt;function __main__.a_decorator.\u0026lt;locals\u0026gt;.wrapper()\u0026gt;\r 其实，这里 wrapper 是返回这个函数本身，而wrapper()则是返回这个函数的返回值。\n装饰器操作符 Python提供了一个针对函数的操作符@。\ndef decorator(func):\rdef wrapper():\rprint('We can do sth. before calling a_func...')\rfunc()\rprint('... and we can do sth. after it was called...')\rreturn wrapper\r@decorator\rdef func():\rprint(\u0026quot;Hi, I'm func!\u0026quot;)\rfunc()\r We can do sth. before calling a_func...\rHi, I'm a_func!\r... and we can do sth. after it was called...\r  注意：以上的代码中，decorator(func) 返回的是 wrapper 这个函数本身。而不是wrapper的返回值。\n 其中， 被 @ 调用的函数，叫做 “装饰器”（Decorator），比如，以上代码中的 decorator(func)。\n现在可以很简单直接地说清楚装饰器的作用了：\n@decorator\rdef func():\r...\r 等价于\ndef func():\r...\rfunc = decorator(func)\r 就是用 decorator 的调用结果替换掉原来的函数。decorator 返回值是什么，以后调用 func 时就是在调用这个返回值，而 decorator 本身此时已经执行完毕了。\n装饰器的用途 Decorator 最常用的场景是什么呢？最常用的场景就是用来改变其它函数的行为。\ndef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r The quick brown fox jumps over the lazy dog.\r def uppercase(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = original_result.upper()\rreturn modified_restult\rreturn wrapper\r@uppercase\rdef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\r 你还可以给一个函数加上一个以上的装饰器：\ndef uppercase(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = original_result.upper()\rreturn modified_restult\rreturn wrapper\rdef strong(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = '\u0026lt;strong\u0026gt;'+original_result+'\u0026lt;/strong\u0026gt;'\rreturn modified_restult\rreturn wrapper\r@uppercase\r@strong\rdef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r \u0026lt;STRONG\u0026gt;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\u0026lt;/STRONG\u0026gt;\r 你把两个装饰器的顺序调换一下写成下面这样试试：\n@uppercase\r@strong\rdef an_output():\r...\r 装饰器的执行顺序是 “自下而上” —— 其实是 “由里到外” 更为准确。体会一下。\n装饰带有参数的函数 到现在我们见到的使用装饰器的函数都是没有参数的：an_output 以及之前的 func。\n如果被装饰的函数有参数怎么办？装饰器自身内部又应该怎么写？\n这时候，Python 的 *args and **kwargs 的威力就显现出来了。\n装饰器函数本身这么写：\ndef decorator(func):\rdef wrapper(*args, **kwargs):\rreturn original_result\r# ... return wrapper\r 在这里，(*args, **kwargs) 非常强大，它可以匹配所有函数传进来的所有参数…… 准确地讲，*args 接收并处理所有传递进来的位置参数，**kwargs 接收并处理所有传递进来的关键字参数。\n假设我们有这么个函数：\ndef say_hi(greeting, name=None):\rreturn greeting + '! ' + name + '.'\rprint(say_hi('Hello', 'Jack'))\r Hello! Jack.\r 如果我们想在装饰器里对函数名、参数，都做些事情 —— 比如，我们写个 @trace 用来告诉用户调用一个函数的时候都发生了什么……\ndef trace(func):\rdef wrapper(*args, **kwargs):\rprint(f\u0026quot;Trace: You've called a function: {func.__name__}(),\u0026quot;,\rf\u0026quot;with args: {args}; kwargs: {kwargs}\u0026quot;)\roriginal_result = func(*args, **kwargs)\rprint(f\u0026quot;Trace: {func.__name__}{args} returned: {original_result}\u0026quot;)\rreturn original_result\rreturn wrapper\r@trace\rdef say_hi(greeting, name=None):\rreturn greeting + '! ' + name + '.'\rprint(say_hi('Hello', name = 'Jack'))\r Trace: You've called a function: say_hi(), with args: ('Hello',); kwargs: {'name': 'Jack'}\rTrace: say_hi('Hello',) returned: Hello! Jack.\rHello! Jack.\r ","id":34,"section":"posts","summary":"函数也是对象 首先要明确一个概念，函数也是对象。 于是，函数本身其实可以与其他的数据类型一样，作为其他函数的参数或者返回值。 def decorator(func): def wrapper(): print(\u0026quot;we can do sth.Befor the func()","tags":null,"title":"Python中的装饰器(1)","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A81/","year":"2020"},{"content":"函数也是对象 首先要明确一个概念，函数也是对象。\n于是，函数本身其实可以与其他的数据类型一样，作为其他函数的参数或者返回值。\ndef decorator(func):\rdef wrapper():\rprint(\u0026quot;we can do sth.Befor the func() is called...\u0026quot;)\rfunc()\rprint(\u0026quot;... and we can do sth. After it is called.. \u0026quot;)\rreturn wrapper()\rdef func()\rprint(\u0026quot;Hi, I'm func!\u0026quot;)\rfunc()\rdecorator(func)\r 输出如下：\nHi, I'm a_func!\rWe can do sth. before a func is called...\rHi, I'm a_func!\r... and we can do sth. after it is called...\r 但是，如果这样，那就不同了：\ndef decorator(func):\rdef wrapper():\rprint('We can do sth. before a func is called...')\rfunc()\rprint('... and we can do sth. after it is called...')\rreturn wrapper def func():\rprint(\u0026quot;Hi, I'm a_func!\u0026quot;)\rfunc()\rdecorator(func)\r Hi, I'm a_func!\r\u0026lt;function __main__.a_decorator.\u0026lt;locals\u0026gt;.wrapper()\u0026gt;\r 其实，这里 wrapper 是返回这个函数本身，而wrapper()则是返回这个函数的返回值。\n装饰器操作符 Python提供了一个针对函数的操作符@。\ndef decorator(func):\rdef wrapper():\rprint('We can do sth. before calling a_func...')\rfunc()\rprint('... and we can do sth. after it was called...')\rreturn wrapper\r@decorator\rdef func():\rprint(\u0026quot;Hi, I'm func!\u0026quot;)\rfunc()\r We can do sth. before calling a_func...\rHi, I'm a_func!\r... and we can do sth. after it was called...\r  注意：以上的代码中，decorator(func) 返回的是 wrapper 这个函数本身。而不是wrapper的返回值。\n 其中， 被 @ 调用的函数，叫做 “装饰器”（Decorator），比如，以上代码中的 decorator(func)。\n现在可以很简单直接地说清楚装饰器的作用了：\n@decorator\rdef func():\r...\r 等价于\ndef func():\r...\rfunc = decorator(func)\r 就是用 decorator 的调用结果替换掉原来的函数。decorator 返回值是什么，以后调用 func 时就是在调用这个返回值，而 decorator 本身此时已经执行完毕了。\n装饰器的用途 Decorator 最常用的场景是什么呢？最常用的场景就是用来改变其它函数的行为。\ndef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r The quick brown fox jumps over the lazy dog.\r def uppercase(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = original_result.upper()\rreturn modified_restult\rreturn wrapper\r@uppercase\rdef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\r 你还可以给一个函数加上一个以上的装饰器：\ndef uppercase(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = original_result.upper()\rreturn modified_restult\rreturn wrapper\rdef strong(func):\rdef wrapper():\roriginal_result = func()\rmodified_restult = '\u0026lt;strong\u0026gt;'+original_result+'\u0026lt;/strong\u0026gt;'\rreturn modified_restult\rreturn wrapper\r@uppercase\r@strong\rdef an_output():\rreturn 'The quick brown fox jumps over the lazy dog.'\rprint(an_output())\r \u0026lt;STRONG\u0026gt;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\u0026lt;/STRONG\u0026gt;\r 你把两个装饰器的顺序调换一下写成下面这样试试：\n@uppercase\r@strong\rdef an_output():\r...\r 装饰器的执行顺序是 “自下而上” —— 其实是 “由里到外” 更为准确。体会一下。\n装饰带有参数的函数 到现在我们见到的使用装饰器的函数都是没有参数的：an_output 以及之前的 func。\n如果被装饰的函数有参数怎么办？装饰器自身内部又应该怎么写？\n这时候，Python 的 *args and **kwargs 的威力就显现出来了。\n装饰器函数本身这么写：\ndef decorator(func):\rdef wrapper(*args, **kwargs):\rreturn original_result\r# ... return wrapper\r 在这里，(*args, **kwargs) 非常强大，它可以匹配所有函数传进来的所有参数…… 准确地讲，*args 接收并处理所有传递进来的位置参数，**kwargs 接收并处理所有传递进来的关键字参数。\n假设我们有这么个函数：\ndef say_hi(greeting, name=None):\rreturn greeting + '! ' + name + '.'\rprint(say_hi('Hello', 'Jack'))\r Hello! Jack.\r 如果我们想在装饰器里对函数名、参数，都做些事情 —— 比如，我们写个 @trace 用来告诉用户调用一个函数的时候都发生了什么……\ndef trace(func):\rdef wrapper(*args, **kwargs):\rprint(f\u0026quot;Trace: You've called a function: {func.__name__}(),\u0026quot;,\rf\u0026quot;with args: {args}; kwargs: {kwargs}\u0026quot;)\roriginal_result = func(*args, **kwargs)\rprint(f\u0026quot;Trace: {func.__name__}{args} returned: {original_result}\u0026quot;)\rreturn original_result\rreturn wrapper\r@trace\rdef say_hi(greeting, name=None):\rreturn greeting + '! ' + name + '.'\rprint(say_hi('Hello', name = 'Jack'))\r Trace: You've called a function: say_hi(), with args: ('Hello',); kwargs: {'name': 'Jack'}\rTrace: say_hi('Hello',) returned: Hello! Jack.\rHello! Jack.\r ","id":35,"section":"posts","summary":"函数也是对象 首先要明确一个概念，函数也是对象。 于是，函数本身其实可以与其他的数据类型一样，作为其他函数的参数或者返回值。 def decorator(func): def wrapper(): print(\u0026quot;we can do sth.Befor the func()","tags":null,"title":"Python中的装饰器(1)","uri":"https://zhihao2020.github.io/2020/04/python%E7%9A%84%E5%87%BD%E6%95%B0%E5%B7%A5%E5%85%B71/","year":"2020"},{"content":"配置文件： [numbers]\rpi: 3.1415926\r[messages]\rgreeting: welcome to the area calculation program!\rquestion: Please emter the radius\rresult_message: The area is\r 使用示例 from ConfigParser import ConfigParser\rCONFIGFILE = ‘XXX.ini'\rconfig = ConfigParser()\r#读取配置文件\rconfig.read(CONFIGFILE)\r#打印初始问候语\r#要查看的区段是’messages‘\rprint(config.get('messages','greeting'))\r#使用配置文件的一个问题读取半径：\rradius = input(config.get('messages','question')+' ')\r#打印配置文件中的结果信息\r#以逗号结束，以在同一行显示\rprint(config.get('messages','result_message'))\r#getfloat()将config值转换为float类型\rprint(config.getfloat('numbers','pi') * radius **2)\r 方法 写入:\nimport configparser\rconfig = configparser.ConfigParser()\rconfig['DEFAULT'] = {'ServerAliveInterval': '45',\r'Compression': 'yes',\r'CompressionLevel': '9'}\rconfig['bitbucket.org'] = {}\rconfig['bitbucket.org']['User'] = 'hg'\rconfig['topsecret.server.com'] = {}\rtopsecret = config['topsecret.server.com']\rtopsecret['Port'] = '50022' # mutates the parser\rtopsecret['ForwardX11'] = 'no' # same here\rconfig['DEFAULT']['ForwardX11'] = 'yes'\rwith open('example.ini', 'w') as configfile:\rconfig.write(configfile)\r 注意： 它不去猜测配置文件中值得数据类型，而是始终将他们内部存储为字符串。\n于是提供了getint()、getfloat和getboolean()方法。\n例如，gwtboolean()用于处理布尔值，此方法不区分大小写，并从并从'yes'/ 'no'，'on'/ 'off'， 'true'/ 'false'和'1'/ '0' 识别布尔值。\n","id":36,"section":"posts","summary":"配置文件： [numbers] pi: 3.1415926 [messages] greeting: welcome to the area calculation program! question: Please emter the radius result_message: The area is 使用示例 from ConfigParser import ConfigParser CONFIGFILE = ‘XXX.ini' config = ConfigParser() #读取配置文件 config.read(CONFIGFILE) #打印初始问候语 #要查看的区段","tags":["Python标准库"],"title":"Python的一种简单配置文件的方法","uri":"https://zhihao2020.github.io/2020/04/python%E7%9A%84%E4%B8%80%E7%A7%8D%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/","year":"2020"},{"content":"面向对象的三大基本特性，五大基本原则 透切理解面向对象三大基本特性是理解面向对象五大基本原则的基础.\n三大特性是：封装,继承,多态 封装 封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n继承 面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”。 被继承的类称为“基类”、“父类”或“超类”。 继承的过程，就是从一般到特殊的过程。 要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。 在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。\n继承概念的实现方式有三类：实现继承、接口继承和可视继承。\n  实现继承是指使用基类的属性和方法而无需额外编码的能力.\n  接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；\n  可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力\n  多态 一种事物的多种体现形式，函数的重写其实就是多态的一种体现\n在Python中，多态指的是父类的引用指向子类的对象\n那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。\n五大基本原则 单一职责原则SRP(Single Responsibility Principle) 是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。\n开放封闭原则OCP(Open－Close Principle) 一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能， 那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。\n替换原则(the Liskov Substitution Principle LSP) 子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工， 也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。\n依赖原则(the Dependency Inversion Principle DIP) 具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能， 这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到 了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。\n接口分离原则(the Interface Segregation Principle ISP) 模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来\n","id":37,"section":"posts","summary":"面向对象的三大基本特性，五大基本原则 透切理解面向对象三大基本特性是理解面向对象五大基本原则的基础. 三大特性是：封装,继承,多态 封装 封装最好理","tags":null,"title":"面向对象的三大特性和五大原则","uri":"https://zhihao2020.github.io/2020/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%92%8C%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99/","year":"2020"},{"content":"JupyterLab 有两种键盘输入模式，分别为编辑模式和命令模式。\n一、命令行模式 (按键 Esc 开启) 命令行模式：键盘输入运行程序命令；这时的单元框线是灰色。\n   快捷键 实现的功能 快捷键 实现的功能     Enter 转入编辑模式 V 粘贴到下方单元   Shift + Enter 运行本单元，选中下个单元 Z 恢复删除的最后一个单元   Ctrl + Enter 运行本单元 连按两下D 删除选中的单元   Alt + Enter 运行本单元，在其下插入新单元 Shift + M 合并选中的单元   Y 单元转入代码状态 Ctrl + S 文件存盘   M 单元转入markdown状态 S 文件存盘   R 单元转入raw状态 L 转换行号   1 设定 1 级标题 O 转换输出   2 设定 2 级标题 Shift + O 转换输出滚动   3 设定 3 级标题 Esc 关闭页面   4 设定 4 级标题 Q 关闭页面   5 设定 5 级标题 H 显示快捷键帮助   6 设定 6 级标题 I,I 中断Notebook内核   Up 选中上方单元 连按两下数字0 重启Notebook内核   Down 选中下方单元 Shift 忽略   K 选中上方单元 Shift + Space 向上滚动   J 选中下方单元 Space 向下滚动   Shift + K 扩大选中上方单元 Shift + J 扩大选中下方单元   A 在上方插入新单元 B 在下方插入新单元   X 剪切选中的单元 C 复制选中的单元   Shift + V 粘贴到上方单元      二、编辑模式 ( Enter 键启动) 编辑模式：允许你往单元中键入代码或文本；这时的单元框线是绿色的。\n   快捷键 实现的功能 快捷键 实现的功能     Tab 代码补全或缩进 Shift + Tab 提示   Ctrl + ] 缩进 Ctrl + [ 解除缩进   Ctrl + A 全选 Ctrl + Z 复原   Ctrl + Shift + Z 再做 Ctrl + Y 再做   Ctrl + Home 跳到单元开头 Ctrl + End 跳到单元末尾   Ctrl + Up 跳到单元开头 Ctrl + Down 跳到单元末尾   Ctrl + Left 跳到左边一个字首 Ctrl + Right 跳到右边一个字首   Ctrl + Backspace 删除前面一个字 Esc 进入命令模式   Ctrl + Delete 删除后面一个字 Shift + Enter 运行本单元，选中下一单元   Ctrl + M 进入命令模式 Ctrl + Enter 运行本单元   Alt + Enter 运行本单元，在下面插入一单元 Ctrl + Shift + + 分割单元   Ctrl + S 文件存盘 Ctrl + Shift + Subtract 分割单元   Up 光标上移或转入上一单元 Down 光标下移或转入下一单元   Shift 忽略      ","id":38,"section":"posts","summary":"JupyterLab 有两种键盘输入模式，分别为编辑模式和命令模式。 一、命令行模式 (按键 Esc 开启) 命令行模式：键盘输入运行程序命令；这时的单元框线是灰色。 快捷键 实","tags":["JupyterLab"],"title":"JupyterLab快捷键","uri":"https://zhihao2020.github.io/2020/04/jupyterlab%E5%BF%AB%E6%8D%B7%E9%94%AE/","year":"2020"},{"content":"测试驱动是先写测试代码，然后写功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码\nunittest最早由JUnit启发而来。它支持自动化测试，分享结构，关闭测试代码，将测试聚合到集合中，并使测试独立于报告框架。\n为了实现这些功能，unittest以面向对象的方式提供了一些重要的概念：\n test fixture(测试固件)  测试装置表示执行一个或多个测试所需的准备工作，以及任何相关的清理操作。例如，这可能涉及创建临时或代理数据库、目录或启动服务器进程。\n test case（测试案例）  测试用例是测试的单个单元。它检查对特定输入集的特定响应。unittest提供了一个基类TestCase，它可以用来创建新的测试用例。\n test suite（测试套件）  测试套件是测试用例、测试套件或两者的集合。它用于聚合(aggregate)应该一起执行的测试。\n test runner（测试运行器）  测试运行器是一个组件，它编排测试的执行并向用户提供结果。运行程序可以使用图形界面、文本界面或返回一个特殊值来指示执行测试的结果。\n基本实例 unittest模块提供了构造和运行测试丰富组件。\nimport unittest\rclass TestStringMethods(unittest.TestCase):\rdef test_upper(self):\rself.assertEqual('foo'.upper(), 'FOO')\rdef test_isupper(self):\rself.assertTrue('FOO'.isupper())\rself.assertFalse('Foo'.isupper())\rdef test_split(self):\rs = 'hello world'\rself.assertEqual(s.split(), ['hello', 'world'])\r# check that s.split fails when the separator is not a string\rwith self.assertRaises(TypeError):\rs.split(2)\rif __name__ == '__main__':\runittest.main()\r testcase是通过子类化unittest.TestCase来创建的。这三个单独的测试是用名称以字母test开头的方法定义的。这个命名约定通知测试运行程序哪些方法表示测试。\n每个测试的关键是调用assertEqual()来检查期望的结果；assertTrue()或assertFalse()来验证条件；或assertRaises来验证是否引发了特定的异常。这些方法替代了assert语句，因此这些测试接货可以最终生成报告。\nsetUp()和tearDown()方法允许你定义能在测试方法之前和之后执行的指令。\n最后的代码是运行这个测试的简单方法。unittest.main()t提供了测试脚本的命令行接口。当从命令行运行时，上面的脚本生成如下的输出：\n...\r------------------------------------------------------------\rRan 3 tests in 0.000s\rOK\r 将-v传输到你的测试代码将使unittest.main()开始更高级的说明。比如像下面：\ntest_isupper (__main__.TestStringMethods) ... ok\rtest_split (__main__.TestStringMethods) ... ok\rtest_upper (__main__.TestStringMethods) ... ok\r----------------------------------------------------------------------\rRan 3 tests in 0.001s\rOK\r 上面的例子展示了最常用的unittest特性，这些特性足以满足许多日常的测试需求。文档的其余部分将探索来自first principles的完整特性集。\n命令行界面 可以从命令行使用unittest模块\n比如\npython -m unittest test_module1 test_module2\rpython -m unittest test_module.TestClass\rpython -m unittest test_module.TestClass.test_method\r 测试模块也可以通过文件路径指定：\npython -m unittest tests/test_something.py\r 这使您可以使用Shell文件名补全来指定测试模块。指定的文件必须仍然可以作为模块导入。通过删除“ .py”并将路径分隔符转换为“。”，可将该路径转换为模块名称。如果要执行不可作为模块导入的测试文件，则应直接执行该文件。\n您可以通过传递-v标志来更详细（更详细）地运行测试：\npython -m unittest -v test_module\r 在不带参数的情况下执行时，将启动“ 测试发现”：\npython -m unittest\r 有关所有命令行选项的列表：\npython -m unittest -h\r 组织测试代码 单元测试的基本构建模块是测试用例 —必须设置单个场景并检查其正确性。在中unittest，测试用例由unittest.TestCase实例表示。要制作自己的测试用例，必须编写TestCase或的子类 FunctionTestCase。\nTestCase实例的测试代码应完全独立，以使它可以隔离运行，也可以与任意数量的其他测试用例任意组合运行。\n最简单的TestCase子类将简单地实现一个测试方法（即名称以开头的方法test），以执行特定的测试代码：\nimport unittest\rclass DefaultWidgetSizeTestCase(unittest.TestCase):\rdef test_default_widget_size(self):\rwidget = Widget('The widget')\rself.assertEqual(widget.size(), (50, 50))\r 请注意，为了测试某些内容，我们使用assert*() ,他TestCase基类提供的方法之一。如果测试失败，则会引发异常，并带有一条解释性消息，并将unittest 测试用例标识为失败。其他任何异常都将被视为错误。\n测试可能很多，并且它们的设置可能是重复的。幸运的是，我们可以通过实现称为的方法来分解设置代码，setUp()测试框架将针对我们运行的每个测试自动调用该方法 ：\nimport unittest\rclass WidgetTestCase(unittest.TestCase):\rdef setUp(self):\rself.widget = Widget('The widget')\rdef test_default_widget_size(self):\rself.assertEqual(self.widget.size(), (50,50),\r'incorrect default size')\rdef test_widget_resize(self):\rself.widget.resize(100,150)\rself.assertEqual(self.widget.size(), (100,150),\r'wrong size after resize')\r 注意:通过根据字符串的内置顺序对测试方法名称进行排序，可以确定各种测试的运行顺序。\n如果在setUp()测试运行时该方法引发异常，则框架将认为该测试已发生错误，并且该测试方法将不会执行。\n同样，我们可以提供一种tearDown()在测试方法运行后进行整理的方法：\nimport unittest\rclass WidgetTestCase(unittest.TestCase):\rdef setUp(self):\rself.widget = Widget('The widget')\rdef tearDown(self):\rself.widget.dispose()\r 如果setUp()成功，tearDown()将运行测试方法是否成功。\n这种用于测试代码的工作环境称为 测试夹具。创建一个新的TestCase实例作为用于执行每种单独的测试方法的唯一测试夹具。因此 setUp()，tearDown()和__init__() 将在每个测试中被调用一次。\n建议使用TestCase实现将测试根据其测试的功能分组在一起。 unittest为此提供了一种机制：test suite（测试套件)，由unittest的 TestSuite类表示。在大多数情况下，调用unittest.main()将做正确的事情，并为您收集所有模块的测试用例并执行它们。\n但是，如果您想自定义测试套件的构建，则可以自己进行：\ndef suite():\rsuite = unittest.TestSuite()\rsuite.addTest(WidgetTestCase('test_default_widget_size'))\rsuite.addTest(WidgetTestCase('test_widget_resize'))\rreturn suite\rif __name__ == '__main__':\rrunner = unittest.TextTestRunner()\rrunner.run(suite())\r 您可以将测试用例和测试套件的定义与它们要测试的代码放在相同的模块中（例如widget.py），但是将测试代码放在单独的模块中有许多优点，例如 test_widget.py：\n 可以从命令行独立运行测试模块。 测试代码可以更容易地与出厂代码分开。 在没有充分理由的情况下，很少有更改测试代码以使其适合测试代码的诱惑。 测试代码的修改频率应低于其测试的代码。 经过测试的代码可以更容易地重构。 如果测试策略发生变化，则无需更改源代码。  ","id":39,"section":"posts","summary":"测试驱动是先写测试代码，然后写功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码 unittest最早由JUnit启发","tags":["Python标准库"],"title":"Python的Unittest模块","uri":"https://zhihao2020.github.io/2020/04/python%E7%9A%84unittest%E6%A8%A1%E5%9D%97/","year":"2020"},{"content":"argparse可以让人编写对用户友好的命令行接口。程序定义好它需要的参数，然后argparse将从sys.argv解析出那些参数。\nargparse还会自动生成帮助和使用手册，并在用户给程序传入无效参数时报出错误信息。\n概念 创建一个解析器 parser = argparse.ArgumentParser(description='Process some integers.')\r 添加参数 添加参数是通过调用add_argument()方法完成的\npaser.add_argument('integers', metavar='N', type=int, nargs='+',help='an integer for the accumulator')\rparser.add_argument('--sum',dest='accumulate',action='store_const',const=sum,default=max,help='max,help='sum the integers (default: find the max)')\r 稍后，调用 parse_args() 将返回一个具有 integers 和 accumulate 两个属性的对象。integers 属性将是一个包含一个或多个整数的列表，而 accumulate 属性当命令行中指定了 --sum 参数时将是 sum() 函数，否则则是 max() 函数。\n解析参数 ArgumentParser 通过 parse_args() 方法解析参数。它将检查命令行，把每个参数转换为适当的类型然后调用相应的操作。在大多数情况下，这意味着一个简单的 Namespace 对象将从命令行参数中解析出的属性构建：\nparser.parse_args(['--sum', '7', '-1', '42'])\r 在脚本中，通常parse_args()会不带参数调用，而ArgumentParser将自动从sysy.argv中确定命令行参数。\n基本方法 基础 import argparse\rparser = argparse.AgumentParser()\rparser.parse_args()\r 位置参数 位置参数之所以这样命名，是因为程序应该如何处理该参数，完全取决于1它在命令行中的参数。\nimport argparse\rparser = argprase.ArgumentParser()\rparser.add_argument(\u0026quot;square\u0026quot;,help=\u0026quot;display a square of a given number\u0026quot;,type=int)\rargs = parser.parser_args()\rprint(args.square**2)\r  首先我们引入parser对象 我们增加了add_argument()方法，该方法用于指定程序能够接受哪些命令行选项。 The parse_args() method actually returns some data from the options specified, in this case, square.  注意，这里有type=int，这个是告诉argparse来吧输入当做整数，不然他就会把它当做字符串。\n可选参数 import argparse\rparser = argparse.ArgumentParser()\rparser.add_argument(\u0026quot;--verbose\u0026quot;, help=\u0026quot;increase output verbosity\u0026quot;,\raction=\u0026quot;store_true\u0026quot;)\rargs = parser.parse_args()\rif args.verbose:\rprint(\u0026quot;verbosity turned on\u0026quot;)\r 这里action赋值为\u0026quot;store_true\u0026quot;。这意味着，当一个选项存在时，为args.verbose赋值为True。没有指定时，啧隐含地赋值为False。\n短选项 parser.add_argument(\u0026quot;-v\u0026quot;, \u0026quot;--verbose\u0026quot;, help=\u0026quot;increase output verbosity\u0026quot;,\raction=\u0026quot;store_true\u0026quot;)\r ","id":40,"section":"posts","summary":"argparse可以让人编写对用户友好的命令行接口。程序定义好它需要的参数，然后argparse将从sys.argv解析出那些参数。 argp","tags":["Python标准库"],"title":"Python 参数解析 Parser 的使用方法","uri":"https://zhihao2020.github.io/2020/04/python-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90-parser-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","year":"2020"},{"content":"sys.argv 传递给Python脚本的命令行参数列表。\n例如\nimport sys\rprint(sys.argv[0])\rprint(sys.argv[1])\r 运行它：\npython temp.py argv1\rsys.py\rargv1\r sys.exit([arg]) 功能：执行到主程序末尾，解释器自动退出，但是如果需要中途退出程序，可以调用sys.exit函数，带有一个可选的整数参数返回给调用它的程序，表示你可以在主程序中捕获对sys.exit的调用。（0是正常退出，其他为异常）\nsys.getdefaultencoding() 获取系统当前编码，一般默认为ascii。\nsys.path 功能：获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。\n当然你可以通过这样修改\nsys.path.append(\u0026quot;自定义模块路径\u0026quot;)\r sys.platform 获取当前系统平台。\nsys.stdin,sys.stdout,sys.stderr 功能：stdin , stdout , 以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们\n——未完之后，会不断补充——\n","id":41,"section":"posts","summary":"sys.argv 传递给Python脚本的命令行参数列表。 例如 import sys print(sys.argv[0]) print(sys.argv[1]) 运行它： python temp.py argv1 sys.py argv1 sys.exit([arg]) 功能：执行到主程序末尾，解释器自动退出，但是如果需要中途退出程序，","tags":["Python标准库"],"title":"Python中的sys","uri":"https://zhihao2020.github.io/2020/04/python%E4%B8%AD%E7%9A%84sys/","year":"2020"},{"content":"放置\nck = QCheckBox()\rnewItem = XX.setCellWidget(1,0,ck)\r 检查是否被选\nlines = []\rsum = 0\ri = 0\rif (i \u0026lt; self.name.rowCount()):\rlines.append([self.tableWidget.cellWidget(i, 0), self.tableWidget.item(i, 1), self.tableWidget.item(i, 2),\rself.tableWidget.cellWidget(i, 5)])\ri += 1\rfor line in lines:\rif line[0].checkState()==Qt.Checked:\rpass\r ","id":42,"section":"posts","summary":"放置 ck = QCheckBox() newItem = XX.setCellWidget(1,0,ck) 检查是否被选 lines = [] sum = 0 i = 0 if (i \u0026lt; self.name.rowCount()): lines.append([self.tableWidget.cellWidget(i, 0), self.tableWidget.item(i, 1), self.tableWidget.item(i, 2), self.tableWidget.cellWidget(i, 5)]) i += 1 for line in lines: if line[0].checkState()==Qt.Checked: pass","tags":["PyQt5"],"title":"在单元格里放置复选框","uri":"https://zhihao2020.github.io/2020/04/%E5%9C%A8%E5%8D%95%E5%85%83%E6%A0%BC%E9%87%8C%E6%94%BE%E7%BD%AE%E5%A4%8D%E9%80%89%E6%A1%86/","year":"2020"},{"content":"这个项目会创建一个N×N的细胞网格，随时间推移，模拟Conway生命游戏。\n在这个游戏中，细胞处于ON或OFF状态。游戏从一个初始状态开始，每个细胞分配一个状态，刷滕州而决定如何随时间而改变。\n这个游戏规则很简单，但是它表明，复杂的结构可以根据简单的规则演进，不必遵循任何一个预设的模式。\n工作原理 Conway生命游戏有4个规则：\n 1、如果一个细胞为ON，邻居中少于两个为ON，他变为OFF。 2、如果一个细胞为ON，邻居中有两个或3个为ON，他保持为ON。 3、如果一个细胞为ON，邻居超过三个为ON，他变为OFF。 4、如果一个细胞为OFF，邻居中恰好有三个为ON，他变为ON.  对于边界采用环形边界条件\n表示网格 表示网格上的细胞死活，采用255和0作为ON和OFF的数值。我们将采用matplotlib的imshow()方法，来显示网格当前的状态，将一个数字矩阵表示为一张图像。\n例如：\nx = np.array([[0,0,255],[255,255,0],[0,255,0]])\rplt.imshow(x,interpolation='nearest')\rplt.show\r 初始条件 开始模拟，先为二维网格的每个细胞初始状态。可以使用随机分布，或者特定的图案。\n这里我使用了随机分布。\n例如：\nnp.random.choice([0,255],4*4,p=[0.1,0.9]).reshape(4,4)\r 下面为输出：\narray([[255, 255, 255, 255],\r[255, 255, 0, 255],\r[0, 255, 255, 255],\r[255, 255, 255, 0]])\r 边界条件 这里除了边缘其他位置都好处理，因为边缘采用了环形边界。\n这里我使用了取模。\nright = gird[i][(j+1)%N]\rleft = grid[i][(j-1)%N]\rtop = grid[(i-1)%N][j]\rdown = grid[(i+1)%N][j]\r 实现规则 生命游戏的规则基于相邻细胞的ON或OFF数目。为了简化这些规则的应用，可以计算出处于ON状态的相邻细胞总数。因为ON状态的值为255，所以可以对所有相邻细胞的值求和，再除以255，来获得ON细胞的数量。下面是相关的代码：\nif grid[i,j] == ON:\rif (total \u0026lt; 2) or (total \u0026gt;3 ):\rnewGrid[i,j] = OFF\relse:\rif total == 3:\rnewGrid[i,j] = ON\r 初始化模拟 # set grid size\rN = 100\rif args.N and int(args.N) \u0026gt; 8:\rN = int(args.N)\r# set animation update interval\rupdateInterval = 50\rif args.interval:\rupdateInterval = int(args.interval)\r# populate grid with random on/off - more off than on\rgrid = randomGrid(N)\r 设置动画，\nfig,ax = plt.subplots()\rimg = ax.imshow(grid,interpolation = 'nearest')\rani = animation.FuncAnimation(fig,update,fargs=\t(img.grid,N,),frames=10,interval=updateInterval,save_count=50)\rif args.movfile:\rani.save(args.movfile, fps=30, extra_args=['-vcodec', 'libx264'])\rplt.show()\r 最后的结果：\n完整代码：\nimport sys, argparse\rimport numpy as np\rimport matplotlib.pyplot as plt\rimport matplotlib.animation as animation\rON = 255\rOFF = 0\rvals = [ON, OFF]\rdef randomGrid(N):\r\u0026quot;\u0026quot;\u0026quot;returns a grid of NxN random values\u0026quot;\u0026quot;\u0026quot;\rreturn np.random.choice(vals, N * N, p=[0.2, 0.8]).reshape(N, N)\rdef update(frameNum, img, grid, N):\r# copy grid since we require 8 neighbors for calculation\r# and we go line by line\rnewGrid = grid.copy()\rfor i in range(N):\rfor j in range(N):\r# compute 8-neghbor sum\r# using toroidal boundary conditions - x and y wrap around\r# so that the simulaton takes place on a toroidal surface.\rtotal = int((grid[i, (j - 1) % N] + grid[i, (j + 1) % N] +\rgrid[(i - 1) % N, j] + grid[(i + 1) % N, j] +\rgrid[(i - 1) % N, (j - 1) % N] + grid[(i - 1) % N, (j + 1) % N] +\rgrid[(i + 1) % N, (j - 1) % N] + grid[(i + 1) % N, (j + 1) % N]) / 255)\r# apply Conway's rules\rif grid[i, j] == ON:\rif (total \u0026lt; 2) or (total \u0026gt; 3):\rnewGrid[i, j] = OFF\relse:\rif total == 3:\rnewGrid[i, j] = ON\r# update data\rimg.set_data(newGrid)\rgrid[:] = newGrid[:]\rreturn img,\r# main() function\rdef main():\r# Command line args are in sys.argv[1], sys.argv[2] ..\r# sys.argv[0] is the script name itself and can be ignored\r# parse arguments\rparser = argparse.ArgumentParser(description=\u0026quot;Runs Conway's Game of Life simulation.\u0026quot;)\r# add arguments\rparser.add_argument('--grid-size', dest='N', required=False)\rparser.add_argument('--mov-file', dest='movfile', required=False)\rparser.add_argument('--interval', dest='interval', required=False)\rargs = parser.parse_args()\r# set grid size\rN = 100\rif args.N and int(args.N) \u0026gt; 8:\rN = int(args.N)\r# set animation update interval\rupdateInterval = 50\rif args.interval:\rupdateInterval = int(args.interval)\r# declare grid\rgrid = np.array([])\r# populate grid with random on/off - more off than on\rgrid = randomGrid(N)\r# set up animation\rfig, ax = plt.subplots()\rimg = ax.imshow(grid, interpolation='nearest')\rani = animation.FuncAnimation(fig, update, fargs=(img, grid, N,),\rframes=10,\rinterval=updateInterval,\rsave_count=50)\rif args.movfile:\rani.save(args.movfile, fps=30, extra_args=['-vcodec', 'libx264'])\rplt.show()\r# call main\rif __name__ == '__main__':\rmain()\r ","id":43,"section":"posts","summary":"这个项目会创建一个N×N的细胞网格，随时间推移，模拟Conway生命游戏。 在这个游戏中，细胞处于ON或OFF状态。游戏从一个初始状态开始，每","tags":null,"title":"用Python模拟生命","uri":"https://zhihao2020.github.io/2020/04/python%E6%A8%A1%E6%8B%9F%E7%94%9F%E5%91%BD/","year":"2020"},{"content":"#!/usr/bin/env python3\r\u0026quot;\u0026quot;\u0026quot;\rA Python version of the classic \u0026quot;bottles of beer on the wall\u0026quot; programming\rexample.\rBy Guido van Rossum, demystified after a version by Fredrik Lundh.\r\u0026quot;\u0026quot;\u0026quot;\rimport sys\rn = 100\rif sys.argv[1:]:\rn = int(sys.argv[1])\rdef bottle(n):\rif n == 0: return \u0026quot;no more bottles of beer\u0026quot;\rif n == 1: return \u0026quot;one bottle of beer\u0026quot;\rreturn str(n) + \u0026quot; bottles of beer\u0026quot;\rfor i in range(n, 0, -1):\rprint(bottle(i), \u0026quot;on the wall,\u0026quot;)\rprint(bottle(i) + \u0026quot;.\u0026quot;)\rprint(\u0026quot;Take one down, pass it around,\u0026quot;)\rprint(bottle(i-1), \u0026quot;on the wall.\u0026quot;)\r 这里值得学习：\nn = 100\rif sys.argv[1:]:\rn = int(sys.argv[1])\r 这样保证了n有默认值，用户也可以自己修改。\n今天这个真水，就算一个平缓的起步吧~\n","id":44,"section":"posts","summary":"#!/usr/bin/env python3 \u0026quot;\u0026quot;\u0026quot; A Python version of the classic \u0026quot;bottles of beer on the wall\u0026quot; programming example. By Guido van Rossum, demystified after a version by Fredrik Lundh. \u0026quot;\u0026quot;\u0026quot; import sys n = 100 if sys.argv[1:]: n = int(sys.argv[1]) def bottle(n): if n == 0: return \u0026quot;no more bottles of beer\u0026quot; if n == 1: return \u0026quot;one bottle of beer\u0026quot; return str(n) + \u0026quot; bottles of beer\u0026quot; for i in","tags":["Python代码学习"],"title":"精读代码(1)","uri":"https://zhihao2020.github.io/2020/04/%E7%B2%BE%E8%AF%BB%E4%BB%A3%E7%A0%811/","year":"2020"},{"content":"配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit）更改。配置Git来忽略制定文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。\n获取Git仓库 有两种获取Git项目仓库的方式。第一种是将已有项目或目录导入为Git仓库；第二种是从其他服务器克隆一个已存在的Git仓库。\n在已存在目录中初始化仓库 如果你打算使用Git来对已有项目进行跟踪，你需要进入项目目录并输入：\ngit init\r 该命令将创建一个名为**.git**的子目录，这个子目录含有你初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。\n如果在一个已存在的文件夹（而非空文件夹）中进行版本控制。你应该开始追踪这些文件并进行初始提交。可以通过git add 命令来指定所需的文件来进行追踪，然后执行git commit：\ngit add .\rgit add LICENSE\rgit commit -m 'initial project version'\r 现在你已经得到了一个存在于被追踪文件与初始提交的Git仓库。\n克隆现有的仓库 如果你想获得一份已经存在了的Git仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这是就要用到git clone命令。Git克隆的是该Git仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。\n当你执行git clone命令时，默认的配置下远程Git胀库的每一个文件的没一个版本都将被拉下来。\ngit clone [url]\r 这会在当前目录下创建一个XX的目录，并在这个目录下初始化一个**.git**文件，从远程仓库拉取下所有数据放入**.git**文件夹，然后从中读取最新版本文件的拷贝。如果你想在克隆远程仓库的时候，自定义本地仓的名字 你可以用这个命令：\ngit clone [url] myStore\r Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用SSH 传输协议，比如 user@server:path/to/repo.git 。\n记录每次更新到仓库 现在我们手上有了一个真实的Git仓库，并从这个仓库中取出所有文件的拷贝。接下来，对这些文件做些修改，在完成一个阶段的目标之后，提交本次更新到仓库。\n记住：你工作目录下的每一个文件都不外乎两种状态：已跟踪或未跟踪。\n已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在国祚一定时间后，它们的状态可能是未修改，已修改或已放入暂存区。\n工作目录中除已跟踪文件以外的所有其他文件都属于未跟踪文件，它们即不存在于上次快照的记录中，也没有被放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。\n检查当前文件状态 可以用git status命令查看哪些文件处于什么状态。如果在克隆仓库后立即使用此命令，会看到类似这样输出：\ngit status\rOn branch master\rnothing to commit,working dirdctory clean\r 这说明你现在的工作目录相当干净，换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有任何处于未跟踪状态的新文件，否则Git会在这里列出来。最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。现在，分支名是“master”，这是默认的分支名。\nGit不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件“。这样的处理让你不必担心将生成的二进制文件或其他不想被跟踪的文件夹包含进来。\n跟踪新文件 使用git add开始跟踪一个文件。所以，比如跟踪README文件，运行：\ngit add README\r 此时再运行git status命令，会看到README文件已被跟踪，并处于暂存状态：\n$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\r 只要在Changes to be committed 这行下面，就说明已暂存状态。如果此时提交，那么该文件在你运行git add时的版本将留在历史记录中。你可能会想起之前我们使用git init后运行了**git add(files)**命令，开始跟踪当前目录下的文件。git add 命令使用文件或牡蛎的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。\n暂存已修改文件 现在我们来修改一个已被跟踪的文件。如果你修改了一个名为CONTRIBUTING。md的已被跟踪的文件，然后运行git status命令，会看到下面内容\n$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 文件CONTRIBURING。md出现在Changes not staged for commit这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行git add命令。\ngit add这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。\n将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行git add 将\u0026quot;CONTRIBUTING.md\u0026quot;放到暂存区，然后再看看 git status 的输出：\n$ git add CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\rmodified: CONTRIBUTING.md\r 现在两个文件都已暂存，下次提交就会一并记录到仓库。假设此时，你想要的在CONTRIBUTING.md里再加条注释。重新编辑存盘后，准备好提交。不过且慢，再运行git status看看：\n$ vim CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\rmodified: CONTRIBUTING.md\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 怎么回事？现在CONTRIBUTING.md文件同时出现在暂存区和非暂存区。实际上，Git只不过暂存了你运行git add命令时的版本。如果你现在提交，CONTRIBUTING.md版本是你最后一次运行git add命令时的那个版本，而不是你运行git commit是，在工作目录中的当前版本。所以，运行了git add之后又做了修订的文件，需要重新运行git add把最新版本重新暂存起来：\n$ git add CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rnew file: README\rmodified: CONTRIBUTING.md\r 状态简览 git status命令输出十分详细，但其用语有些繁琐。Git有一个选项可以帮助你缩短状态命令的输出，这样可以以简洁的方式查看更改。如果你使用git status -s命令或git status —short命令，你将得到一种格式更为紧凑的输出。\n$ git status -s\rM README\rMM Rakefile\rA lib/git.rb\rM lib/simplegit.rb\r?? LICENSE.txt\r 新添加的未跟踪文件前面有**？？**标记，\n新添加都暂存区中的文件前面有A标记，\n修改过的文件前面有M标记。\n注意：M有两个可以出现的位置，出现在右边的M表示该文件被修改了但是还没被放入暂存区。出现在靠左边的M表示该文件被修改了并被放入了暂存区。\n 例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,lib/simplegit.rb 文件被修改了并已将修改后的文件放入了暂存区。 而 Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。\r 忽略文件 一般我们总会有些文件无需纳入Git的管理，也不希望它们总出现在未被跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件。在这种情况下，我们可以创建一个名为**.gitignore**的文件，列出要忽略的文件模式。来看一个实际的**.gitignore**例子\n$ cat .gitignore\r*.[oa]\r*~\r 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。\n第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。\n此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好**.gitignore** 文件的习惯，以免将来误提交这类无用的文件。\n文件.gitignore的格式规范如下：\n 所有空行或者以#开头的行都会被Git忽略。 可以使用标准的glob模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（！）取反。  所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z , a/b/z 或 a/b/c/z 等。 我们再看一个 .gitignore 文件的例子：\n# no .a files\r*.a\r# but do track lib.a, even though you're ignoring .a files above\r!lib.a\r# only ignore the TODO file in the current directory, not subdir/TODO\r/TODO\r# ignore all files in the build/ directory\rbuild/\r# ignore doc/notes.txt, but not doc/server/arch.txt\rdoc/*.txt\r# ignore all .pdf files in the doc/ directory\rdoc/**/*.pdf\r GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在https://github.com/github/gitignore 找到它。\n查看已暂存和未暂存的修改 如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。稍后我们会详细介绍 git diff，你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？ 有哪些更新已经暂存起来准备好下次提交？ 虽然 git status 已经通过在相应栏下列出文件名的方式回答了这个问 题，但 git diff 将通过文件补丁的格式更加具体地显示哪些行发生了改变。 假如再次修改 README 文件后暂存，然后编辑 CONTRIBUTING.md 文件后先不暂存， 运行 status 命令将会看到：\n$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rmodified: README\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 要看尚未暂存的文件更新了哪些部分，不加参数直接输入git diff：\n$ git diff\rdiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\rindex 8ebb991..643e24f 100644\r--- a/CONTRIBUTING.md\r+++ b/CONTRIBUTING.md\r@@ -65,7 +65,8 @@ branch directly, things can get messy.\rPlease include a nice description of your changes when you submit your\rPR;\rif we have to read the whole diff to figure out why you're contributing\rin the first place, you're less likely to get feedback and have your\rchange\r-merged in.\r+merged in. Also, split your changes into comprehensive chunks if your\rpatch is\r+longer than a dozen lines.\rIf you are starting to work on a particular area, feel free to submit a\rPR\rthat highlights your work in progress (and note in the PR title that it's\r 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。 若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff \u0026ndash;staged 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异:\n$ git diff --staged\rdiff --git a/README b/README\rnew file mode 100644\rindex 0000000..03902a1\r--- /dev/null\r+++ b/README\r@@ -0,0 +1 @@\r+My Project\r 请注意，git diff本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。 像之前说的，暂存 CONTRIBUTING.md 后再编辑，可以使用 git status 查看已被暂存的修改或未被暂存的修改。 如果我们的环境（终端输出）看起来如下：\n$ git add CONTRIBUTING.md\r$ echo '# test line' \u0026gt;\u0026gt; CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rmodified: CONTRIBUTING.md\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 现在运行git diff看暂存前后变化：\n$ git diff\rdiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\rindex 643e24f..87f08c8 100644\r--- a/CONTRIBUTING.md\r+++ b/CONTRIBUTING.md\r@@ -119,3 +119,4 @@ at the\r## Starter Projects\rSee our [projects\rlist](\u0026lt;https://github.com/libgit2/libgit2/blob/development/PROJECTS.md\u0026gt;).\r+# test line\r 然后用git diff —cached查看已经暂存起来的变化：（\u0026ndash;staged 和 \u0026ndash;cached 是同义词）\n提交更新 现在暂存区域已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有git add 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过但没有暂存的文件只保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 git commit：\ngit commit\r 这种方式会启动文本编辑器以便输入本次提交的说明。 （默认会启用 shell 的环境变量 $EDITOR 所指定的软件，一般都是 vim 或 emacs。当然也可以按照 起步 介绍的方式，使用 git config \u0026ndash;globalcore.editor 命令设定你喜欢的编辑软件。） 编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：\n# Please enter the commit message for your changes. Lines starting\r# with '#' will be ignored, and an empty message aborts the commit.\r# On branch master\r# Changes to be committed:\r# new file: README\r# modified: CONTRIBUTING.md\r#\r~\r~\r~\r\u0026quot;.git/COMMIT_EDITMSG\u0026quot; 9L, 283C\r 可以看到，默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。 （如果想要更详细的对修改了哪些内容的提示，可以用 -v 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。） 退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。 另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示：\n$ git commit -m \u0026quot;Story 182: Fix benchmarks for speed\u0026quot;\r[master 463dc4f] Story 182: Fix benchmarks for speed\r2 files changed, 2 insertions(+)\rcreate mode 100644 README\r 好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本 次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改 过。 请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。\n跳过使用暂存区 尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存 起来一并提交，从而跳过 git add 步骤：\n$ git status\rOn branch master\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\rno changes added to commit (use \u0026quot;git add\u0026quot; and/or \u0026quot;git commit -a\u0026quot;)\r$ git commit -a -m 'added new benchmarks'\r[master 83e38c7] added new benchmarks\r1 file changed, 5 insertions(+), 0 deletions(-)\r 看到了吗？提交之前不再需要 git add 文件“CONTRIBUTING.md”了。 这是因为 -a 选项使本次提交包含了所有修改过的文件。 这很方便，但是要小心；有时这个选项会将不需要的文件添加到提交中。\n移除文件 **要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。**可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。\n如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到：\n$ rm PROJECTS.md\r$ git status\rOn branch master\rYour branch is up-to-date with 'origin/master'.\rChanges not staged for commit:\r(use \u0026quot;git add/rm \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rdeleted: PROJECTS.md\rno changes added to commit (use \u0026quot;git add\u0026quot; and/or \u0026quot;git commit -a\u0026quot;)\r 然后再运行git rm 记录此次移除文件的操作：\n$ git rm PROJECTS.md\rrm 'PROJECTS.md'\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rdeleted: PROJECTS.md\r 下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。\n另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 \u0026ndash;cached 选项：\ngit rm --cache README\r git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。 比方说：\ngit rm log/\\\\*.log\r 注意到星号 * 之前的反斜杠 \\， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。此命令删除 log/ 目录下扩展名为 .log 的所有文件。 类似的比如：\ngit rm \\\\*~\r 该命令为删除以 ~ 结尾的所有文件。\n移动文件 Git不会显式跟踪文件移动操作。\n要在Git中对文件改名：\ngit mv file_from file_to\r 实际上，运行git mv就相当于运行下面三条命令：\n$ mv README.md README\r$ git rm README.md\r$ git add README\r 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。\n查看提交历史 在提交了若干个更新，又或者克隆了某个项目之后，你想回顾一下提交历史。完成这个任务最简单而有效的工具是git log命令\n不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 git log 有许多选项可以帮助你搜寻你所要找的提交， 下面我们会介绍几个最常用的选项。 其中一个比较有用的选项是 -p，它会显示每次提交所引入的差异。 与此同时，你也可以使用 -2 选项来仅显示最近的两次提交：\n撤销操作 在任何一个阶段，你都有可能想要撤销某些操作。这里，我们将会学习几个撤销你所做修改的基本工具。注意，有些撤销操作是不可逆的。这是在使用Git的过程中，会因为操作失误而导致之前工作丢失的少有的几个地方之一。\n有时候，我们提交完发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有 —amend 选项的提交命令尝试重新提交。\ngit commit --amend\r 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。 例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\n$ git commit -m 'initial commit'\r$ git add forgotten_file\r$ git commit --amend\r 最终你只会有一个提交——第二次提交将代替第一次提交的结果。\n取消暂存的文件 接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。\n例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如何只取消暂存两个中的一个呢？ git status 命令提示了你：\n$ git add *\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rrenamed: README.md -\u0026gt; README\rmodified: CONTRIBUTING.md\r 在 “Changes to be committed” 文字正下方，提示使用 git reset HEAD \u0026hellip; 来取消暂存。 所以，我们可以这样来取消暂存 CONTRIBUTING.md 文件\n$ git reset HEAD CONTRIBUTING.md\rUnstaged changes after reset:\rM CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rrenamed: README.md -\u0026gt; README\rChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r 这样CONTRIBUTING.md 文件已经是修改未暂存的状态了。\n虽然在调用时加上 \u0026ndash;hard 选项可以令 git reset 成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！），但本例中工作目录内的文件并不会被修改。 不加选项地调用git reset 并不危险 — 它只会修改暂存区域。\n撤销对文件的修改 如果你并不想保留对 CONTRIBUTING.md 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，git status 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样\nChanges not staged for commit:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\r(use \u0026quot;git checkout -- \u0026lt;file\u0026gt;...\u0026quot; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r$ git checkout -- CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\rrenamed: README.md -\u0026gt; README\r 可以看到那些修改已经被撤销了。\n你需要知道 git checkout \u0026ndash; [file] 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失——你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。\n如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 Git 分支 介绍保存进度与分支；这些通常是更好的做法。 记住，在 Git 中任何 已提交的 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 \u0026ndash;amend 选项覆盖的提交也可以恢复（阅读 数据恢复 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。\n远程仓库的使用 为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 在本节中，我们将介绍一部分远程管理的技能。\n查看远程仓库 如果想查看你已经配置好的远程仓库服务器，可以运行git remote命令。他会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该看到origin——这是Git给你克隆的仓库服务意识的默认名字。\n$ git clone \u0026lt;https://github.com/schacon/ticgit\u0026gt;\rCloning into 'ticgit'...\rremote: Reusing existing pack: 1857, done.\rremote: Total 1857 (delta 0), reused 0 (delta 0)\rReceiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.\rResolving deltas: 100% (772/772), done.\rChecking connectivity... done.\r$ cd ticgit\r$ git remote\rorigin\r 你也可以指定选项**-v**，会显示读写远程仓库使用的Git保存的简写与其对应的URL。\n$ git remote -v\rorigin \u0026lt;https://github.com/schacon/ticgit\u0026gt; (fetch)\rorigin \u0026lt;https://github.com/schacon/ticgit\u0026gt; (push)\r 添加远程仓库 我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。 运行 **git remote add ** 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简 写：\n$ git remote\rorigin\r$ git remote add pb \u0026lt;https://github.com/paulboone/ticgit\u0026gt;\r$ git remote -v\rorigin \u0026lt;https://github.com/schacon/ticgit\u0026gt; (fetch)\rorigin \u0026lt;https://github.com/schacon/ticgit\u0026gt; (push)\rpb \u0026lt;https://github.com/paulboone/ticgit\u0026gt; (fetch)\rpb \u0026lt;https://github.com/paulboone/ticgit\u0026gt; (push)\r 现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch pb：\n$ git fetch pb\rremote: Counting objects: 43, done.\rremote: Compressing objects: 100% (36/36), done.\rremote: Total 43 (delta 10), reused 31 (delta 5)\rUnpacking objects: 100% (43/43), done.\rFrom \u0026lt;https://github.com/paulboone/ticgit\u0026gt;\r* [new branch] master -\u0026gt; pb/master\r* [new branch] ticgit -\u0026gt; pb/ticgit\r 现在 Paul 的 master 分支可以在本地通过 pb/master 访问到——你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 Git 分支 中详细介绍什么是分支以及如何使用分支。）\n从远程仓库中抓取与拉取 从远程仓库获得数据，可以执行：\ngit fetch [remote-name]\r 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工 作。 如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 Git 分支 了解更多信息），可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\n推送到远程仓库 当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：git push [remote-name] [branchname]。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：\ngit push origin master\r 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 阅读 Git 分支 了解如何推送到远程仓库服务器的详细信息。\n查看某个远程仓库 如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：\n$ git remote show origin\r* remote origin\rFetch URL: \u0026lt;https://github.com/schacon/ticgit\u0026gt;\rPush URL: \u0026lt;https://github.com/schacon/ticgit\u0026gt;\rHEAD branch: master\rRemote branches:\rmaster tracked\rdev-branch tracked\rLocal branch configured for 'git pull':\rmaster merges with remote master\rLocal ref configured for 'git push':\rmaster pushes to master (up to date)\r 它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。 这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 git remote show 看到更多的信息。\n$ git remote show origin\r* remote origin\rURL: \u0026lt;https://github.com/my-org/complex-project\u0026gt;\rFetch URL: \u0026lt;https://github.com/my-org/complex-project\u0026gt;\rPush URL: \u0026lt;https://github.com/my-org/complex-project\u0026gt;\rHEAD branch: master\rRemote branches:\rmaster tracked\rdev-branch tracked\rmarkdown-strip tracked\rissue-43 new (next fetch will store in\rremotes/origin)\rissue-45 new (next fetch will store in\rremotes/origin)\rrefs/remotes/origin/issue-11 stale (use 'git remote prune' to\rremove)\rLocal branches configured for 'git pull':\rdev-branch merges with remote dev-branch\rmaster merges with remote master\rLocal refs configured for 'git push':\rdev-branch pushes to dev-branch\r(up to date)\rmarkdown-strip pushes to markdown-strip\r(up to date)\rmaster pushes to master\r(up to date)\r 这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 git pull 时哪些分支会自动合并。\n远程仓库的移除与重命名 如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 例如，想要将 pb重命名为 paul，可以用 git remote rename 这样做：\n$ git remote rename pb paul\r$ git remote\rorigin\rpaul\r 值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 pb/master 的现在会引用 paul/master。\n如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用 git remote rm ：\n$ git remote rm paul\r$ git remote\rorigin\r ","id":45,"section":"posts","summary":"配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit）更改。配置Git来忽","tags":["Git"],"title":"Git基本操作(1)","uri":"https://zhihao2020.github.io/2020/04/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C1/","year":"2020"},{"content":"行内与独行  行内公式：将公式插入到本行内，符号：$公式内容$，如：$xyz$ 独行公式：将公式插入到新的一行内，并且居中，符号：$$公式内容$$，如：$$xyz$$  上标、下标与组合  上标符号，符号：^，如：$x^4$ 下标符号，符号：_，如：$x_1$ 组合符号，符号：{}，如：${16}{8}O{2+}{2}$  汉字、字体与格式  汉字形式，符号：\\mbox{}，如：$V_{\\mbox{初始}}$ 字体控制，符号：\\displaystyle，如：$\\displaystyle \\frac{x+y}{y+z}$ 下划线符号，符号：\\underline，如：$\\underline{x+y}$ 标签，符号\\tag{数字}，如：$\\tag{11}$ 上大括号，符号：\\overbrace{算式}，如：$\\overbrace{a+b+c+d}^{2.0}$ 下大括号，符号：\\underbrace{算式}，如：$a+\\underbrace{b+c}_{1.0}+d$ 上位符号，符号：\\stacrel{上位符号}{基位符号}，如：$\\vec{x}\\stackrel{\\mathrm{def}}{=}{x_1,\\dots,x_n}$  占位符  两个quad空格，符号：\\qquad，如：$x \\qquad y$ quad空格，符号：\\quad，如：$x \\quad y$ 大空格，符号\\，如：$x \\ y$ 中空格，符号\\:，如：$x : y$ 小空格，符号\\,，如：$x , y$ 没有空格，符号``，如：$xy$ 紧贴，符号\\!，如：$x ! y$  定界符与组合  括号，符号：（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)，如：$（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)$ 中括号，符号：[]，如：$[x+y]$ 大括号，符号：\\{ \\}，如：${x+y}$ 自适应括号，符号：\\left \\right，如：$\\left(x\\right)$，$\\left(x{yz}\\right)$ 组合公式，符号：{上位公式 \\choose 下位公式}，如：${n+1 \\choose k}={n \\choose k}+{n \\choose k-1}$ 组合公式，符号：{上位公式 \\atop 下位公式}，如：$\\sum_{k_0,k_1,\\ldots\u0026gt;0 \\atop k_0+k_1+\\cdots=n}A_{k_0}A_{k_1}\\cdots$  四则运算  加法运算，符号：+，如：$x+y=z$ 减法运算，符号：-，如：$x-y=z$ 加减运算，符号：\\pm，如：$x \\pm y=z$ 减甲运算，符号：\\mp，如：$x \\mp y=z$ 乘法运算，符号：\\times，如：$x \\times y=z$ 点乘运算，符号：\\cdot，如：$x \\cdot y=z$ 星乘运算，符号：\\ast，如：$x \\ast y=z$ 除法运算，符号：\\div，如：$x \\div y=z$ 斜法运算，符号：/，如：$x/y=z$ 分式表示，符号：\\frac{分子}{分母}，如：$\\frac{x+y}{y+z}$ 分式表示，符号：{分子} \\voer {分母}，如：${x+y} \\over {y+z}$ 绝对值表示，符号：||，如：$|x+y|$  高级运算  平均数运算，符号：\\overline{算式}，如：$\\overline{xyz}$ 开二次方运算，符号：\\sqrt，如：$\\sqrt x$ 开方运算，符号：\\sqrt[开方数]{被开方数}，如：$\\sqrt[3]{x+y}$ 对数运算，符号：\\log，如：$\\log(x)$ 极限运算，符号：\\lim，如：$\\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 极限运算，符号：\\displaystyle \\lim，如：$\\displaystyle \\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 求和运算，符号：\\sum，如：$\\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 求和运算，符号：\\displaystyle \\sum，如：$\\displaystyle \\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 积分运算，符号：\\int，如：$\\int^{\\infty}_{0}{xdx}$ 积分运算，符号：\\displaystyle \\int，如：$\\displaystyle \\int^{\\infty}_{0}{xdx}$ 微分运算，符号：\\partial，如：$\\frac{\\partial x}{\\partial y}$ 矩阵表示，符号：\\begin{matrix} \\end{matrix}，如：$\\left[ \\begin{matrix} 1 \u0026amp;2 \u0026amp;\\cdots \u0026amp;4\\5 \u0026amp;6 \u0026amp;\\cdots \u0026amp;8\\vdots \u0026amp;\\vdots \u0026amp;\\ddots \u0026amp;\\vdots\\13 \u0026amp;14 \u0026amp;\\cdots \u0026amp;16\\end{matrix} \\right]$  逻辑运算  等于运算，符号：=，如：$x+y=z$ 大于运算，符号：\u0026gt;，如：$x+y\u0026gt;z$ 小于运算，符号：\u0026lt;，如：$x+y\u0026lt;z$ 大于等于运算，符号：\\geq，如：$x+y \\geq z$ 小于等于运算，符号：\\leq，如：$x+y \\leq z$ 不等于运算，符号：\\neq，如：$x+y \\neq z$ 不大于等于运算，符号：\\ngeq，如：$x+y \\ngeq z$ 不大于等于运算，符号：\\not\\geq，如：$x+y \\not\\geq z$ 不小于等于运算，符号：\\nleq，如：$x+y \\nleq z$ 不小于等于运算，符号：\\not\\leq，如：$x+y \\not\\leq z$ 约等于运算，符号：\\approx，如：$x+y \\approx z$ 恒定等于运算，符号：\\equiv，如：$x+y \\equiv z$  集合运算  属于运算，符号：\\in，如：$x \\in y$ 不属于运算，符号：\\notin，如：$x \\notin y$ 不属于运算，符号：\\not\\in，如：$x \\not\\in y$ 子集运算，符号：\\subset，如：$x \\subset y$ 子集运算，符号：\\supset，如：$x \\supset y$ 真子集运算，符号：\\subseteq，如：$x \\subseteq y$ 非真子集运算，符号：\\subsetneq，如：$x \\subsetneq y$ 真子集运算，符号：\\supseteq，如：$x \\supseteq y$ 非真子集运算，符号：\\supsetneq，如：$x \\supsetneq y$ 非子集运算，符号：\\not\\subset，如：$x \\not\\subset y$ 非子集运算，符号：\\not\\supset，如：$x \\not\\supset y$ 并集运算，符号：\\cup，如：$x \\cup y$ 交集运算，符号：\\cap，如：$x \\cap y$ 差集运算，符号：\\setminus，如：$x \\setminus y$ 同或运算，符号：\\bigodot，如：$x \\bigodot y$ 同与运算，符号：\\bigotimes，如：$x \\bigotimes y$ 实数集合，符号：\\mathbb{R}，如：\\mathbb{R} 自然数集合，符号：\\mathbb{Z}，如：\\mathbb{Z} 空集，符号：\\emptyset，如：$\\emptyset$  数学符号  无穷，符号：\\infty，如：$\\infty$ 虚数，符号：\\imath，如：$\\imath$ 虚数，符号：\\jmath，如：$\\jmath$ 数学符号，符号\\hat{a}，如：$\\hat{a}$ 数学符号，符号\\check{a}，如：$\\check{a}$ 数学符号，符号\\breve{a}，如：$\\breve{a}$ 数学符号，符号\\tilde{a}，如：$\\tilde{a}$ 数学符号，符号\\bar{a}，如：$\\bar{a}$ 矢量符号，符号\\vec{a}，如：$\\vec{a}$ 数学符号，符号\\acute{a}，如：$\\acute{a}$ 数学符号，符号\\grave{a}，如：$\\grave{a}$ 数学符号，符号\\mathring{a}，如：$\\mathring{a}$ 一阶导数符号，符号\\dot{a}，如：$\\dot{a}$ 二阶导数符号，符号\\ddot{a}，如：$\\ddot{a}$ 上箭头，符号：\\uparrow，如：$\\uparrow$ 上箭头，符号：\\Uparrow，如：$\\Uparrow$ 下箭头，符号：\\downarrow，如：$\\downarrow$ 下箭头，符号：\\Downarrow，如：$\\Downarrow$ 左箭头，符号：\\leftarrow，如：$\\leftarrow$ 左箭头，符号：\\Leftarrow，如：$\\Leftarrow$ 右箭头，符号：\\rightarrow，如：$\\rightarrow$ 右箭头，符号：\\Rightarrow，如：$\\Rightarrow$ 底端对齐的省略号，符号：\\ldots，如：$1,2,\\ldots,n$ 中线对齐的省略号，符号：\\cdots，如：$x_1^2 + x_2^2 + \\cdots + x_n^2$ 竖直对齐的省略号，符号：\\vdots，如：$\\vdots$ 斜对齐的省略号，符号：\\ddots，如：$\\ddots$  希腊字母    字母 实现 字母 实现     A A α \\alhpa   B B β \\beta   Γ \\Gamma γ \\gamma   Δ \\Delta δ \\delta   E E ϵ \\epsilon   Z Z ζ \\zeta   H H η \\eta   Θ \\Theta θ \\theta   I I ι \\iota   K K κ \\kappa   Λ \\Lambda λ \\lambda   M M μ \\mu   N N ν \\nu   Ξ \\Xi ξ \\xi   O O ο \\omicron   Π \\Pi π \\pi   P P ρ \\rho   Σ \\Sigma σ \\sigma   T T τ \\tau   Υ \\Upsilon υ \\upsilon   Φ \\Phi ϕ \\phi   X X χ \\chi   Ψ \\Psi ψ \\psi   Ω \\v ω \\omega    这篇文章是我转自别人的，放到我的库里面，方便以后即使查阅。\n作者：DanielGavin 来源：简书 链接：https://www.jianshu.com/p/e74eb43960a1\n","id":46,"section":"posts","summary":"行内与独行 行内公式：将公式插入到本行内，符号：$公式内容$，如：$xyz$ 独行公式：将公式插入到新的一行内，并且居中，符号：$$公式内容$$","tags":["Markown"],"title":"Mrakdown中插入数学公式","uri":"https://zhihao2020.github.io/2020/04/markdown%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","year":"2020"},{"content":"常量通常定义在代码前面，并且全都大写，分割的时候用_（下划线）分割。比如想，MAX_OVERFLOW和TOTAL这样。\n Constants are usually defined on a module level and written in all capital letters with underscores separating words. Examples include MAX_OVERFLOW and TOTAL.\n 始终决定是否一个类的方法和实例变量（通常也叫“属性”）应该是公开还是不公开。如果不确定的话，选择非公共，之后让他公开会 比 让公共的属性非公开，要简单。\n Always decide whether a class\u0026rsquo;s methods and instance variables (collectively: \u0026ldquo;attributes\u0026rdquo;) should be public or non-public. If in doubt, choose non-public; it\u0026rsquo;s easier to make it public later than to make a public attribute non-public.\n 公共属性是那些 与你认为与你使用的类不相关的客户端，并且你承诺避免向后不兼容的更改。不公共的属性 是那些打算被第三方使用的属性；你不保证非公共属性不能更改或者被移除。\n Public attributes are those that you expect unrelated clients of your class to use, with your commitment to avoid backwards incompatible changes. Non-public attributes are those that are not intended to be used by third parties; you make no guarantees that non-public attributes won\u0026rsquo;t change or even be removed.\n 我们在这里不使用“私密”这个术语。因为在Python中没有属性是真正的私密（通常没有必要的工作量）。\n We don\u0026rsquo;t use the term \u0026ldquo;private\u0026rdquo; here, since no attribute is really private in Python (without a generally unnecessary amount of work).\n 另一类属性的种类是“子类API”的一部分。（在其它的语言中，经常被叫做“被保护”）。一些类被设计为从类继承，以扩展或者修改类行为的某些方面。在设计这样一个类时，要注意明确地决定哪些属性是公共的，哪些属性是子类API的一部分，哪些属性实际上只由基类使用。\n Another category of attributes are those that are part of the \u0026ldquo;subclass API\u0026rdquo; (often called \u0026ldquo;protected\u0026rdquo; in other languages). Some classes are designed to be inherited from, either to extend or modify aspects of the class\u0026rsquo;s behavior. When designing such a class, take care to make explicit decisions about which attributes are public, which are part of the subclass API, and which are truly only to be used by your base class.\n 基于这样的考虑，这里有Pyhton的建议：\n With this in mind, here are the Pythonic guidelines:\n  公共属性，前面没有下划线。   Public attributes should have no leading underscores.\n   如果你的公共属性与保留关键字冲突，在你的属性名后面加上一个_(下划线).这比缩写或者拼写错误更好。（但是，尽管有这个规定，对于已知是类的任何变量或参数，特别是类方法的第一个参数，“cls”是首选拼写。）\nNote1：有关类方法，请参阅上面的参数名称建议。\n   If your public attribute name collides with a reserved keyword, append a single trailing underscore to your attribute name. This is preferable to an abbreviation or corrupted spelling. (However, notwithstanding this rule, \u0026lsquo;cls\u0026rsquo; is the preferred spelling for any variable or argument which is known to be a class, especially the first argument to a class method.)\nNote 1: See the argument name recommendation above for class methods.\n   对于简单的公共数据变量，最好公开属性名，不用复杂的accessor/mutator方法。请记住，Python提供了一个通往未来增强的简单路径，如果你发现了一个简单的数据属性需要增长功能行为。在这种情况下，使用属性将功能实现隐藏在简单的数据属性访问语法之后。\nNote1:特性(Properties)只工作在新式类中。\nNote2：尽量使函数行为无副作用，尽管像缓存这样的副作用通常是好的\nNote3：避免使用属性进行计算开销大的操作;属性表示法使调用者相信访问是(相对)便宜的。\n   For simple public data attributes, it is best to expose just the attribute name, without complicated accessor/mutator methods. Keep in mind that Python provides an easy path to future enhancement, should you find that a simple data attribute needs to grow functional behavior. In that case, use properties to hide functional implementation behind simple data attribute access syntax.\nNote 1: Properties only work on new-style classes.\nNote 2: Try to keep the functional behavior side-effect free, although side-effects such as caching are generally fine.\nNote 3: Avoid using properties for computationally expensive operations; the attribute notation makes the caller believe that access is (relatively) cheap.\n   如果你的类被打算子类化，并且如果您不希望使用子类的属性，可以考虑使用__(双前导下划线)和无后导下划线来命名它们。这将调用Python的名称转换算法，其中类的名称将转换为属性名。这有助于避免在子类无意中包含具有相同名称的属性时发生属性名称冲突。\nNote1：注意，在混乱的名称中只使用简单的类名，因此，如果子类同时选择相同的类名和属性名，仍然会发生名称冲突。\nNote2：名称篡改可以使某些用途变得不那么方便，比如调试和getattr()。但是，名称篡改(mangling)算法有很好的文档记录，并且很容易手工执行。\nNote3：不是每个人都喜欢乱改名字。尽量平衡避免意外名称冲突与高级调用者可能使用的名称冲突的需要。\n   If your class is intended to be subclassed, and you have attributes that you do not want subclasses to use, consider naming them with double leading underscores and no trailing underscores. This invokes Python\u0026rsquo;s name mangling algorithm, where the name of the class is mangled into the attribute name. This helps avoid attribute name collisions should subclasses inadvertently contain attributes with the same name.\nNote 1: Note that only the simple class name is used in the mangled name, so if a subclass chooses both the same class name and attribute name, you can still get name collisions.\nNote 2: Name mangling can make certain uses, such as debugging and getattr(), less convenient. However the name mangling algorithm is well documented and easy to perform manually.\nNote 3: Not everyone likes name mangling. Try to balance the need to avoid accidental name clashes with potential use by advanced callers.\n 任何向后兼容性保证都只适用于公共接口。因此，用户能够清楚地区分公共接口和内部接口是很重要的。\n Any backwards compatibility guarantees apply only to public interfaces. Accordingly, it is important that users be able to clearly distinguish between public and internal interfaces.\n 文档化的接口被认为是公共的，除非文档明确声明它们是临时的或内部接口，不受通常的向后兼容性保证的约束。所有未文档化的接口都应该被认为是内部的。\n Documented interfaces are considered public, unless the documentation explicitly declares them to be provisional or internal interfaces exempt from the usual backwards compatibility guarantees. All undocumented interfaces should be assumed to be internal.\n 为了更好地支持自省，模块应该使用all属性显式地在其公共API中声明名称。将all设置为空列表表示该模块没有公共API。\n To better support introspection, modules should explicitly declare the names in their public API using the all attribute. Setting all to an empty list indicates that the module has no public API.\n 即使all进行了适当的设置，内部接口(包、模块、类、函数、属性或其他名称)仍然应该以单个前导下划线作为前缀。\n Even with all set appropriately, internal interfaces (packages, modules, classes, functions, attributes or other names) should still be prefixed with a single leading underscore.\n 如果任何包含名称空间(包、模块或类)被认为是内部的，那么接口也被认为是内部的。\n An interface is also considered internal if any containing namespace (package, module or class) is considered internal.\n 导入的名称应该始终被视为实现细节。其他模块不能依赖于对这些导入名称的间接访问，除非它们是包含模块的API(如os)的显式文档部分。从子模块公开功能的路径或包的init模块。\n Imported names should always be considered an implementation detail. Other modules must not rely on indirect access to such imported names unless they are an explicitly documented part of the containing module\u0026rsquo;s API, such as os.path or a package\u0026rsquo;s init module that exposes functionality from submodules.\n   编写代码的方式不应该损害Python的其他实现(PyPy、Jython、IronPython、Cython、Psyco等)。\n例如，对于形式为a += b或a = a + b的语句，不要依赖于CPython的就地字符串连接的高效实现。这种优化是脆弱的甚至在CPython的(只适用于某些类型)和不存在在不使用refcounting实现。在库的性能敏感部分，应该使用“.join()”形式。这将确保在不同实现之间以线性时间进行连接。\n Code should be written in a way that does not disadvantage other implementations of Python (PyPy, Jython, IronPython, Cython, Psyco, and such).\nFor example, do not rely on CPython\u0026rsquo;s efficient implementation of in-place string concatenation for statements in the form a += b or a = a + b. This optimization is fragile even in CPython (it only works for some types) and isn\u0026rsquo;t present at all in implementations that don\u0026rsquo;t use refcounting. In performance sensitive parts of the library, the \u0026lsquo;'.join() form should be used instead. This will ensure that concatenation occurs in linear time across various implementations.\n   像None这样的比较应该始终使用is或is not，而不是相等运算符。\n另外，当你真正的意思是x不是None时，要注意不要写if x。例如，当测试一个默认为None的变量或参数是否被设置为其他值时。另一个值可能具有在布尔上下文中为false的类型(例如容器)!\n Comparisons to singletons like None should always be done with is or is not, never the equality operators.\nAlso, beware of writing if x when you really mean if x is not None \u0026ndash; e.g. when testing whether a variable or argument that defaults to None was set to some other value. The other value might have a type (such as a container) that could be false in a boolean context!\n   Use is not operator rather than not \u0026hellip; is. While both expressions are functionally identical, the former is more readable and preferred.\nYes:\n if foo is not None:\r No:\n if not foo is None:\r   When implementing ordering operations with rich comparisons, it is best to implement all six operations (eq, ne, lt, le, gt, ge) rather than relying on other code to only exercise a particular comparison.\nTo minimize the effort involved, the functools.total_ordering() decorator provides a tool to generate missing comparison methods.\nPEP 207 indicates that reflexivity rules are assumed by Python. Thus, the interpreter may swap y \u0026gt; x with x \u0026lt; y, y \u0026gt;= x with x \u0026lt;= y, and may swap the arguments of x == y and x != y. The sort() and min() operations are guaranteed to use the \u0026lt; operator and the max() function uses the \u0026gt; operator. However, it is best to implement all six operations so that confusion doesn\u0026rsquo;t arise in other contexts.\n  Always use a def statement instead of an assignment statement that binds a lambda expression directly to an identifier.\nYes:\n def f(x): return 2*x\r No:\n f = lambda x: 2*x\r The first form means that the name of the resulting function object is specifically \u0026lsquo;f\u0026rsquo; instead of the generic \u0026lsquo;\u0026rsquo;. This is more useful for tracebacks and string representations in general. The use of the assignment statement eliminates the sole benefit a lambda expression can offer over an explicit def statement (i.e. that it can be embedded inside a larger expression)\n  Derive exceptions from Exception rather than BaseException. Direct inheritance from BaseException is reserved for exceptions where catching them is almost always the wrong thing to do.\nDesign exception hierarchies based on the distinctions that code catching the exceptions is likely to need, rather than the locations where the exceptions are raised. Aim to answer the question \u0026ldquo;What went wrong?\u0026rdquo; programmatically, rather than only stating that \u0026ldquo;A problem occurred\u0026rdquo; (see PEP 3151 for an example of this lesson being learned for the builtin exception hierarchy)\nClass naming conventions apply here, although you should add the suffix \u0026ldquo;Error\u0026rdquo; to your exception classes if the exception is an error. Non-error exceptions that are used for non-local flow control or other forms of signaling need no special suffix.\n  Use exception chaining appropriately. In Python 3, \u0026ldquo;raise X from Y\u0026rdquo; should be used to indicate explicit replacement without losing the original traceback.\nWhen deliberately replacing an inner exception (using \u0026ldquo;raise X\u0026rdquo; in Python 2 or \u0026ldquo;raise X from None\u0026rdquo; in Python 3.3+), ensure that relevant details are transferred to the new exception (such as preserving the attribute name when converting KeyError to AttributeError, or embedding the text of the original exception in the new exception message).\n  When raising an exception in Python 2, use raise ValueError(\u0026lsquo;message\u0026rsquo;) instead of the older form raise ValueError, \u0026lsquo;message\u0026rsquo;.\nThe latter form is not legal Python 3 syntax.\nThe paren-using form also means that when the exception arguments are long or include string formatting, you don\u0026rsquo;t need to use line continuation characters thanks to the containing parentheses.\n  When catching exceptions, mention specific exceptions whenever possible instead of using a bare except: clause:\n try:\rimport platform_specific_module\rexcept ImportError:\rplatform_specific_module = None\r A bare except: clause will catch SystemExit and KeyboardInterrupt exceptions, making it harder to interrupt a program with Control-C, and can disguise other problems. If you want to catch all exceptions that signal program errors, use except Exception: (bare except is equivalent to except BaseException:).\nA good rule of thumb is to limit use of bare \u0026lsquo;except\u0026rsquo; clauses to two cases:\n If the exception handler will be printing out or logging the traceback; at least the user will be aware that an error has occurred. If the code needs to do some cleanup work, but then lets the exception propagate upwards with raise. try\u0026hellip;finally can be a better way to handle this case.    When binding caught exceptions to a name, prefer the explicit name binding syntax added in Python 2.6:\n try:\rprocess_data()\rexcept Exception as exc:\rraise DataProcessingFailedError(str(exc))\r This is the only syntax supported in Python 3, and avoids the ambiguity problems associated with the older comma-based syntax.\n  When catching operating system errors, prefer the explicit exception hierarchy introduced in Python 3.3 over introspection of errno values.\n  Additionally, for all try/except clauses, limit the try clause to the absolute minimum amount of code necessary. Again, this avoids masking bugs.\nYes:\n try:\rvalue = collection[key]\rexcept KeyError:\rreturn key_not_found(key)\relse:\rreturn handle_value(value)\r No:\n try:\r# Too broad!\rreturn handle_value(collection[key])\rexcept KeyError:\r# Will also catch KeyError raised by handle_value()\rreturn key_not_found(key)\r   When a resource is local to a particular section of code, use a with statement to ensure it is cleaned up promptly and reliably after use. A try/finally statement is also acceptable.\n  Context managers should be invoked through separate functions or methods whenever they do something other than acquire and release resources.\nYes:\nwith conn.begin_transaction():\rdo_stuff_in_transaction(conn)\r No:\nwith conn:\rdo_stuff_in_transaction(conn)\r The latter example doesn\u0026rsquo;t provide any information to indicate that the enter and exit methods are doing something other than closing the connection after a transaction. Being explicit is important in this case.\n  Be consistent in return statements. Either all return statements in a function should return an expression, or none of them should. If any return statement returns an expression, any return statements where no value is returned should explicitly state this as return None, and an explicit return statement should be present at the end of the function (if reachable).\nYes:\n def foo(x):\rif x \u0026gt;= 0:\rreturn math.sqrt(x)\relse:\rreturn None\rdef bar(x):\rif x \u0026lt; 0:\rreturn None\rreturn math.sqrt(x)\r No:\n def foo(x):\rif x \u0026gt;= 0:\rreturn math.sqrt(x)\rdef bar(x):\rif x \u0026lt; 0:\rreturn\rreturn math.sqrt(x)\r   Use string methods instead of the string module.\nString methods are always much faster and share the same API with unicode strings. Override this rule if backwards compatibility with Pythons older than 2.0 is required.\n  Use \u0026lsquo;'.startswith() and \u0026lsquo;'.endswith() instead of string slicing to check for prefixes or suffixes.\nstartswith() and endswith() are cleaner and less error prone:\n Yes: if foo.startswith('bar'):\rNo: if foo[:3] == 'bar':\r   Object type comparisons should always use isinstance() instead of comparing types directly.\n Yes: if isinstance(obj, int):\rNo: if type(obj) is type(1):\r When checking if an object is a string, keep in mind that it might be a unicode string too! In Python 2, str and unicode have a common base class, basestring, so you can do:\n if isinstance(obj, basestring):\r Note that in Python 3, unicode and basestring no longer exist (there is only str) and a bytes object is no longer a kind of string (it is a sequence of integers instead).\n  For sequences, (strings, lists, tuples), use the fact that empty sequences are false.\n Yes: if not seq:\rif seq:\rNo: if len(seq):\rif not len(seq):\r   Don\u0026rsquo;t write string literals that rely on significant trailing whitespace. Such trailing whitespace is visually indistinguishable and some editors (or more recently, reindent.py) will trim them.\n  Don\u0026rsquo;t compare boolean values to True or False using ==.\n Yes: if greeting:\rNo: if greeting == True:\rWorse: if greeting is True:\r   Use of the flow control statements return/break/continue within the finally suite of a try\u0026hellip;finally, where the flow control statement would jump outside the finally suite, is discouraged. This is because such statements will implicitly cancel any active exception that is propagating through the finally suite.\nNo:\n def foo():\rtry:\r1 / 0\rfinally:\rreturn 42\r   With the acceptance of PEP 484, the style rules for function annotations are changing.\n  In order to be forward compatible, function annotations in Python 3 code should preferably use PEP 484 syntax. (There are some formatting recommendations for annotations in the previous section.)\n  The experimentation with annotation styles that was recommended previously in this PEP is no longer encouraged.\n  However, outside the stdlib, experiments within the rules of PEP 484 are now encouraged. For example, marking up a large third party library or application with PEP 484 style type annotations, reviewing how easy it was to add those annotations, and observing whether their presence increases code understandability.\n  The Python standard library should be conservative in adopting such annotations, but their use is allowed for new code and for big refactorings.\n  For code that wants to make a different use of function annotations it is recommended to put a comment of the form:\nnear the top of the file; this tells type checker to ignore all annotations. (More fine-grained ways of disabling complaints from type checkers can be found in PEP 484.)\n  Like linters, type checkers are optional, separate tools. Python interpreters by default should not issue any messages due to type checking and should not alter their behavior based on annotations.\n  Users who don\u0026rsquo;t want to use type checkers are free to ignore them. However, it is expected that users of third party library packages may want to run type checkers over those packages. For this purpose PEP 484 recommends the use of stub files: .pyi files that are read by the type checker in preference of the corresponding .py files. Stub files can be distributed with a library, or separately (with the library author\u0026rsquo;s permission) through the typeshed repo [5].\n  For code that needs to be backwards compatible, type annotations can be added in the form of comments. See the relevant section of PEP 484 [6].\n  PEP 526 introduced variable annotations. The style recommendations for them are similar to those on function annotations described above:\n  Annotations for module level variables, class and instance variables, and local variables should have a single space after the colon.\n  There should be no space before the colon.\n  If an assignment has a right hand side, then the equality sign should have exactly one space on both sides.\n  Yes:\n code: int\rclass Point:\rcoords: Tuple[int, int]\rlabel: str = '\u0026lt;unknown\u0026gt;'\r   No:\ncode:int # No space after colon\rcode : int # Space before colon\rclass Test:\rresult: int=0 # No spaces around equality sign\r   Although the PEP 526 is accepted for Python 3.6, the variable annotation syntax is the preferred syntax for stub files on all versions of Python (see PEP 484 for details).\n  ","id":47,"section":"posts","summary":"常量通常定义在代码前面，并且全都大写，分割的时候用_（下划线）分割。比如想，MAX_OVERFLOW和TOTAL这样。 Constants are usually defined on a module level and written in","tags":null,"title":"PEP-8——Python代码的风格指导","uri":"https://zhihao2020.github.io/2020/04/pep-8python%E4%BB%A3%E7%A0%81%E7%9A%84%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%AF%BC/","year":"2020"},{"content":"定额计价法　 定额计价法的概念 定额计价是根据招标文件，按照各国家建设行政主管部门发布的建设工程预算定额的“工程量计算规则”，同时参照省级建设主管部门发布的人工工日单价、机械台班单价、材料以及设备价格信息及同期市场价格，直接计算直接工程费，再按规定的计算计算方法计算间接费、利润、税金，汇总确定建筑安装工程造价。\n定额计价法的特点 定额计价法是我们使用了几十年的一种计价模式，其基本特征就是价格=定额+费用+文件规定，并作为法定性的依据强制执行，不论是工程招标编制标底还是投标报价均以此为唯一的依据，承发包双方共用一本定额和费用标准确定标底价和投标报价，一旦定额价与市场价脱节就会影响计价的准确性。\n定额计价是建立在以政府定价为主导的计划经济管理基础上的价格管理模式，它所体现的是政府对工程价格的直接管理和调控。\n工程量清单计价 这种计价方式，是时代的趋势，是市场经济的要求。\n工程量清单计价概念 工程量清单计价是指 投标人完成由 招标人提供的 工程量清单所需的全部费用，包括分部分项工程费、措施项目费、其他项目费、规费和税金\n工程量清单计价方式，是在建设工程招投标中，招标人自行或委托具有资质的中介机构编制反映工程实体消耗和措施性消耗的工程量清单，并作为招标文件的一部分提供给投标人，由投标人依据工程量清单自主报价的计价方式。在工程招标中采用工程量清单计价是国际上较为通行的做法。\n工程量清单计价的特点 1、工程量清单均采用了综合单价形式，综合单价中包含了工程直接费、间接费、管理费、风险费、利润、国家规定的各种规费等，一目了然，更适合工程招投标。\n2、工程量清单报价要求投标单位根据市场行情，自身实力报价，这就要求投标人注重工程单价的分析，在报价中反映本投标单位的实际能力。\n3、工程量清单报价具有合同化的法定性，本质上是单价合同的计价模式，中标后的单价一经合同确认，在竣工结算时不能调整，即量变价不变。\n4、工程量报价有利于加强合同的管理，明确承发包双方的责任，实现风险的合理分担，工程量的误差由发包方承担，工程报价的风险由投标方承担。\n5、工程量清单报价将推动计价依据的改革发展，推动企业编制自己的企业定额，提高自己的工程技术水平和经营管理能力。\n6、工程量清单计价是国际通行的计价办法，在我国实行工程量清单计价，有利于提高国内建设各方主体参与国际化竞争的能力。\n工程量清单计价与传统的定额计价的区别 抽象意义上的不同 1、工程量清单计价与定额计价不仅仅是在表现形式、计价方法上发生了变化，而是从定额管理方式和计价模式上发生了变化。首先，从思想观念上对定额管理工作有了新的认识和定位。 由于工程量清单计价提供的是计价规则、计价办法以及定额消耗量，摆脱了定额标准价格的概念，真正实现了量价分离、企业自主报价、市场有序竞争形式价格。工程量清单报价按相同的工程量和统一的计量规则，由企业根据自身情况报出综合单价，价格高低完全由企业自己确定，充分体现了企业的实力，同时也真正体现出公开、公平、公正。　采用行业统一定额计价，投标企业没有定价的发言权，只能被动接受。而工程量清单投标报价，可以充分发挥企业的能动性，企业利用自身的特点，使企业在投标中处于优势的位置。同时工程量清单报价体现了企业技术管理水平等综合实力，也促进企业在施工中加强管理、鼓励创新、从技术中要效率、从管理中要利润，在激烈的市场竞争中不断发展和壮大，企业的经营管理水平高，可以降低管理费，自有的机械设备齐全，可减少报价中的机械租赁费用，对未来要素价格发展趋势预测准确，就可以减少承包风险，增强竞争力，其结果促进了优质企业做大做强，使无资金、无技术，无管理的小企业、包工头退出市场，实现了优胜劣汰，从而形成管理规范、竞争有序的建设市场秩序。\n2、工程量清单计价是属于全面成本管理的范畴，其思路是“统一计算规则，有效控制水量，彻底放开价格，正确引导企业自主报价、市场有序竞争形成价格”。跳出传统的定额计价模式，建立一种全新的计价模式，依靠市场和企业的实力通过竞争形成价格，使业主通过企业报价可直观的了解项目造价。 具体表现的不同 1、编制对象与综合内容不同 工程量清单项目的工程内容是 以最终产品为对象，按实际完成一个综合实体项目所需工程内容列项。其工程量计算规则 是根据主体工程项目设置的，综合了清单项目的全部工程内容。\n基础定额项目主要 是以施工过程为对象划分的，工程量计算规则仅是单一的工程内容。\n2、计算口径不同 工程量清单项目工程量计算规则是 按工程实体尺寸的净量计算，不考虑施工方法和加工余量。\n基础定额则考虑了不同施工方法和加工余量的施工过程的实际数量。\n例如：土石方工程中的“挖基坑土方”，\n 按计算规范规定，工程量清单项目计算是按图示尺寸数量计算的净量（基础垫层底面积×挖土深度），不包括放坡及工作面等的开挖量。 基础定额项目计算则按实际开挖量计算，包括放坡及工作面等的开挖量，即包含了为满足施工工艺要求而增加的加工余量。  在工程量清单项目计算规范中，挖基坑土方的工程内容综合了排地表水、土方开挖、围护（挡土板）及支拆、基坑钎探、运输等内容。而在基础定额中则将上述的工程内容都作为单独的定额子目处理。\n3、计量单位不同 工程量清单项目的计量单位一般采用基本的物理计量单位或自然单位，如m^2,m^3基础定额中的计量单位 还包括扩大的物理计量单位，如100m^2，1000m^3,100m等。\n那么它们都什么时候用呢？  看合同约定，一般招投标都是清单计价 政府项目必须用清单计价，地产公司项目或私人项目可以采用 定额招标方式。  ","id":48,"section":"posts","summary":"定额计价法 定额计价法的概念 定额计价是根据招标文件，按照各国家建设行政主管部门发布的建设工程预算定额的“工程量计算规则”，同时参照省级建设主管","tags":["工程造价"],"title":"定额计价与清单计价","uri":"https://zhihao2020.github.io/2020/04/%E5%AE%9A%E9%A2%9D%E8%AE%A1%E4%BB%B7%E4%B8%8E%E6%B8%85%E5%8D%95%E8%AE%A1%E4%BB%B7/","year":"2020"},{"content":"对于爬虫来说，知道了网站的数据自增ID，那么就能将整个站点爬取下来。不过，那些大站，比如油管之类的，他们绝不会把业务的自增ID暴露出来，而是用一种可逆的字符串替代。\n一般有这么几种方法:\n 使用Hashids，Hashids是一个小型的开放源代码库，可从数字生成短的，唯一的，非顺序的ID。 Base64编码，这个方法最直接，大多数语言也具有这个功能。不过没有Hashids的花哨功能。 根据timestamp生成ID，使用计数器（如果有的话）+时间戳+一些系统值+一个随机整数。许多公司都采用这种方法，因为它在分布式系统中效果很好。这些id是彼此独立生成的，发生碰撞的风险非常小，可以忽略不计。 如果ID仅包含数字，可以使用Optimus，它基于Knuth的整数哈希方法，并产生混淆的整数ID。只有PHP和Go实现。 Nano ID，一个很小的，安全的，URL友好的，唯一的JavaScript字符串ID生成器。它也可用于多种语言。 其他的方法  使用hashids 安装\npip install hashids\r 使用\n首先初始化一个hashids示例\nfrom hashids import Hashids\r 编码（加密）\nid = hashids.encode(2)\r 生成的字符ID长度和数值大小有关。\n解码（解密）\nnum = hashids.decode('j0gW')\r 解码后返回时一个元组。如果你解码一个随机的字符串ID，不一定能恢复成数字，此时会返回空元组。\n不过，因为hashids可逆，所以拿到ID后可以反向推测出原始数字ID。我们在编码的时候可以指定盐值。理论上，盐值不泄露，就很难破解。\n指定盐值\nhashids = Hashids(salt=\u0026quot;aaa\u0026quot;)\rhashids.encode(123)\r 同样的数字使用不同的盐值编码得到的字符串是不同的，别人就无法猜出原始ID是多少了。\n限制hash长度\n默认情况下，数字越小，编码生成的字符串也比较断，为了讲不通大小的数值转化为统一长度的字符串，在初始化hashids时，可以指定hash的最小长度。\nhashids = Hashids(salt=\u0026quot;aaa\u0026quot;,min_length=10)\rhashids.encode(123)\r 限制hash的字符种类\n如果你不希望hash中有大写字母，那么可以在初始化的时候，指定hash字符串的范围，例如我们可以指定为所有的小写字母\nhashids = Hashids(alphabet=\u0026quot;abcdefghigklmopkrst\u0026quot;)\rhashids.encode(123)\r 需要注意的时候，alphabet至少要指定16个以上的不同字符。\nBase64 Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于\n$$ \\log_264=6 $$ 所以每6个比特为一个单元，可以对应某个打印字符。\n其它的方法之后会再写 ","id":49,"section":"posts","summary":"对于爬虫来说，知道了网站的数据自增ID，那么就能将整个站点爬取下来。不过，那些大站，比如油管之类的，他们绝不会把业务的自增ID暴露出来，而是","tags":["爬虫"],"title":"得到真正的业务ID","uri":"https://zhihao2020.github.io/2020/04/%E5%8F%8D%E6%89%92id%E4%B9%8Bhashids/","year":"2020"},{"content":"Git介绍 Git其实就是一个版本控制系统。它记录着文件内容的变化，你可以查阅每次修改的情况。\n其实很多人就一直在使用版本控制系统，许多人习惯把整个项目文件放到一个特定的文件夹中，并注明备份的时间以示区分。这是一个不错的整理自己文件的习惯，不过它虽然简单，但如果有时候一不小心混淆了所在的工作目录，或者写错文件，或者意外的覆盖了文件，那么就很难再将它们找回来了。\n其实除了Git，人们很早也开发了许多本地版本控制系统，早期的系统大多就是采用某种简单的数据库来记录文件历次更新的差异。但它们都是基于本地的系统。\n再后来，人们慢慢想到要让不同的开发者协同工作，这时候，就有了新的系统。它们都有单一的集中管理的服务器，服务器里保存着所有文件的修订版本。\n嗯，这样有了很大的进步。不过，把所有的鸡蛋都放在同一个菜篮子里，总是有那么些不安全。这样一来，分布式版本控制系统（DVCS)诞生了。在这个系统里，客户端是把代码仓库完整的拷贝下来，而不是像以前那样，仅仅就是最新文件的快照。这样即使服务器宕机，那么每一个拷贝下来的仓库，都能及时进行部署。\nGit就是有这个神奇功能的软件。\nGit特点 Git的三种状态 Git中的文件有三种状态。已提交（committed）、已修改（modified）和已暂存（staged）\n 已提交：表示数据已经安全保存在本地数据库中。 已修改：表示修改文件，但还没有保存都数据库中。 已暂存：表示对一个已修改文件的当前版本做了标记，是指包含了在下一次提交的快照中。  这三种状态，对应了三个工作区的概念：Git仓库、工作目录和暂存区域\nGit仓库目录，是Git用来保存项目数据和对象数据库的地方。这是Git最重要的部分。其实从其他计算机克隆仓库时，拷贝的就是这里的数据。\n工作目录 就是对项目的某个版本独立提取出来的内容。\n暂存文件 是一个文件，保存了下一次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称为“索引”\nGt直接记录快照，而非差异比较 每次你提交更新，或在Git中保存项目状态时，他主要对当时的文件制作一个快照并保存这个快照的索引。Git对待数据更像是一个快照流。\nGit中几乎所有操作都是本地执行 在Git中绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其他计算机的信息。这意味着，你在飞机或者火车上没有网络的情况下，想做些工作，你能愉快地提交，并且直到有网络连接时再上传。\nGit保证完整性 Git中的所有数据在存储前都计算校验和，然后以校验和来引用。这样，就能确保每次传输过程中，都能保证完整；如果不完整的话，Git就会及时发现。\nGit一般只添加数据 你在执行Git操作的时候，几乎只往Git数据库中增加数据，那么就很难执行不可逆的操作。当然你得需要每次都要进行提交。\n你了解了这个，我们使用Git就会很安心了。我们知道我们尝试了多种操作，而没有把事情搞糟的危险。\n当然，你也可以去参加开源社区做出贡献了！ 下一篇，我就会写关于Git的操作了。\n","id":50,"section":"posts","summary":"Git介绍 Git其实就是一个版本控制系统。它记录着文件内容的变化，你可以查阅每次修改的情况。 其实很多人就一直在使用版本控制系统，许多人习惯把","tags":["Git"],"title":"为什么要使用Git","uri":"https://zhihao2020.github.io/2020/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8git/","year":"2020"},{"content":"更新文章 hugo --theme= --baseUrl=\u0026quot;\u0026quot; --buildDrafts\rgit remote add origin https://github.com/XXX/XXX.github.io.git\rcd public\rgit add .\rgit commit -m \u0026quot;XXXX/XX/XX\u0026quot;\rgit push -u origin master\r ","id":51,"section":"posts","summary":"更新文章 hugo --theme= --baseUrl=\u0026quot;\u0026quot; --buildDrafts git remote add origin https://github.com/XXX/XXX.github.io.git cd public git add . git commit -m \u0026quot;XXXX/XX/XX\u0026quot; git push -u origin master","tags":["Hugo","Git"],"title":"Hugo的操作","uri":"https://zhihao2020.github.io/2020/04/%E6%9B%B4%E6%96%B0hugo/","year":"2020"},{"content":"简单介绍一下 汉语拼音，分为声母与韵母。全拼打字的时候，是将它们都打出来，比如[双]字 就需要打出shuang，相比双拼效率就低了。\n双拼，是将声母与韵母分开，除了zh、ch、sh之外，所有的声母都是键盘上的标准键。而把韵母分配的键盘26个按键上，这么一来每一个字字需要按两个键（一个声母和一个韵母）就可以完成输入了。\n我使用的就是[小鹤双拼]\n它为了让大家记住键位，还编了首曲子哈哈哈\n我的使用心得 使用了双拼之后，将自己所有电子设备的输入法都改为了双拼，现在，你在让我使用全拼到也很不适应了。\n从使用曲子辅助记忆到已经形成肌肉记忆，我大概花了一周的时间。之后就能熟练的使用双拼，学习新东西的那个过程是曲折的，但是一旦挺过来，那么就是光明的了。\n","id":52,"section":"posts","summary":"简单介绍一下 汉语拼音，分为声母与韵母。全拼打字的时候，是将它们都打出来，比如[双]字 就需要打出shuang，相比双拼效率就低了。 双拼，是将声","tags":null,"title":"从全拼到双拼","uri":"https://zhihao2020.github.io/2020/04/%E4%BB%8E%E5%85%A8%E6%8B%BC%E5%88%B0%E5%8F%8C%E6%8B%BC/","year":"2020"},{"content":"def teach_yourself(anything):\rwhile not creat(something):\rlearn()\rpractice()\rreturn teach_yourself(another)\rteach_yourself(something)\r 我挺赞同这个伪代码的，自学的过程就是不断学习、不断创造的过程，并将能否进行创造作为自学成功与否的关键。\n自学是时代的要求 在大学中，自学是必备的技能。学生时期是时间最为最为充分的时期，在这个时期吸足了养分，才能在接下来的漫长岁月中，更加茁壮。\n现在，是一个信息爆炸的时代，但是知识是不会爆炸的。那些之所以称为泡沫的东西，都是缺少了价值作为基础，反之，那些真正有价值的东西，是不会爆炸的，他会随着时间不断积累，不断增值。比如，现在的人工智能，它的理论在上个世纪就已经很完善了，只是当前机器的算力越来越强，才让那些理论真正的实现。\n求人不如求己，人与人之间的交往本质上就是交换，通过不断的自学，能实现自身价值的增值。在说后的社交中，也会处于更有利的地位。\n自学也是个人的一种乐趣 你不断的学习东西，通过他们进行创造，你将不断收获惊喜。并且，也会享受到之间你掌握那些手艺带来的方便、愉快。\n 用既有政策下的结果反对改革——陆铭\n 我也想通过不句话来说明，不要以为这些知识到来不了什么，只是你从未拥有，所以你才从未感受到，于是，你甚至信以为真，真的不去再学习。\n当这成为你的一种习惯，内化的你的骨子里。那么，不学习、不进步才会让你更加难受。这时你也真正的进化了。\n","id":53,"section":"posts","summary":"def teach_yourself(anything): while not creat(something): learn() practice() return teach_yourself(another) teach_yourself(something) 我挺赞同这个伪代码的，自学的过程就是不断学习、不断创造的过程，并将能否进行创造作为自学成功与否的关键。 自学是时代的要求 在","tags":null,"title":"关于自学的感想（1）","uri":"https://zhihao2020.github.io/2020/04/%E5%85%B3%E4%BA%8E%E8%87%AA%E5%AD%A6%E7%9A%84%E6%84%9F%E6%83%B31/","year":"2020"},{"content":" 人生而就是不平等的，但是在时间上却是平等的\n 珍惜自己的时间，远离焦虑 这个世界上又这么一个银行，他每天给你1440的资产，让你去消费，而且过了今天就一切清零，再给你1440.资产不会积累，只能不断消耗，但是每天的供应都是一样多。它其实就叫做时间银行。\n与其因焦虑而不断浪费自己的时间，不如去好好的利用它们、好好的享受它们。那些使用这些资产去学习、提升自己的人，其实本质上是相信自己以后的时间会更值钱。\n人就是很奇怪，对有形的东西感知能力还在线，对于那一些不容易感知的就会失去感觉，不信的话，想想你自己在家的这段时间，还能记得今天是周几吗？\n","id":54,"section":"posts","summary":"人生而就是不平等的，但是在时间上却是平等的 珍惜自己的时间，远离焦虑 这个世界上又这么一个银行，他每天给你1440的资产，让你去消费，而且过了今","tags":null,"title":"爱惜自己的时间","uri":"https://zhihao2020.github.io/2020/04/%E7%88%B1%E6%83%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E9%97%B4/","year":"2020"}],"tags":[{"title":"Git","uri":"https://zhihao2020.github.io/tags/git/"},{"title":"Hugo","uri":"https://zhihao2020.github.io/tags/hugo/"},{"title":"JupyterLab","uri":"https://zhihao2020.github.io/tags/jupyterlab/"},{"title":"Markown","uri":"https://zhihao2020.github.io/tags/markown/"},{"title":"PyQt5","uri":"https://zhihao2020.github.io/tags/pyqt5/"},{"title":"Python代码学习","uri":"https://zhihao2020.github.io/tags/python%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"title":"Python内建函数","uri":"https://zhihao2020.github.io/tags/python%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"title":"Python标准库","uri":"https://zhihao2020.github.io/tags/python%E6%A0%87%E5%87%86%E5%BA%93/"},{"title":"Python魔法方法","uri":"https://zhihao2020.github.io/tags/python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"},{"title":"SQLite","uri":"https://zhihao2020.github.io/tags/sqlite/"},{"title":"办公自动化","uri":"https://zhihao2020.github.io/tags/%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"title":"可视化","uri":"https://zhihao2020.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"title":"工程造价","uri":"https://zhihao2020.github.io/tags/%E5%B7%A5%E7%A8%8B%E9%80%A0%E4%BB%B7/"},{"title":"爬虫","uri":"https://zhihao2020.github.io/tags/%E7%88%AC%E8%99%AB/"},{"title":"错误记录","uri":"https://zhihao2020.github.io/tags/%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/"}]}